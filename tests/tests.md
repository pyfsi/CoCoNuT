# Tests

## Idea

Unit tests are particularly important to developers to debug their code separately from other coupling components. These 
unit tests also offer an opportunity to quickly check whether the installation of the package was successful, as mentioned 
on the [start page](../README.md#quick-test). 

The remainder of this documentation page focuses on running these tests. The first section explains the procedure to run
(almost) all tests at once, which is useful for the post-installation test. The second section contains information on how to 
include the unit test of a solver wrapper in the testing framework. Finally, it is explained how to run a single test file,
test class or test method. The latter is useful in the development of a new solver wrappers to quickly test a single 
aspect of the wrapper without having to test all aspects together, which can be time-consuming. 

## Running unit tests

### Running unit tests
The unit tests in CoCoNuT uses the unittest module available in Python. 
To run the default collection of tests which evaluates in a matter of seconds, navigate to the _`coconut/tests/`_ directory 
and type following command in the terminal:
```bash
python3 run_tests.py
```
This command will run all tests excluding the solver wrapper tests that are not pure Python.
These tests are excluded because they each take several minutes to complete.
The above command is equivalent to 
```bash
python3 run_tests.py -fast
```
It is equally possible to run all test by using the keyword `-all` as follows
```bash
python3 run_tests.py -all
```
Besides these two predefined keywords, it is also possible to use (a set of) arbitrary keywords.
For example
```bash
python3 run_tests.py fluent abaqus
```
will run all tests that have the `fluent` or `abaqus` in its path: for example
`coconut.tests.solver_wrappers.fluent.test_v2023R1.test_move_nodes`.

Starting from Anaconda 2023.09, to run a specific test, it is sufficient to provide the full path, for example
```bash
python3 run_tests.py solver_wrappers.fluent.test_v2023R1.TestSolverWrapperFluent2023R1Tube3D.test_partitioning
```
Here, only the test method `test_partitioning` is run in the `TestSolverWrapperFluent2023R1Tube3D` class.
Similarly, to run all methods in a particular class, it is sufficient to include the path up to the class name (or simply the class name itself, if there exists no duplicate).

Besides the method of running tests explained above, it is also possible to use commands of the form
```bash
python3 -m unittest -bv
```
Here, the keyword `discover` is assumed silently and all unit tests in modules named `test*.py`_ will be looked for.
It will recursively find all the test files with this pattern for all the folders containing an _`__init__.py`_ file. 
The `-b` keyword suppresses any output generated by the part of the code that is being tested, unless an error occurs or a test fails. 
Finally, the `-v` keyword enables a higher verbosity, as such the user can see what test methods have been run. Further documentation 
on the Python unit test framework can be found on the [Python documentation website](https://docs.python.org/3/library/unittest.html).

To run a specific test for earlier Python versions, it is required to use
```bash
python3 -m unittest -bv solver_wrappers.fluent.test_v2023R1.TestSolverWrapperFluent2023R1Tube3D.test_partitioning
```

### What if solver software is not available
If a solver wrapper test is run, but the software is not available, the test will automatically be skipped and the non-availability wil be given
as the reason.
The availability of software is checked using the _`solver_modules.py`_ file.