{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"index.html","text":"Coupling Code for Numerical Tools CoCoNuT is a light-weight Python package for efficient partitioned multi-physics simulations, with a focus on fluid-structure interaction. Thanks to its fully modular approach, the package is versatile and easy to extend. It is available under the GPL-3.0 license. Introduction The Coupling Code for Numerical Tools \u2014 CoCoNuT in short \u2014 follows a partitioned approach to solve multi-physics problems: existing single-physics solvers are coupled through a Python interface. This has the advantage that dedicated, highly-optimized single-physics solvers can be used. To use the code with a new solver (open source or commercial), a so-called solver wrapper is written to take care of the communication with CoCoNuT. All other CoCoNuT components, such as mapping for non-conformal meshes, are solver-independent and are easily swapped thanks to CoCoNuT's modular architecture. CoCoNuT is under active development by the Fluid Mechanics research team at Ghent University. Our specialization is partitioned fluid-structure interaction. We develop high-performance quasi-Newton algorithms to accelerate convergence of the coupled problem, and apply these techniques to diverse fluid-structure interaction applications such as wind turbines, tube bundles and flexible aircraft. The full documentation of the CoCoNuT package can be found at the documentation website . Installation These instructions describe the setup of CoCoNuT on Linux. The package has not been tested on Windows or macOS, so compatibility is not guaranteed, although we do not expect major issues. Requirements python>=3.6 numpy>=1.16.4 scipy>=1.3.0 pandas>=0.24.2 (required for Kratos solver wrapper ) matplotlib=3.1.0 (recommended) We recommend Anaconda 2019.07 or newer. Installation procedure CoCoNuT does not need to be compiled, hence installation is straightforward. The source code can be downloaded as a zip file, or cloned directly from GitHub. For users that have no experience with Git or GitHub, we recommend the first option. The second option makes it easier to update the software and contribute to the code. Option 1: download zip Download the source code from GitHub . Unzip to a folder coconut . If the folder is unzipped in Windows, some of the file permissions may change and some tests or examples may not run out of the box. Option 2: clone source Choose or create a directory to install CoCoNuT. Move to this directory. Clone the GitHub repository with SSH or HTTPS by executing one of the following commands. With SSH: git clone git@github.com:pyfsi/coconut.git With HTTPS: git clone https://github.com/pyfsi/coconut.git After the code has been downloaded or cloned, the coconut folder must be added to the user's Python path. For example, with a folder structure like /some/absolute/path/ coconut/ coupling_components/ data_structure/ ... README.md coconut can be added to your Python path by executing the following line: export PYTHONPATH = /some/absolute/path: $PYTHONPATH This line can also be added to your .bashrc file. Checking the solver modules Before using CoCoNuT, it is necessary to adapt some system specific commands in the solver_modules.py file in the coconut folder. This file has the commands to load solver modules in separate environments when running a case, to avoid conflicts. As these commands are system specific, it is important to check this file before testing CoCoNuT. The file contains a nested dictionary solver_load_cmd_dict , which has keys such as ugent_cluster_SL6.3 or ugent_cluster_CO7 denoting the machine on which CoCoNuT is installed. In their turn, each of these dictionaries contains keys for all solvers that are available on that machine and can be used in CoCoNuT. The values are strings containing terminal commands to load the software, thus setting the environment which allows running the solver. For example, on the UGent cluster, the Lmod system is used, but there is no general guideline on how to make the solvers' software available as long as it is compatible with your system's command-line-interface. If multiple commands are needed, they should appropriately be separated within the string. For example in a Linux terminal the semi-colon (;) or double ampersand (&&) can be used. Since machine_name is set to ugent_cluster_SL6.3 , this dictionary is used by default. In case your system differs from the ugent_cluster_SL6.3 settings, it is advised to add your own internal dictionary to solver_load_cmd_dict and provide this key to machine_name . If a solver module is not present on your system the key should be removed. If a solver module is always present, i.e. no module load command or similar action is needed, an empty string should be given as value. When CoCoNuT tries to use a solver module that is not present in the solver_load_cmd_dict or that has the wrong value, an error will be raised. Quick test We recommend to run the unit tests at the end of the installation, to make sure that everything works. Ensure that coconut is included in your Python path. Move to the coconut/tests directory. Run the unit tests by executing the following line: python -m unittest -b Getting started Once the CoCoNuT package has been successfully installed, it is time to run a first coupled simulation. For this purpose, we give a step-by-step guide of an example case included in the source code. In this example the fluid-structure interaction (FSI) problem of a pressure wave propagating through an elastic tube in incompressible flow is calculated [ 1 , 2 ]. For both the flow and structure solver, we use 1D Python-solvers that are included in CoCoNuT. This has the advantage that no external single-physics solvers must be installed for this example. Furthermore, the 1D solvers are very fast, so that a full transient FSI calculation can be done in this example. Other example cases in the source code solve the same FSI problem with ANSYS Fluent or OpenFOAM as flow solver and Abaqus or Kratos as structure solver. We start by creating a variable COCO in which we can store the path to the folder in which CoCoNuT is installed. We will use this variable to avoid any confusion about relative or absolute paths in this tutorial. Using the example installation location from above: COCO = /some/absolute/path We can now navigate to the folder of the example we will simulate. cd $COCO /coconut/examples/tube_tube_flow_tube_structure/ This folder serves as main directory to set up and run the FSI simulation from in CoCoNuT. The file parameters.json will be used to run the actual FSI simulation, but we will come back to that later. First we must set up both single-physics solvers separately. This setup is typically done outside of CoCoNuT by the user, as it is solver and case specific. In this case we provide a script setup.py that sets up both solvers using the files in the folder ../setup_files . When the script is run with python3 setup.py new folders CFD and CSM appear, as well as the file run_simulation.py . The CFD folder contains all files required to start a simulation of the flow in the tube. Analogously, the CSM folder contains all files required to start a simulation of the tube structure. We can now start the FSI simulation in CoCoNuT by running the Python file run_simulation.py : python3 run_simulation.py The simulation should start, first printing the CoCoNuT ASCII-banner and some information about the settings of the FSI simulation. Then the simulation itself strats: in each time step, the residual is given for every coupling iteration. When the simulation has finished, a summary about the computational effort is printed. Let us now take a closer look at the two files that are used to run CoCoNuT. The Python file run_simulation.py typically does not have to be adapted by the user. Its task is to read in the settings file parameters.json and launch a simulation using those settings. The file parameters.json is a collection of settings that is written in JSON format . JSON is a language-independent text format that is easy to read and write, and is used for data-exchange. It consists mainly of key-value pairs, and can hence be easily converted to a (nested) Python dictionary. While the keys are always strings, the values can be strings, numbers, arrays, booleans or nested JSON objects (nested dictionaries). Before you read on, it can be useful to familiarize yourself with the JSON syntax. In what follows, we will use Python terminology (dictionary, list, boolean, etc...) to refer to the structure and the values in the JSON file. The JSON file is built up in a hierarchical way that represents the objects created in the CoCoNuT simulation. At the highest level, the dictionary contains two keys: settings and coupled_solver . The value given to the settings key is a nested dictionary, which contains a single key-value pair that sets the number of time steps to be simulated. The value given to the coupled_solver key is a special dictionary, because it has the type key. CoCoNuT will generate an object of the specified type, namely coupled_solvers.iqni . This refers to the class defined in the file $COCO/coconut/coupling_components/coupled_solvers/iqni.py : the CoupledSolverIQNI class. Note that the value in type always refers to a file located in $COCO/coconut/coupling_components . The dictionary under settings is used to initialize an instance of this class. In this case the initial time timestep_start , the time step delta_t and some other parameters must be given. The coupled solver is the main class that determines how the two single-physics solvers are coupled. The dictionary that is given to the coupled_solver key contains next to type and settings three other key-value pairs. These will generate other objects: the fact that they are given in the coupled_solver dictionary means that these objects will be created by the coupled solver object. predictor will generate an object of the PredictorLinear class found in the file $COCO/coconut/coupling_components/predictors/linear.py . This class requires no additional settings for its initialization. The predictor object is used to extrapolate the solution to the next time step. convergence_criterion will generate an object of the ConvergenceCriterionOr class found in the file $COCO/coconut/coupling_components/convergence_criteria/or.py , using the given settings for its initialization. The convergence criterion is used to determine when CoCoNuT should move to the next time step. In this case the or criterion is used, which signals convergence when one or both underlying criteria are satisfied. These underlying criteria are instances of the ConvergenceCriterionIterationLimit and ConvergenceCriterionRelativeNorm classes defined in respectively $COCO/coconut/coupling_components/convergence_criteria/iteration_limit.py and $COCO/coconut/coupling_components/convergence_criteria/relative_norm.py . This means that CoCoNuT will move to the next time step after 15 iterations or when the 2-norm of the residual has decreased six orders of magnitude. solver_wrappers is a list of two solver wrapper objects, which will communicate with the two single-physics solvers, in this case the 1D flow solver and the 1D structure solver. The first dictionary in the list will generate an instance of the SolverWrapperTubeFlow class found in $COCO/coconut/coupling_components/solver_wrappers/python/tube_flow_solver.py . An important setting to generate this object is the working_directory , which refers to the folder CFD that we created with the case files of the flow solver. All files written by the flow solver will also appear in this folder. We would now expect the second dictionary to generate a solver wrapper to communicate with the structure solver, i.e. an instance of the SolverWrapperTubeStructure class found in $COCO/coconut/coupling_components/solver_wrappers/python/tube_structure_solver.py . This is not the case however: the flow and structure solvers typically use a different geometrical discretization (computational grid or mesh), hence they cannot readily be coupled in CoCoNuT. To overcome this issue, we put a layer of mapping around one of the solver wrappers. This is done with the SolverWrapperMapped class found in $COCO/coconut/coupling_components/solver_wrappers/mapped.py . The mapped solver wrapper interpolates all data flowing between the coupled solver and the real solver wrapper. The mapped solver wrapper itself contains three objects: the actual solver wrapper ( SolverWrapperTubeStructure class), and mappers for respectively the input and the output of the solver wrapper (both MapperInterface class, found in $COCO/coconut/coupling_components/mappers/interface.py ). The concept of the mapped solver wrapper illustrates the modularity of CoCoNuT. As far as the coupled solver is concerned, the mapped solver wrapper acts exactly as a real solver wrapper. The real solver wrapper does not know about the mapping at all: it acts as if it directly communicates with the coupled solver. Furthermore, the interpolation method can be easily changed by swapping the mappers in the mapped solver wrapper: the current linear interpolation scheme can for example be replaced by a radial basis scheme by changing mappers.linear to mappers.radial_basis . Now try to change some of the settings in the JSON file, such as the mappers, the time step or the maximum number of coupling iterations, and rerun the coupled simulation. After a simulation is finished, it can be useful to visualize the output quantities (i.e. displacement, pressure and in general also shear). For the FSI-simulation we have just performed, post-processing has already been implemented in the file $COCO/coconut/examples/post_processing/ . It requires the save_results setting in the coupled_solver part of the JSON-file to be set on true , which is for all examples done by default. As an example, we will generate an animation by running the animate_example.py file: python $COCO /coconut/examples/post_processing/animate_example.py Animations of the displacement and pressure will be shown. Overview of the code The CoCoNuT package consists of 5 main folders: coupling_components , data_structure , docs , examples and tests . To give a general understanding of how the code is structured, we give a brief description of the purpose of each folder. The documentation website mirrors this folder structure and the folder names below link to the corresponding page. coupling_components This folder contains the basic building blocks of CoCoNuT, which can be used to set up a coupled simulation. This includes among others the solver wrappers, to communicate with single-physics solvers, and the mappers, which provide interpolation between non-conforming meshes present in the different single-physics solvers. data_structure This folder contains the data structure that is used internally in CoCoNuT to store and pass around information obtained from the single-physics solvers. The data structure relies on NumPy arrays for efficient storage and manipulation of data. docs This folder serves to automatically generate the documentation website, based on the MarkDown documentation files that are present throughout the code. examples This folder contains examples of several fluid-structure interaction cases, which can serve as starting point for settings up the user's own simulation. They also provide insight into the capabilities of CoCoNuT. tests This folder contains the unit tests. These are created for each piece of code that is added to CoCoNuT and are run regularly, to avoid bugs. References [1] Degroote J., Annerel S. and Vierendeels J., \"Stability analysis of Gauss-Seidel iterations in a partitioned simulation of fluid-structure interaction\", Computers & Structures, vol. 88, no. 5-6, pp. 263, 2010. [2] Delaiss\u00e9 N., Demeester T., Fauconnier D. and Degroote J., \"Comparison of different quasi-Newton techniques for coupling of black box solvers\", in ECCOMAS 2020, Proceedings, Paris, France, 2021.","title":"Introduction"},{"location":"index.html#coupling-code-for-numerical-tools","text":"CoCoNuT is a light-weight Python package for efficient partitioned multi-physics simulations, with a focus on fluid-structure interaction. Thanks to its fully modular approach, the package is versatile and easy to extend. It is available under the GPL-3.0 license.","title":"Coupling Code for Numerical Tools"},{"location":"index.html#introduction","text":"The Coupling Code for Numerical Tools \u2014 CoCoNuT in short \u2014 follows a partitioned approach to solve multi-physics problems: existing single-physics solvers are coupled through a Python interface. This has the advantage that dedicated, highly-optimized single-physics solvers can be used. To use the code with a new solver (open source or commercial), a so-called solver wrapper is written to take care of the communication with CoCoNuT. All other CoCoNuT components, such as mapping for non-conformal meshes, are solver-independent and are easily swapped thanks to CoCoNuT's modular architecture. CoCoNuT is under active development by the Fluid Mechanics research team at Ghent University. Our specialization is partitioned fluid-structure interaction. We develop high-performance quasi-Newton algorithms to accelerate convergence of the coupled problem, and apply these techniques to diverse fluid-structure interaction applications such as wind turbines, tube bundles and flexible aircraft. The full documentation of the CoCoNuT package can be found at the documentation website .","title":"Introduction"},{"location":"index.html#installation","text":"These instructions describe the setup of CoCoNuT on Linux. The package has not been tested on Windows or macOS, so compatibility is not guaranteed, although we do not expect major issues.","title":"Installation"},{"location":"index.html#requirements","text":"python>=3.6 numpy>=1.16.4 scipy>=1.3.0 pandas>=0.24.2 (required for Kratos solver wrapper ) matplotlib=3.1.0 (recommended) We recommend Anaconda 2019.07 or newer.","title":"Requirements"},{"location":"index.html#installation-procedure","text":"CoCoNuT does not need to be compiled, hence installation is straightforward. The source code can be downloaded as a zip file, or cloned directly from GitHub. For users that have no experience with Git or GitHub, we recommend the first option. The second option makes it easier to update the software and contribute to the code. Option 1: download zip Download the source code from GitHub . Unzip to a folder coconut . If the folder is unzipped in Windows, some of the file permissions may change and some tests or examples may not run out of the box. Option 2: clone source Choose or create a directory to install CoCoNuT. Move to this directory. Clone the GitHub repository with SSH or HTTPS by executing one of the following commands. With SSH: git clone git@github.com:pyfsi/coconut.git With HTTPS: git clone https://github.com/pyfsi/coconut.git After the code has been downloaded or cloned, the coconut folder must be added to the user's Python path. For example, with a folder structure like /some/absolute/path/ coconut/ coupling_components/ data_structure/ ... README.md coconut can be added to your Python path by executing the following line: export PYTHONPATH = /some/absolute/path: $PYTHONPATH This line can also be added to your .bashrc file.","title":"Installation procedure"},{"location":"index.html#checking-the-solver-modules","text":"Before using CoCoNuT, it is necessary to adapt some system specific commands in the solver_modules.py file in the coconut folder. This file has the commands to load solver modules in separate environments when running a case, to avoid conflicts. As these commands are system specific, it is important to check this file before testing CoCoNuT. The file contains a nested dictionary solver_load_cmd_dict , which has keys such as ugent_cluster_SL6.3 or ugent_cluster_CO7 denoting the machine on which CoCoNuT is installed. In their turn, each of these dictionaries contains keys for all solvers that are available on that machine and can be used in CoCoNuT. The values are strings containing terminal commands to load the software, thus setting the environment which allows running the solver. For example, on the UGent cluster, the Lmod system is used, but there is no general guideline on how to make the solvers' software available as long as it is compatible with your system's command-line-interface. If multiple commands are needed, they should appropriately be separated within the string. For example in a Linux terminal the semi-colon (;) or double ampersand (&&) can be used. Since machine_name is set to ugent_cluster_SL6.3 , this dictionary is used by default. In case your system differs from the ugent_cluster_SL6.3 settings, it is advised to add your own internal dictionary to solver_load_cmd_dict and provide this key to machine_name . If a solver module is not present on your system the key should be removed. If a solver module is always present, i.e. no module load command or similar action is needed, an empty string should be given as value. When CoCoNuT tries to use a solver module that is not present in the solver_load_cmd_dict or that has the wrong value, an error will be raised.","title":"Checking the solver modules"},{"location":"index.html#quick-test","text":"We recommend to run the unit tests at the end of the installation, to make sure that everything works. Ensure that coconut is included in your Python path. Move to the coconut/tests directory. Run the unit tests by executing the following line: python -m unittest -b","title":"Quick test"},{"location":"index.html#getting-started","text":"Once the CoCoNuT package has been successfully installed, it is time to run a first coupled simulation. For this purpose, we give a step-by-step guide of an example case included in the source code. In this example the fluid-structure interaction (FSI) problem of a pressure wave propagating through an elastic tube in incompressible flow is calculated [ 1 , 2 ]. For both the flow and structure solver, we use 1D Python-solvers that are included in CoCoNuT. This has the advantage that no external single-physics solvers must be installed for this example. Furthermore, the 1D solvers are very fast, so that a full transient FSI calculation can be done in this example. Other example cases in the source code solve the same FSI problem with ANSYS Fluent or OpenFOAM as flow solver and Abaqus or Kratos as structure solver. We start by creating a variable COCO in which we can store the path to the folder in which CoCoNuT is installed. We will use this variable to avoid any confusion about relative or absolute paths in this tutorial. Using the example installation location from above: COCO = /some/absolute/path We can now navigate to the folder of the example we will simulate. cd $COCO /coconut/examples/tube_tube_flow_tube_structure/ This folder serves as main directory to set up and run the FSI simulation from in CoCoNuT. The file parameters.json will be used to run the actual FSI simulation, but we will come back to that later. First we must set up both single-physics solvers separately. This setup is typically done outside of CoCoNuT by the user, as it is solver and case specific. In this case we provide a script setup.py that sets up both solvers using the files in the folder ../setup_files . When the script is run with python3 setup.py new folders CFD and CSM appear, as well as the file run_simulation.py . The CFD folder contains all files required to start a simulation of the flow in the tube. Analogously, the CSM folder contains all files required to start a simulation of the tube structure. We can now start the FSI simulation in CoCoNuT by running the Python file run_simulation.py : python3 run_simulation.py The simulation should start, first printing the CoCoNuT ASCII-banner and some information about the settings of the FSI simulation. Then the simulation itself strats: in each time step, the residual is given for every coupling iteration. When the simulation has finished, a summary about the computational effort is printed. Let us now take a closer look at the two files that are used to run CoCoNuT. The Python file run_simulation.py typically does not have to be adapted by the user. Its task is to read in the settings file parameters.json and launch a simulation using those settings. The file parameters.json is a collection of settings that is written in JSON format . JSON is a language-independent text format that is easy to read and write, and is used for data-exchange. It consists mainly of key-value pairs, and can hence be easily converted to a (nested) Python dictionary. While the keys are always strings, the values can be strings, numbers, arrays, booleans or nested JSON objects (nested dictionaries). Before you read on, it can be useful to familiarize yourself with the JSON syntax. In what follows, we will use Python terminology (dictionary, list, boolean, etc...) to refer to the structure and the values in the JSON file. The JSON file is built up in a hierarchical way that represents the objects created in the CoCoNuT simulation. At the highest level, the dictionary contains two keys: settings and coupled_solver . The value given to the settings key is a nested dictionary, which contains a single key-value pair that sets the number of time steps to be simulated. The value given to the coupled_solver key is a special dictionary, because it has the type key. CoCoNuT will generate an object of the specified type, namely coupled_solvers.iqni . This refers to the class defined in the file $COCO/coconut/coupling_components/coupled_solvers/iqni.py : the CoupledSolverIQNI class. Note that the value in type always refers to a file located in $COCO/coconut/coupling_components . The dictionary under settings is used to initialize an instance of this class. In this case the initial time timestep_start , the time step delta_t and some other parameters must be given. The coupled solver is the main class that determines how the two single-physics solvers are coupled. The dictionary that is given to the coupled_solver key contains next to type and settings three other key-value pairs. These will generate other objects: the fact that they are given in the coupled_solver dictionary means that these objects will be created by the coupled solver object. predictor will generate an object of the PredictorLinear class found in the file $COCO/coconut/coupling_components/predictors/linear.py . This class requires no additional settings for its initialization. The predictor object is used to extrapolate the solution to the next time step. convergence_criterion will generate an object of the ConvergenceCriterionOr class found in the file $COCO/coconut/coupling_components/convergence_criteria/or.py , using the given settings for its initialization. The convergence criterion is used to determine when CoCoNuT should move to the next time step. In this case the or criterion is used, which signals convergence when one or both underlying criteria are satisfied. These underlying criteria are instances of the ConvergenceCriterionIterationLimit and ConvergenceCriterionRelativeNorm classes defined in respectively $COCO/coconut/coupling_components/convergence_criteria/iteration_limit.py and $COCO/coconut/coupling_components/convergence_criteria/relative_norm.py . This means that CoCoNuT will move to the next time step after 15 iterations or when the 2-norm of the residual has decreased six orders of magnitude. solver_wrappers is a list of two solver wrapper objects, which will communicate with the two single-physics solvers, in this case the 1D flow solver and the 1D structure solver. The first dictionary in the list will generate an instance of the SolverWrapperTubeFlow class found in $COCO/coconut/coupling_components/solver_wrappers/python/tube_flow_solver.py . An important setting to generate this object is the working_directory , which refers to the folder CFD that we created with the case files of the flow solver. All files written by the flow solver will also appear in this folder. We would now expect the second dictionary to generate a solver wrapper to communicate with the structure solver, i.e. an instance of the SolverWrapperTubeStructure class found in $COCO/coconut/coupling_components/solver_wrappers/python/tube_structure_solver.py . This is not the case however: the flow and structure solvers typically use a different geometrical discretization (computational grid or mesh), hence they cannot readily be coupled in CoCoNuT. To overcome this issue, we put a layer of mapping around one of the solver wrappers. This is done with the SolverWrapperMapped class found in $COCO/coconut/coupling_components/solver_wrappers/mapped.py . The mapped solver wrapper interpolates all data flowing between the coupled solver and the real solver wrapper. The mapped solver wrapper itself contains three objects: the actual solver wrapper ( SolverWrapperTubeStructure class), and mappers for respectively the input and the output of the solver wrapper (both MapperInterface class, found in $COCO/coconut/coupling_components/mappers/interface.py ). The concept of the mapped solver wrapper illustrates the modularity of CoCoNuT. As far as the coupled solver is concerned, the mapped solver wrapper acts exactly as a real solver wrapper. The real solver wrapper does not know about the mapping at all: it acts as if it directly communicates with the coupled solver. Furthermore, the interpolation method can be easily changed by swapping the mappers in the mapped solver wrapper: the current linear interpolation scheme can for example be replaced by a radial basis scheme by changing mappers.linear to mappers.radial_basis . Now try to change some of the settings in the JSON file, such as the mappers, the time step or the maximum number of coupling iterations, and rerun the coupled simulation. After a simulation is finished, it can be useful to visualize the output quantities (i.e. displacement, pressure and in general also shear). For the FSI-simulation we have just performed, post-processing has already been implemented in the file $COCO/coconut/examples/post_processing/ . It requires the save_results setting in the coupled_solver part of the JSON-file to be set on true , which is for all examples done by default. As an example, we will generate an animation by running the animate_example.py file: python $COCO /coconut/examples/post_processing/animate_example.py Animations of the displacement and pressure will be shown.","title":"Getting started"},{"location":"index.html#overview-of-the-code","text":"The CoCoNuT package consists of 5 main folders: coupling_components , data_structure , docs , examples and tests . To give a general understanding of how the code is structured, we give a brief description of the purpose of each folder. The documentation website mirrors this folder structure and the folder names below link to the corresponding page.","title":"Overview of the code"},{"location":"index.html#coupling_components","text":"This folder contains the basic building blocks of CoCoNuT, which can be used to set up a coupled simulation. This includes among others the solver wrappers, to communicate with single-physics solvers, and the mappers, which provide interpolation between non-conforming meshes present in the different single-physics solvers.","title":"coupling_components"},{"location":"index.html#data_structure","text":"This folder contains the data structure that is used internally in CoCoNuT to store and pass around information obtained from the single-physics solvers. The data structure relies on NumPy arrays for efficient storage and manipulation of data.","title":"data_structure"},{"location":"index.html#docs","text":"This folder serves to automatically generate the documentation website, based on the MarkDown documentation files that are present throughout the code.","title":"docs"},{"location":"index.html#examples","text":"This folder contains examples of several fluid-structure interaction cases, which can serve as starting point for settings up the user's own simulation. They also provide insight into the capabilities of CoCoNuT.","title":"examples"},{"location":"index.html#tests","text":"This folder contains the unit tests. These are created for each piece of code that is added to CoCoNuT and are run regularly, to avoid bugs.","title":"tests"},{"location":"index.html#references","text":"[1] Degroote J., Annerel S. and Vierendeels J., \"Stability analysis of Gauss-Seidel iterations in a partitioned simulation of fluid-structure interaction\", Computers & Structures, vol. 88, no. 5-6, pp. 263, 2010. [2] Delaiss\u00e9 N., Demeester T., Fauconnier D. and Degroote J., \"Comparison of different quasi-Newton techniques for coupling of black box solvers\", in ECCOMAS 2020, Proceedings, Paris, France, 2021.","title":"References"},{"location":"abaqus.html","text":"Abaqus This is the documentation for all Abaqus solver wrappers. Abaqus is a structural solver implementing the finite element method. Currently this wrapper only supports FSI simulations, no other multi-physics problems. Subcycling within the structural solver is possible. Fluid-structure interaction with Abaqus Abaqus (Dassault Syst\u00e8mes) can be used to solve for the structural displacement/deformation in partitioned FSI-simulations. The FSI interface consist of a surfaces in the Abaqus model, where pressure and surface traction loads are applied, and corresponding node sets , where the resulting computed displacements are returned to the solver wrapper. The loads are applied in so-called load points (Gauss points, quadrature points), the displacements are exported in the elements' nodes. The input loads are collected in one or more ModelParts in the input Interface , the output nodes are collected in one or more ModelParts of the output Interface . Each ModelPart on the input Interface has a counterpart on the output Interface . More information about ModelParts and Interface can be found in the data structure documentation . Terminology Main directory: Directory where the analysis is started. Working directory: Subdirectory of the main directory in which Abaqus runs. Source directory: Directory where the source files of the Abaqus solver wrapper are found: coupling_components/solver_wrappers/abaqus . Extra directory: Subdirectory of the source directory with some files to assist with the setup. Geometrical nodes: Nodes in Abaqus related to the geometry of the elements. At these nodes the displacement data is exported. Load points: Every element has load points. This is where the loads (input to Abaqus) are applied. Time step: Time step from the viewpoint of the fluid-structure interaction, usually equal to the time-step of the flow solver and structural solver, although one of the solvers can deviate in the case of subcycling. Increment: Time increment in the nomenclature of the Abaqus software. This is usually equal to the time step of the flow solver and overall coupled simulation, but in case of subcycling within the Abaqus solver, a time step can be subdivided in multiple increments. Environment A working directory for Abaqus needs to be created within the main directory. Its relative path to the main directory should be specified in the JSON file. In the CoCoNuT examples this folder is typically called CSM , but any name is allowed. The Abaqus license server needs to be specified in the parametrized file abaqus_v6.env which is present in the source directory . For use at Ghent University no changes are required. The Abaqus software should be available as well as compilers to compile the user-subroutines (FORTRAN) and post-processing code (C++). Some compilers also require a license. Parameters This section describes the parameter settings in the JSON file. A distinction is made between mandatory and optional parameters. It can be useful to have a look at a JSON file of one of the examples in the examples folder. Mandatory parameter type description arraysize int Size specification for array in FORTRAN part of the code, to reserve sufficient memory. Should be large enough and depends on the number of load points in the structural model. cores int Number of cores to be used by Abaqus. delta_t float Size of the time step in Abaqus. Its value should be synchronized with the flow solver. This parameter is usually specified in a higher Component object in which case it is not mandatory. dimensions int Dimensionality of the problem (2 or 3). surfaceIDs list List with the names of the node sets associated with the geometrical nodes on the FSI-interface surfaces. Example: [\"NODESET_NAME_A\", \"NODESET_NAME_B\"] Important notes: \u2003\u2022 The sequence of these surfaces has to correspond with the integer specified in the corresponding load-surface (see the input file section ). \u2003\u2022 The names of these surfaces should be all UPPERCASE as Abaqus recasts these when opening the .inp file. interface_input list Should contain a dictionary for each corresponding element in surfaceIDs , with a key \"model_part\" that provides the name of a ModelPart for Abaqus load points as value. The second key of the dictionary is variables . The list given as value specifies the input variables that should be included, chosen from data_structure/variables.py . Currently only \"pressure\" and \"traction\" are allowed (case-sensitive). An example can be found in this part of the input file section . interface_output list Similar to interface_input but for Abaqus geometrical nodes. In this case the \"variables\" key specifies the output variable, chosen from data_structure/variables.py . Currently only \"displacement\" is allowed (case-sensitive). An example can be found in this part of the input file section . input_file str Name of the Abaqus input file (.inp) provided by the user. Example: \"case.inp\" mp_mode str Determines how Abaqus is executed in parallel. It is recommended to use \"THREADS\" . \"MPI\" works as well but requires a host-file called AbaqusHosts.txt . This host-file lists the machines on which Abaqus is allowed to run. One line per requested core, but excessive lines cause no harm. The extra directory contains a script make_host_file.sh which can be used to generate a host file (Ghent University system). Note that multi-node computations are currently not supported. save_interval int (optional) Default: 1. Determines what files are kept by Abaqus. Only the files corresponding to (i.e. of which the time step is a multiple of) save_interval are kept at the end of a time step. Important for restart options (also in correspondence with the save interval of the flow solver). timestep_start int Time step to start from. Data should be available at this time step. For a new simulation this value will typically be 0. This parameter should be synchronized with the flow solver. This parameter is usually specified in a higher Component in which case it is not mandatory to specify. working_directory str Relative path to the directory in which Abaqus will be executed and where all structural information will be stored. Should be created before execution and contain a file AbaqusHosts.txt , see the environment section . timestep_start and delta_t are necessary parameters, but are usually defined in a higher Component . However, they can also be given directly as parameter of the solver wrapper (e.g. for standalone testing). If they are defined both in higher object and in the solver wrapper, then the former value is used and a warning is printed. Optional parameter type description subcycling boolean false : [Default] Abaqus solves the requested time step using one increment. true : Abaqus is allowed to solve the time step using multiple increments . This can be of use when Abaqus has convergence difficulties. For example cases where contact is involved often require small increments . initial_inc float Required when subcycling is enabled. Contains the size of the first time increment attempted by Abaqus. max_inc float Required when subcycling is enabled. Contains the maximal time increment size allowed. This value should not be higher than delta_t . max_num_inc int Required when subcycling is enabled. Contains the maximum number of increments that Abaqus is allowed to perform for one time step. min_inc float Required when subcycling is enabled. Contains the minimal size allowed for a time increment . ramp boolean Only used when subcycling is enabled in Abaqus. false : Load is considered to be constant throughout the time step. true : Load is applied in a ramped fashion throughout the time step. Overview of operation The solver wrapper consists of 5 files located in the source directory (with X denoting the Abaqus version, e.g. v614.py ): X.py : defines the SolverWrapperAbaqusX class. abaqus_v6.env : environment file setting the environment for the Abaqus solver. GetOutput.cpp : Extracts the output (from Abaqus .odb files) and writes it to a file for each output ModelPart . Written in C++. USR.f : An Abaqus user-subroutine that reads the loads from files (one for each input ModelPart ) and applies them on the load points. Written in FORTRAN. USRinit.f : An Abaqus user-subroutine that extract the coordinates of the load points and writes them to files (one for each input ModelPart ) to initialize each input ModelPart . Written in FORTRAN. The __init__ method During initialization of the SolverWrapperAbaqusX object, some parameters are substituted in abaqus_v6.env , GetOutput.cpp , USR.f and USRinit.f and these files are copied to the working directory. The C++ files and FORTRAN files are subsequently compiled. USRinit is ran to obtain the coordinates of the load points of each surfaces of which the name matches \"MOVINGSURFACE B \", where B should correspond to the index of the elements in surfaceIDs (0, 1, 2, ...). These coordinates are stored in ModelParts of which the name corresponds to the entries in interface_input (which also correspond to elements in surfaceIDs ). GetOutput is ran to extract the coordinates of the geometrical nodes. These coordinates are added to ModelParts of which the names corresponds to entries of interface_output (also matched with surfaceIDs ). The input ModelParts are added to an Interface object taking care of the inputs (i.e. loads), the output ModelParts to another instance of Interface taking care of outputs (i.e. displacements). Files written in the working directory during __init__ In the file conventions A is the start time step ( timestep_start in the JSON file) and B the index of the corresponding element of surfaceIDs . The Abaqus input file ( input_file in JSON file) is processed into a file CSM_TimeA.inp and CSM_Restart.inp , the latter taking care of all simulations (i.e. coupling iterations) but the first. Upon running USRinit the load point coordinates of each surface of which the name matches \"MOVINGSURFACEB\" are written to CSM_TimeACpu0SurfaceBFaces.dat and CSM_TimeACpu0SurfaceBFacesBis.dat . When these are processed by the solver wrapper, also CSM_TimeASurfaceBElements.dat is created. Upon running GetOutput the geometrical nodes are written to CSM_TimeASurfaceBNodes.dat . The solve_solution_step method This method of SolverWrapperAbaqusX is called each coupling iteration with an Interface object (input_interface) containing loads, which are written to files that are read by the (compiled) USR.f during the invoked Abaqus simulation. The Abaqus software is started and shut down for each calculation, i.e. each coupling iteration. When the simulation has ran successfully (log-file abaqus.log is checked for errors), the outputs are read from Abaqus by GetOuput and written to a file. The file is read in Python and the output (displacements) are stored in the output_interface Interface object which is returned. Files written in the working directory during solve_solution_step In the file conventions A is the time step and B the index of the corresponding element of surfaceIDs . Files written by Abaqus for allowing a restart (required every coupling iteration): CSM_TimeA.odb , CSM_TimeA.res , CSM_TimeA.mdl , CSM_TimeA.prt , CSM_TimeA.stt . Output database file written by Abaqus called CSM_TimeA.odb and read by GetOutput (also needed for restart). Output text file CSM_TimeASurfaceBOutput.dat containing displacements written by GetOutput and read by the solver wrapper. Input text file CSM_TimeASurfaceBCpu0Input.dat containing the loads written by the solver wrapper and read by the USR. Setting up a case: Abaqus input file (.inp) The Abaqus solver wrapper is configured to start from an input file which contains all necessary information for the calculation. This file should be located in the main directory. Its name should be specified in the JSON file via the parameter input_file . For the remainder of this section this file will be referred to as \"base-file\". Creation of the base-file is not considered a part of the solver wrapper functionality as it is case-specific. However, in order for the solver wrapper to work, the base-file has to comply with certain general conditions. This section aims at informing the user about the requirements for the base-file. General The base-file needs to be of the \".inp\" type, this is an \"input file for Abaqus\". \".inp-files\" are created via Abaqus by, after configuration, creating a \"job\" and requesting a \"write input\" for that job. These files can be opened in Abaqus by using \"file > import > model\". The base-file has to contain all necessary information about the structural model, which includes: Mesh defining the structure geometry and discretization. Also the element type needs to be defined. Material properties. Boundary conditions. Surfaces where external loads need to be applied. Here \"Surface\" refers to nomenclature of the Abaqus software itself. The name can be found as such in the Abaqus working tree. Node sets where displacement data will be extracted. Here \"Set\" refers to nomenclature of the Abaqus software itself. The name can be found as such in the Abaqus working tree. Also element sets exist, but for CoCoNuT the demanded sets need to be a collection of geometrical nodes, hence \"node set\". A Step definition, which contains solver settings. Currently the following type of analyses (it is advised to explicitly set them rather than leaving it to Abaqus to fill in a default) are supported: Implicit dynamic, application quasi-static Implicit dynamic, application moderate dissipation Static general Additional loads not dependent on the flow solver. Abaqus models contain parts and those parts are used to create assemblies. The base-file should contain one assembly, which will then be used by the coupling. The assembly, thus, determines the position and orientation that will be used by the coupling software. Also the sets and surfaces required by CoCoNuT should be defined on the assembly level. Abaqus has a GUI as well as a Python 2 interface (which is also accessible) via the GUI. References to both the Python interface and GUI will be made below. Setup for Abaqus input (loads) Per surface in the fluid-structure interface (where loads and displacements need to be exchanged) a \"surface\" should be created in the assembly . There are multiple possibilities to create these surfaces: From the geometry: when the geometry has been defined in Abaqus itself, the geometry faces can easily be selected in the GUI. This method is often the most straightforward, but the Abaqus model should contain the geometry. From the mesh: when the geometry is not available (this can for example be the case when a mesh has been imported), a surface can be defined by selecting multiple mesh faces. As a surface typically covers many mesh faces, it is useful there to select the regions \"by angle\", which uses the angle between mesh faces to determine whether adjacent faces should be selected. This way the surface selection can be extended until a sharp corner is met. By converting a \"node set\" containing all the nodes on the surface and then calling the SurfaceFromNodeSet method which can be found in the make_surface.py file in the extra directory. The name of the surface has to be MOVINGSURFACE followed by an integer . The integer of the surface has to correspond with the index of that specific surface in the surfaceIDs parameter (index starts from 0). For example MOVINGSURFACE0 is associated with the first item in surfaceIDs and MOVINGSURFACE1 would be associated with the second item in surfaceIDs . An example on the use of SurfaceFromNodeSet (via the Python console in Abaqus or a Python script for Abaqus): from makeSurface import SurfaceFromNodeSet my_model = mdb . models [ 'Model-1' ] my_assembly = my_model . rootAssembly my_instance = my_assembly . instances [ 'PART-1-1' ] movingSurface0 = SurfaceFromNodeSet ( my_model , my_instance , 'NODESET_NAME_A' , 'MOVINGSURFACE0' ) On these surfaces a \"pressure load\" and a \"surface traction load\" need to be specified with a \"user-defined\" distribution. Loads are assigned to a \"step\". A step is a part of the simulation to which an analysis type, algorithm settings and incrementation settings are assigned that do not change for the duration of the step. In a typical CoCoNuT case only a single step is defined. Note that the name of the step used for the FSI has to be \"Step-1\" as this name is hardcoded in GetOutput.cpp . After creation of the step the loads can be assigned. This can be done via the GUI or using Python commands available in Abaqus similar to the following: from step import * step1 = my_model . ImplicitDynamicsStep ( name = 'Step-1' , previous = 'Initial' , timePeriod = 1 , nlgeom = ON , maxNumInc = 1 , haftol = 1 , initialInc = 1 , minInc = 1 , maxInc = 1 , amplitude = RAMP , noStop = OFF , nohaf = ON , initialConditions = OFF , timeIncrementationMethod = FIXED , application = QUASI_STATIC ) step1 . Restart ( frequency = 99999 , overlay = ON ) my_model . Pressure ( name = 'DistributedPressure' , createStepName = 'Step-1' , distributionType = USER_DEFINED , field = '' , magnitude = 1 , region = movingSurface0 ) my_model . SurfaceTraction ( name = 'DistributedShear' , createStepName = 'Step-1' , region = movingSurface0 , magnitude = 1 , traction = GENERAL , directionVector = (( 0 , 0 , 0 ), ( 1 , 0 , 0 )), distributionType = USER_DEFINED ) The second command enables writing of restart files by Abaqus, which is required for running unsteady cases. This can be done from the GUI when the \"Step\" module is active in the viewport, by selecting \"Output\" in the top menu and subsequently \"Restart Requests\". Frequency should be put on 99999 , overlay activated (this spares disk space since only the last increment is kept) and interval on 1 (also see this Abaqus documentation page ). Note that the step type \"ImplicitDynamicsStep\" is an example, it depends on the analysis procedure chosen to run the Abaqus part of the FSI simulation. For a steady simulation this could for example be \"StaticStep\": step1 = my_model . StaticStep ( name = 'Step-1' , previous = 'Initial' , timePeriod = 1.0 , initialInc = 1 , minInc = 1e-4 , maxNumInc = 10 , nlgeom = ON , amplitude = RAMP ) Currently, the Abaqus wrapper automatically checks if the increments comply with the delta_t , subcycling and related settings and adjusts them accordingly or raises an error, but only for a dynamic step or a static step with subcycling . Attention: Replacing the incrementation settings is done by looking up some keywords in the base-file ( *Step , *Dynamic , application ). This procedure fails when these keywords are not found. When using the GUI to create the base-file (.inp) and using the default settings for the step, often the keyword application is not written. It is hence advised not to use the default settings but use an application (quasi-static works for most cases and also moderate dissipation is allowed). If sub-cycling is not enabled, the maximal number of increments should be 1 ( inc=1 ), otherwise an error is raised. This behavior may be changed in future versions of the code. The lines in the base-file (.inp) should look similar to this: *Step, name=Step-1, nlgeom=YES, inc=1 *Dynamic,application=QUASI-STATIC,direct,nohaf,initial=NO 0.0001,0.0001, The time step (0.0001) will in this case be replaced by settings found in the JSON file. More information can be found in this Abaqus documentation page . Input-related settings in JSON file Although it is imperative to use MOVINGSURFACE followed by an integer in the base-file to identify the surfaces for input , some lines in the JSON file (see example below) related to input contains names specified by the user. The names in the interface_input[\"model_part\"] keys are matched by the elements (and their index) in surfaceIDs . { \"surfaceIDs\" : [ \"NODESET_NAME_A\" , \"NODESET_NAME_B\" ], \"interface_input\" : [ { \"model_part\" : \"NODESET_NAME_A_load_points\" , \"variables\" : [ \"pressure\" , \"traction\" ] }, { \"model_part\" : \"NODESET_NAME_B_load_points\" , \"variables\" : [ \"pressure\" , \"traction\" ] } ] } Setup for Abaqus output (displacements) After creation of the step, Abaqus needs to be instructed about what to output at the end of a calculation. A \"Field Output\" has to be generated covering all locations involved in the fluid-structure interface. To do so one must create node sets in the assembly (if this had not been done before) with names corresponding to surfaceIDs and containing all structural nodes of the surfaces, then create a Field Output Request for at least the coordinates and the displacements. This Field Output Request can in the GUI be found as part of the model tree, but below also an example for the Python interface is given. A Field Output Request requests field output (as the name says) to be written to the output database file (.odb). In the previous section an example was given of how a surface can be created from a node set, but the other way around is also possible, creating a node set from a surface (presuming that this surface was already created): my_assembly = my_model . rootAssembly movingSurface0 = my_assembly . surfaces [ \"MOVINGSURFACE0\" ] outputSet = my_assembly . Set ( name = 'NODESET_NAME_A' , nodes = movingSurface0 . nodes ) my_model . FieldOutputRequest ( createStepName = 'Step-1' , frequency = LAST_INCREMENT , name = 'F-Output-1' , region = my_assembly . sets [ 'NODESET_NAME_A' ], variables = ( 'COORD' , 'U' )) Furthermore, it may be interesting (for post-processing and debugging) to preserve the default Abaqus output and therefore also configure a Field Output and History Output with PRESELECTED variables. This can be done via the GUI or using Python lines similar to the following: my_model . FieldOutputRequest ( createStepName = 'Step-1' , frequency = LAST_INCREMENT , name = 'F-Output-2' , variables = PRESELECT ) my_model . HistoryOutputRequest ( createStepName = 'Step-1' , frequency = LAST_INCREMENT , name = 'H-Output-1' , variables = PRESELECT ) Output-related settings in JSON file The values of the interface_output[\"model_part\"] keys are matched by the elements (and their index) in surfaceIDs . These values are internally used in CoCoNuT to distinguish the different ModelParts . The elements of surfaceIDs should match the names of the node sets defined in Abaqus. { \"surfaceIDs\" : [ \"NODESET_NAME_A\" , \"NODESET_NAME_B\" ], \"interface_output\" : [ { \"model_part\" : \"NODESET_NAME_A_nodes\" , \"variables\" : [ \"displacement\" ] }, { \"model_part\" : \"NODESET_NAME_B_nodes\" , \"variables\" : [ \"displacement\" ] } ] } Note about choosing ModelParts The created \"surfaces\" and \"node sets\" for load input and displacement output respectively, correspond to ModelParts in the CoCoNuT code, a representation of the data used for the coupling. It is strongly advised to sub-divide to fluid-structure interaction interface intelligently, depending on the geometry. As a rule of thumb it can be said that a surfaces at two sides of a sharp corner should be assigned to a different ModelPart . As the interpolation is based on shortest distance, issues can arise at sharp corners. Those are avoided by having different ModelParts at each side of the corner. Another reason to do this is because the code cannot handle elements with two or more faces being part of the same ModelPart . This situation would occur if the surface contains corners. An example is an airfoil where the suction side and pressure side belong to the same ModelPart : elements at the trailing edge will have (a) face(s) at both the pressure side and suction side. Even when the code would allow this, interpolation mistakes become likely, as a geometrical node or load point on the suction side could have a nearest neighbour on the pressure side, causing that the wrong data is used for interpolation. Log files A general event log of the procedure can be found in the working directory, in a file named abaqus.log . For more detailed information on a certain time step, the .msg file written by Abaqus can be consulted. In CoCoNuT these are structured as follows: CSM_TimeA.msg , A being the time step. Typically multiple coupling iterations are done within each time step, so these .msg-files get overwritten by each new coupling iteration in the same time step.","title":"Abaqus"},{"location":"abaqus.html#abaqus","text":"This is the documentation for all Abaqus solver wrappers. Abaqus is a structural solver implementing the finite element method. Currently this wrapper only supports FSI simulations, no other multi-physics problems. Subcycling within the structural solver is possible.","title":"Abaqus"},{"location":"abaqus.html#fluid-structure-interaction-with-abaqus","text":"Abaqus (Dassault Syst\u00e8mes) can be used to solve for the structural displacement/deformation in partitioned FSI-simulations. The FSI interface consist of a surfaces in the Abaqus model, where pressure and surface traction loads are applied, and corresponding node sets , where the resulting computed displacements are returned to the solver wrapper. The loads are applied in so-called load points (Gauss points, quadrature points), the displacements are exported in the elements' nodes. The input loads are collected in one or more ModelParts in the input Interface , the output nodes are collected in one or more ModelParts of the output Interface . Each ModelPart on the input Interface has a counterpart on the output Interface . More information about ModelParts and Interface can be found in the data structure documentation .","title":"Fluid-structure interaction with Abaqus"},{"location":"abaqus.html#terminology","text":"Main directory: Directory where the analysis is started. Working directory: Subdirectory of the main directory in which Abaqus runs. Source directory: Directory where the source files of the Abaqus solver wrapper are found: coupling_components/solver_wrappers/abaqus . Extra directory: Subdirectory of the source directory with some files to assist with the setup. Geometrical nodes: Nodes in Abaqus related to the geometry of the elements. At these nodes the displacement data is exported. Load points: Every element has load points. This is where the loads (input to Abaqus) are applied. Time step: Time step from the viewpoint of the fluid-structure interaction, usually equal to the time-step of the flow solver and structural solver, although one of the solvers can deviate in the case of subcycling. Increment: Time increment in the nomenclature of the Abaqus software. This is usually equal to the time step of the flow solver and overall coupled simulation, but in case of subcycling within the Abaqus solver, a time step can be subdivided in multiple increments.","title":"Terminology"},{"location":"abaqus.html#environment","text":"A working directory for Abaqus needs to be created within the main directory. Its relative path to the main directory should be specified in the JSON file. In the CoCoNuT examples this folder is typically called CSM , but any name is allowed. The Abaqus license server needs to be specified in the parametrized file abaqus_v6.env which is present in the source directory . For use at Ghent University no changes are required. The Abaqus software should be available as well as compilers to compile the user-subroutines (FORTRAN) and post-processing code (C++). Some compilers also require a license.","title":"Environment"},{"location":"abaqus.html#parameters","text":"This section describes the parameter settings in the JSON file. A distinction is made between mandatory and optional parameters. It can be useful to have a look at a JSON file of one of the examples in the examples folder.","title":"Parameters"},{"location":"abaqus.html#mandatory","text":"parameter type description arraysize int Size specification for array in FORTRAN part of the code, to reserve sufficient memory. Should be large enough and depends on the number of load points in the structural model. cores int Number of cores to be used by Abaqus. delta_t float Size of the time step in Abaqus. Its value should be synchronized with the flow solver. This parameter is usually specified in a higher Component object in which case it is not mandatory. dimensions int Dimensionality of the problem (2 or 3). surfaceIDs list List with the names of the node sets associated with the geometrical nodes on the FSI-interface surfaces. Example: [\"NODESET_NAME_A\", \"NODESET_NAME_B\"] Important notes: \u2003\u2022 The sequence of these surfaces has to correspond with the integer specified in the corresponding load-surface (see the input file section ). \u2003\u2022 The names of these surfaces should be all UPPERCASE as Abaqus recasts these when opening the .inp file. interface_input list Should contain a dictionary for each corresponding element in surfaceIDs , with a key \"model_part\" that provides the name of a ModelPart for Abaqus load points as value. The second key of the dictionary is variables . The list given as value specifies the input variables that should be included, chosen from data_structure/variables.py . Currently only \"pressure\" and \"traction\" are allowed (case-sensitive). An example can be found in this part of the input file section . interface_output list Similar to interface_input but for Abaqus geometrical nodes. In this case the \"variables\" key specifies the output variable, chosen from data_structure/variables.py . Currently only \"displacement\" is allowed (case-sensitive). An example can be found in this part of the input file section . input_file str Name of the Abaqus input file (.inp) provided by the user. Example: \"case.inp\" mp_mode str Determines how Abaqus is executed in parallel. It is recommended to use \"THREADS\" . \"MPI\" works as well but requires a host-file called AbaqusHosts.txt . This host-file lists the machines on which Abaqus is allowed to run. One line per requested core, but excessive lines cause no harm. The extra directory contains a script make_host_file.sh which can be used to generate a host file (Ghent University system). Note that multi-node computations are currently not supported. save_interval int (optional) Default: 1. Determines what files are kept by Abaqus. Only the files corresponding to (i.e. of which the time step is a multiple of) save_interval are kept at the end of a time step. Important for restart options (also in correspondence with the save interval of the flow solver). timestep_start int Time step to start from. Data should be available at this time step. For a new simulation this value will typically be 0. This parameter should be synchronized with the flow solver. This parameter is usually specified in a higher Component in which case it is not mandatory to specify. working_directory str Relative path to the directory in which Abaqus will be executed and where all structural information will be stored. Should be created before execution and contain a file AbaqusHosts.txt , see the environment section . timestep_start and delta_t are necessary parameters, but are usually defined in a higher Component . However, they can also be given directly as parameter of the solver wrapper (e.g. for standalone testing). If they are defined both in higher object and in the solver wrapper, then the former value is used and a warning is printed.","title":"Mandatory"},{"location":"abaqus.html#optional","text":"parameter type description subcycling boolean false : [Default] Abaqus solves the requested time step using one increment. true : Abaqus is allowed to solve the time step using multiple increments . This can be of use when Abaqus has convergence difficulties. For example cases where contact is involved often require small increments . initial_inc float Required when subcycling is enabled. Contains the size of the first time increment attempted by Abaqus. max_inc float Required when subcycling is enabled. Contains the maximal time increment size allowed. This value should not be higher than delta_t . max_num_inc int Required when subcycling is enabled. Contains the maximum number of increments that Abaqus is allowed to perform for one time step. min_inc float Required when subcycling is enabled. Contains the minimal size allowed for a time increment . ramp boolean Only used when subcycling is enabled in Abaqus. false : Load is considered to be constant throughout the time step. true : Load is applied in a ramped fashion throughout the time step.","title":"Optional"},{"location":"abaqus.html#overview-of-operation","text":"The solver wrapper consists of 5 files located in the source directory (with X denoting the Abaqus version, e.g. v614.py ): X.py : defines the SolverWrapperAbaqusX class. abaqus_v6.env : environment file setting the environment for the Abaqus solver. GetOutput.cpp : Extracts the output (from Abaqus .odb files) and writes it to a file for each output ModelPart . Written in C++. USR.f : An Abaqus user-subroutine that reads the loads from files (one for each input ModelPart ) and applies them on the load points. Written in FORTRAN. USRinit.f : An Abaqus user-subroutine that extract the coordinates of the load points and writes them to files (one for each input ModelPart ) to initialize each input ModelPart . Written in FORTRAN.","title":"Overview of operation"},{"location":"abaqus.html#the-__init__-method","text":"During initialization of the SolverWrapperAbaqusX object, some parameters are substituted in abaqus_v6.env , GetOutput.cpp , USR.f and USRinit.f and these files are copied to the working directory. The C++ files and FORTRAN files are subsequently compiled. USRinit is ran to obtain the coordinates of the load points of each surfaces of which the name matches \"MOVINGSURFACE B \", where B should correspond to the index of the elements in surfaceIDs (0, 1, 2, ...). These coordinates are stored in ModelParts of which the name corresponds to the entries in interface_input (which also correspond to elements in surfaceIDs ). GetOutput is ran to extract the coordinates of the geometrical nodes. These coordinates are added to ModelParts of which the names corresponds to entries of interface_output (also matched with surfaceIDs ). The input ModelParts are added to an Interface object taking care of the inputs (i.e. loads), the output ModelParts to another instance of Interface taking care of outputs (i.e. displacements).","title":"The __init__ method"},{"location":"abaqus.html#files-written-in-the-working-directory-during-__init__","text":"In the file conventions A is the start time step ( timestep_start in the JSON file) and B the index of the corresponding element of surfaceIDs . The Abaqus input file ( input_file in JSON file) is processed into a file CSM_TimeA.inp and CSM_Restart.inp , the latter taking care of all simulations (i.e. coupling iterations) but the first. Upon running USRinit the load point coordinates of each surface of which the name matches \"MOVINGSURFACEB\" are written to CSM_TimeACpu0SurfaceBFaces.dat and CSM_TimeACpu0SurfaceBFacesBis.dat . When these are processed by the solver wrapper, also CSM_TimeASurfaceBElements.dat is created. Upon running GetOutput the geometrical nodes are written to CSM_TimeASurfaceBNodes.dat .","title":"Files written in the working directory during __init__"},{"location":"abaqus.html#the-solve_solution_step-method","text":"This method of SolverWrapperAbaqusX is called each coupling iteration with an Interface object (input_interface) containing loads, which are written to files that are read by the (compiled) USR.f during the invoked Abaqus simulation. The Abaqus software is started and shut down for each calculation, i.e. each coupling iteration. When the simulation has ran successfully (log-file abaqus.log is checked for errors), the outputs are read from Abaqus by GetOuput and written to a file. The file is read in Python and the output (displacements) are stored in the output_interface Interface object which is returned.","title":"The solve_solution_step method"},{"location":"abaqus.html#files-written-in-the-working-directory-during-solve_solution_step","text":"In the file conventions A is the time step and B the index of the corresponding element of surfaceIDs . Files written by Abaqus for allowing a restart (required every coupling iteration): CSM_TimeA.odb , CSM_TimeA.res , CSM_TimeA.mdl , CSM_TimeA.prt , CSM_TimeA.stt . Output database file written by Abaqus called CSM_TimeA.odb and read by GetOutput (also needed for restart). Output text file CSM_TimeASurfaceBOutput.dat containing displacements written by GetOutput and read by the solver wrapper. Input text file CSM_TimeASurfaceBCpu0Input.dat containing the loads written by the solver wrapper and read by the USR.","title":"Files written in the working directory during solve_solution_step"},{"location":"abaqus.html#setting-up-a-case-abaqus-input-file-inp","text":"The Abaqus solver wrapper is configured to start from an input file which contains all necessary information for the calculation. This file should be located in the main directory. Its name should be specified in the JSON file via the parameter input_file . For the remainder of this section this file will be referred to as \"base-file\". Creation of the base-file is not considered a part of the solver wrapper functionality as it is case-specific. However, in order for the solver wrapper to work, the base-file has to comply with certain general conditions. This section aims at informing the user about the requirements for the base-file.","title":"Setting up a case: Abaqus input file (.inp)"},{"location":"abaqus.html#general","text":"The base-file needs to be of the \".inp\" type, this is an \"input file for Abaqus\". \".inp-files\" are created via Abaqus by, after configuration, creating a \"job\" and requesting a \"write input\" for that job. These files can be opened in Abaqus by using \"file > import > model\". The base-file has to contain all necessary information about the structural model, which includes: Mesh defining the structure geometry and discretization. Also the element type needs to be defined. Material properties. Boundary conditions. Surfaces where external loads need to be applied. Here \"Surface\" refers to nomenclature of the Abaqus software itself. The name can be found as such in the Abaqus working tree. Node sets where displacement data will be extracted. Here \"Set\" refers to nomenclature of the Abaqus software itself. The name can be found as such in the Abaqus working tree. Also element sets exist, but for CoCoNuT the demanded sets need to be a collection of geometrical nodes, hence \"node set\". A Step definition, which contains solver settings. Currently the following type of analyses (it is advised to explicitly set them rather than leaving it to Abaqus to fill in a default) are supported: Implicit dynamic, application quasi-static Implicit dynamic, application moderate dissipation Static general Additional loads not dependent on the flow solver. Abaqus models contain parts and those parts are used to create assemblies. The base-file should contain one assembly, which will then be used by the coupling. The assembly, thus, determines the position and orientation that will be used by the coupling software. Also the sets and surfaces required by CoCoNuT should be defined on the assembly level. Abaqus has a GUI as well as a Python 2 interface (which is also accessible) via the GUI. References to both the Python interface and GUI will be made below.","title":"General"},{"location":"abaqus.html#setup-for-abaqus-input-loads","text":"Per surface in the fluid-structure interface (where loads and displacements need to be exchanged) a \"surface\" should be created in the assembly . There are multiple possibilities to create these surfaces: From the geometry: when the geometry has been defined in Abaqus itself, the geometry faces can easily be selected in the GUI. This method is often the most straightforward, but the Abaqus model should contain the geometry. From the mesh: when the geometry is not available (this can for example be the case when a mesh has been imported), a surface can be defined by selecting multiple mesh faces. As a surface typically covers many mesh faces, it is useful there to select the regions \"by angle\", which uses the angle between mesh faces to determine whether adjacent faces should be selected. This way the surface selection can be extended until a sharp corner is met. By converting a \"node set\" containing all the nodes on the surface and then calling the SurfaceFromNodeSet method which can be found in the make_surface.py file in the extra directory. The name of the surface has to be MOVINGSURFACE followed by an integer . The integer of the surface has to correspond with the index of that specific surface in the surfaceIDs parameter (index starts from 0). For example MOVINGSURFACE0 is associated with the first item in surfaceIDs and MOVINGSURFACE1 would be associated with the second item in surfaceIDs . An example on the use of SurfaceFromNodeSet (via the Python console in Abaqus or a Python script for Abaqus): from makeSurface import SurfaceFromNodeSet my_model = mdb . models [ 'Model-1' ] my_assembly = my_model . rootAssembly my_instance = my_assembly . instances [ 'PART-1-1' ] movingSurface0 = SurfaceFromNodeSet ( my_model , my_instance , 'NODESET_NAME_A' , 'MOVINGSURFACE0' ) On these surfaces a \"pressure load\" and a \"surface traction load\" need to be specified with a \"user-defined\" distribution. Loads are assigned to a \"step\". A step is a part of the simulation to which an analysis type, algorithm settings and incrementation settings are assigned that do not change for the duration of the step. In a typical CoCoNuT case only a single step is defined. Note that the name of the step used for the FSI has to be \"Step-1\" as this name is hardcoded in GetOutput.cpp . After creation of the step the loads can be assigned. This can be done via the GUI or using Python commands available in Abaqus similar to the following: from step import * step1 = my_model . ImplicitDynamicsStep ( name = 'Step-1' , previous = 'Initial' , timePeriod = 1 , nlgeom = ON , maxNumInc = 1 , haftol = 1 , initialInc = 1 , minInc = 1 , maxInc = 1 , amplitude = RAMP , noStop = OFF , nohaf = ON , initialConditions = OFF , timeIncrementationMethod = FIXED , application = QUASI_STATIC ) step1 . Restart ( frequency = 99999 , overlay = ON ) my_model . Pressure ( name = 'DistributedPressure' , createStepName = 'Step-1' , distributionType = USER_DEFINED , field = '' , magnitude = 1 , region = movingSurface0 ) my_model . SurfaceTraction ( name = 'DistributedShear' , createStepName = 'Step-1' , region = movingSurface0 , magnitude = 1 , traction = GENERAL , directionVector = (( 0 , 0 , 0 ), ( 1 , 0 , 0 )), distributionType = USER_DEFINED ) The second command enables writing of restart files by Abaqus, which is required for running unsteady cases. This can be done from the GUI when the \"Step\" module is active in the viewport, by selecting \"Output\" in the top menu and subsequently \"Restart Requests\". Frequency should be put on 99999 , overlay activated (this spares disk space since only the last increment is kept) and interval on 1 (also see this Abaqus documentation page ). Note that the step type \"ImplicitDynamicsStep\" is an example, it depends on the analysis procedure chosen to run the Abaqus part of the FSI simulation. For a steady simulation this could for example be \"StaticStep\": step1 = my_model . StaticStep ( name = 'Step-1' , previous = 'Initial' , timePeriod = 1.0 , initialInc = 1 , minInc = 1e-4 , maxNumInc = 10 , nlgeom = ON , amplitude = RAMP ) Currently, the Abaqus wrapper automatically checks if the increments comply with the delta_t , subcycling and related settings and adjusts them accordingly or raises an error, but only for a dynamic step or a static step with subcycling . Attention: Replacing the incrementation settings is done by looking up some keywords in the base-file ( *Step , *Dynamic , application ). This procedure fails when these keywords are not found. When using the GUI to create the base-file (.inp) and using the default settings for the step, often the keyword application is not written. It is hence advised not to use the default settings but use an application (quasi-static works for most cases and also moderate dissipation is allowed). If sub-cycling is not enabled, the maximal number of increments should be 1 ( inc=1 ), otherwise an error is raised. This behavior may be changed in future versions of the code. The lines in the base-file (.inp) should look similar to this: *Step, name=Step-1, nlgeom=YES, inc=1 *Dynamic,application=QUASI-STATIC,direct,nohaf,initial=NO 0.0001,0.0001, The time step (0.0001) will in this case be replaced by settings found in the JSON file. More information can be found in this Abaqus documentation page .","title":"Setup for Abaqus input (loads)"},{"location":"abaqus.html#input-related-settings-in-json-file","text":"Although it is imperative to use MOVINGSURFACE followed by an integer in the base-file to identify the surfaces for input , some lines in the JSON file (see example below) related to input contains names specified by the user. The names in the interface_input[\"model_part\"] keys are matched by the elements (and their index) in surfaceIDs . { \"surfaceIDs\" : [ \"NODESET_NAME_A\" , \"NODESET_NAME_B\" ], \"interface_input\" : [ { \"model_part\" : \"NODESET_NAME_A_load_points\" , \"variables\" : [ \"pressure\" , \"traction\" ] }, { \"model_part\" : \"NODESET_NAME_B_load_points\" , \"variables\" : [ \"pressure\" , \"traction\" ] } ] }","title":"Input-related settings in JSON file"},{"location":"abaqus.html#setup-for-abaqus-output-displacements","text":"After creation of the step, Abaqus needs to be instructed about what to output at the end of a calculation. A \"Field Output\" has to be generated covering all locations involved in the fluid-structure interface. To do so one must create node sets in the assembly (if this had not been done before) with names corresponding to surfaceIDs and containing all structural nodes of the surfaces, then create a Field Output Request for at least the coordinates and the displacements. This Field Output Request can in the GUI be found as part of the model tree, but below also an example for the Python interface is given. A Field Output Request requests field output (as the name says) to be written to the output database file (.odb). In the previous section an example was given of how a surface can be created from a node set, but the other way around is also possible, creating a node set from a surface (presuming that this surface was already created): my_assembly = my_model . rootAssembly movingSurface0 = my_assembly . surfaces [ \"MOVINGSURFACE0\" ] outputSet = my_assembly . Set ( name = 'NODESET_NAME_A' , nodes = movingSurface0 . nodes ) my_model . FieldOutputRequest ( createStepName = 'Step-1' , frequency = LAST_INCREMENT , name = 'F-Output-1' , region = my_assembly . sets [ 'NODESET_NAME_A' ], variables = ( 'COORD' , 'U' )) Furthermore, it may be interesting (for post-processing and debugging) to preserve the default Abaqus output and therefore also configure a Field Output and History Output with PRESELECTED variables. This can be done via the GUI or using Python lines similar to the following: my_model . FieldOutputRequest ( createStepName = 'Step-1' , frequency = LAST_INCREMENT , name = 'F-Output-2' , variables = PRESELECT ) my_model . HistoryOutputRequest ( createStepName = 'Step-1' , frequency = LAST_INCREMENT , name = 'H-Output-1' , variables = PRESELECT )","title":"Setup for Abaqus output (displacements)"},{"location":"abaqus.html#output-related-settings-in-json-file","text":"The values of the interface_output[\"model_part\"] keys are matched by the elements (and their index) in surfaceIDs . These values are internally used in CoCoNuT to distinguish the different ModelParts . The elements of surfaceIDs should match the names of the node sets defined in Abaqus. { \"surfaceIDs\" : [ \"NODESET_NAME_A\" , \"NODESET_NAME_B\" ], \"interface_output\" : [ { \"model_part\" : \"NODESET_NAME_A_nodes\" , \"variables\" : [ \"displacement\" ] }, { \"model_part\" : \"NODESET_NAME_B_nodes\" , \"variables\" : [ \"displacement\" ] } ] }","title":"Output-related settings in JSON file"},{"location":"abaqus.html#note-about-choosing-modelparts","text":"The created \"surfaces\" and \"node sets\" for load input and displacement output respectively, correspond to ModelParts in the CoCoNuT code, a representation of the data used for the coupling. It is strongly advised to sub-divide to fluid-structure interaction interface intelligently, depending on the geometry. As a rule of thumb it can be said that a surfaces at two sides of a sharp corner should be assigned to a different ModelPart . As the interpolation is based on shortest distance, issues can arise at sharp corners. Those are avoided by having different ModelParts at each side of the corner. Another reason to do this is because the code cannot handle elements with two or more faces being part of the same ModelPart . This situation would occur if the surface contains corners. An example is an airfoil where the suction side and pressure side belong to the same ModelPart : elements at the trailing edge will have (a) face(s) at both the pressure side and suction side. Even when the code would allow this, interpolation mistakes become likely, as a geometrical node or load point on the suction side could have a nearest neighbour on the pressure side, causing that the wrong data is used for interpolation.","title":"Note about choosing ModelParts"},{"location":"abaqus.html#log-files","text":"A general event log of the procedure can be found in the working directory, in a file named abaqus.log . For more detailed information on a certain time step, the .msg file written by Abaqus can be consulted. In CoCoNuT these are structured as follows: CSM_TimeA.msg , A being the time step. Typically multiple coupling iterations are done within each time step, so these .msg-files get overwritten by each new coupling iteration in the same time step.","title":"Log files"},{"location":"breaking_dam_fluent2d_abaqus2d.html","text":"Breaking dam with Fluent2D and Abaqus2D This example simulates a dam-break on a top-fixed flexible gate. The liquid, intially located in a free-surface tank, imposes a variable pressure on the bending flexible gate. This case has been examined numerically and experimentally by Antoci et al. [ 1 ]. Here, this 2D FSI calculation is performed with Fluent and Abaqus. The figure below shows the bending of the gate and the flowing water (with Fluent). The geometry is provided in the following figure. Pressure outlets and walls are indicated in blue and black, respectively. The gap beneath the gate is exagerated for clarity. The corresponding parameters are: parameter value description A 0.1 m Width of the liquid tank. G 0.0025 m Clearance of the elastic gate. H 0.14 m Initial height of the liquid column. L 0.079 m Height of the elastic gate. S 0.005 m Thickness of the elastic gate. The elastic gate is made of rubber and has the following parameters: density: 1100 kg/m\u00b3 modulus of elasticity: 10 ^7 ^7 Pa poisson's ratio: 0.49 The flow calculation uses the volume of fluid (VOF) method to model the free-surface. The liquid phase is water with the following properties: density: 1000 kg/m\u00b3 dynamic viscosity: 0.001 Pa \\cdot \\cdot s The gas phase is air modelled with the following parameters: density: 1.225 kg/m\u00b3 dynamic viscosity: 1.7894 10 ^{-5} ^{-5} Pa \\cdot \\cdot s The gravitational accelartion is 9.81 m/s\u00b2. The total simulated time is 0.4 s in time steps of 0.001 s. geometry Coupling algorithm The coupling technique used is the interface quasi-Newton algorithm with an approximation for the inverse of the Jacobian from a least-squares model (IQNI-LS). The reuse parameter q is set to 10, which means that data from the last ten time steps will be used to stabilize and accelerate the convergence. Predictor The initial guess in every time step is done using the linear predictor. Convergence criterion Two convergence criteria have been specified: The number of iterations in every time step is larger than 20. The residual norm on the displacement is a factor 10^{-3} 10^{-3} lower than the initial value. When either criterion is satisfied the simulation stops. Solvers Fluent is used as flow solver. The provided mesh is triangular. When the gate bends remeshing is performed to perserve its quality. A script to regenerate it using Gambit is included. This script allows to change the resolution and geometrical parameters. The structure solver is Abaqus. The Abaqus case is built when setting up the case starting from the file mesh_breaking_dam.inp containing nodes and elements. This is done by running Abaqus with the make_inp.py Python script to set all parameters, such as surface definitions, material parameters, boundary conditions and time step information. The result of the setup is a completed input file case_breaking_dam.inp . The Abaqus element type used is CPE8R. To exchange information between the solvers on the fluid-structure interface, the use of mappers is required. In the structure solver wrapper, a linear interpolation mapper is used to interpolate in the x- and y-direction from and to the coupled solver. References [1] Antoci C., Gallatie M., Sibilla, S., \"Numerical simulation of fluid-structure interaction by sph\", Computers & Structures, vol. 85, no. 11, pp. 879-890, 2007.","title":"Fluent 2D - Abaqus 2D"},{"location":"breaking_dam_fluent2d_abaqus2d.html#breaking-dam-with-fluent2d-and-abaqus2d","text":"This example simulates a dam-break on a top-fixed flexible gate. The liquid, intially located in a free-surface tank, imposes a variable pressure on the bending flexible gate. This case has been examined numerically and experimentally by Antoci et al. [ 1 ]. Here, this 2D FSI calculation is performed with Fluent and Abaqus. The figure below shows the bending of the gate and the flowing water (with Fluent). The geometry is provided in the following figure. Pressure outlets and walls are indicated in blue and black, respectively. The gap beneath the gate is exagerated for clarity. The corresponding parameters are: parameter value description A 0.1 m Width of the liquid tank. G 0.0025 m Clearance of the elastic gate. H 0.14 m Initial height of the liquid column. L 0.079 m Height of the elastic gate. S 0.005 m Thickness of the elastic gate. The elastic gate is made of rubber and has the following parameters: density: 1100 kg/m\u00b3 modulus of elasticity: 10 ^7 ^7 Pa poisson's ratio: 0.49 The flow calculation uses the volume of fluid (VOF) method to model the free-surface. The liquid phase is water with the following properties: density: 1000 kg/m\u00b3 dynamic viscosity: 0.001 Pa \\cdot \\cdot s The gas phase is air modelled with the following parameters: density: 1.225 kg/m\u00b3 dynamic viscosity: 1.7894 10 ^{-5} ^{-5} Pa \\cdot \\cdot s The gravitational accelartion is 9.81 m/s\u00b2. The total simulated time is 0.4 s in time steps of 0.001 s. geometry","title":"Breaking dam with Fluent2D and Abaqus2D"},{"location":"breaking_dam_fluent2d_abaqus2d.html#coupling-algorithm","text":"The coupling technique used is the interface quasi-Newton algorithm with an approximation for the inverse of the Jacobian from a least-squares model (IQNI-LS). The reuse parameter q is set to 10, which means that data from the last ten time steps will be used to stabilize and accelerate the convergence.","title":"Coupling algorithm"},{"location":"breaking_dam_fluent2d_abaqus2d.html#predictor","text":"The initial guess in every time step is done using the linear predictor.","title":"Predictor"},{"location":"breaking_dam_fluent2d_abaqus2d.html#convergence-criterion","text":"Two convergence criteria have been specified: The number of iterations in every time step is larger than 20. The residual norm on the displacement is a factor 10^{-3} 10^{-3} lower than the initial value. When either criterion is satisfied the simulation stops.","title":"Convergence criterion"},{"location":"breaking_dam_fluent2d_abaqus2d.html#solvers","text":"Fluent is used as flow solver. The provided mesh is triangular. When the gate bends remeshing is performed to perserve its quality. A script to regenerate it using Gambit is included. This script allows to change the resolution and geometrical parameters. The structure solver is Abaqus. The Abaqus case is built when setting up the case starting from the file mesh_breaking_dam.inp containing nodes and elements. This is done by running Abaqus with the make_inp.py Python script to set all parameters, such as surface definitions, material parameters, boundary conditions and time step information. The result of the setup is a completed input file case_breaking_dam.inp . The Abaqus element type used is CPE8R. To exchange information between the solvers on the fluid-structure interface, the use of mappers is required. In the structure solver wrapper, a linear interpolation mapper is used to interpolate in the x- and y-direction from and to the coupled solver.","title":"Solvers"},{"location":"breaking_dam_fluent2d_abaqus2d.html#references","text":"[1] Antoci C., Gallatie M., Sibilla, S., \"Numerical simulation of fluid-structure interaction by sph\", Computers & Structures, vol. 85, no. 11, pp. 879-890, 2007.","title":"References"},{"location":"convergence_criteria.html","text":"Convergence criteria Convergence criteria are an essential part of numerical tools. They should be chosen wisely in order to obtain a reasonably accurate solution without performing more iterations than needed. This documentation describes how the user can practically assemble a set of convergence criteria. Types Iteration limit The type convergence_criterion.iteration_limit is satisfied if the number of coupling iterations equals or is larger than a predefined maximum. Settings The settings dictionary contains one entry: parameter type description maximum int Maximum number of iterations. Absolute norm The type convergence_criterion.absolute_norm is satisfied if the p p -norm of the residual in the last coupling iteration is smaller than a predefined tolerance . More information on how the residual is calculated can be found in the coupled solvers documentation . The p p -norm of the residual r r is defined as \\Vert r \\Vert_p = \\left(\\sum_{i=1}^n \\vert r_{i}\\vert^p\\right)^{1/p} , \\Vert r \\Vert_p = \\left(\\sum_{i=1}^n \\vert r_{i}\\vert^p\\right)^{1/p} , where r_i r_i is the i i -th component of the residual. Settings The settings are as follows: parameter type description order int Order p p of the norm. tolerance double Limit value for convergence. Relative norm The type convergence_criterion.relative_norm is completely analogous to the absolute norm. Instead of the norm of the last residual being smaller than a set tolerance , now the ratio norm of the residual of the last coupling iteration to the norm of the residual of the first coupling iteration is compared to a tolerance . Zero divisions are avoided internally by comparing the norm of the residual of the first coupling iteration to the machine limit for floating points, i.e. the smallest number different from zero. In case this initial norm is too small, an exception will be raised. Should this happen, it is advised to opt for the absolute norm criterion instead of relative norm. Settings These are the same as for convergence_criterion.absolute_norm . Combining multiple convergence criteria In most cases, it is wise to combine two criteria: one to ensure a high enough accuracy and an iteration limit in order to break loops that are not converging fast enough. In that case, the criteria are combined via or or and statements. In that case, the type is set to convergence_criterion.or (alternatively, convergence_criterion.and ) and the settings contain a criteria_list that contains single criteria in the same way as described above. In the following example, the iteration_limit and relative_norm criteria are combined using an or statement. Note that the number of criteria is not limited to two. Moreover, the or and and statements can be combined multiple times, if needed. { \"type\" : \"convergence_criteria.or\" , \"settings\" : { \"criteria_list\" : [ { \"type\" : \"convergence_criteria.iteration_limit\" , \"settings\" : { \"maximum\" : 20 } }, { \"type\" : \"convergence_criteria.relative_norm\" , \"settings\" : { \"order\" : 2 , \"tolerance\" : 1e-3 } } ] } }","title":"Convergence criteria"},{"location":"convergence_criteria.html#convergence-criteria","text":"Convergence criteria are an essential part of numerical tools. They should be chosen wisely in order to obtain a reasonably accurate solution without performing more iterations than needed. This documentation describes how the user can practically assemble a set of convergence criteria.","title":"Convergence criteria"},{"location":"convergence_criteria.html#types","text":"","title":"Types"},{"location":"convergence_criteria.html#iteration-limit","text":"The type convergence_criterion.iteration_limit is satisfied if the number of coupling iterations equals or is larger than a predefined maximum.","title":"Iteration limit"},{"location":"convergence_criteria.html#settings","text":"The settings dictionary contains one entry: parameter type description maximum int Maximum number of iterations.","title":"Settings"},{"location":"convergence_criteria.html#absolute-norm","text":"The type convergence_criterion.absolute_norm is satisfied if the p p -norm of the residual in the last coupling iteration is smaller than a predefined tolerance . More information on how the residual is calculated can be found in the coupled solvers documentation . The p p -norm of the residual r r is defined as \\Vert r \\Vert_p = \\left(\\sum_{i=1}^n \\vert r_{i}\\vert^p\\right)^{1/p} , \\Vert r \\Vert_p = \\left(\\sum_{i=1}^n \\vert r_{i}\\vert^p\\right)^{1/p} , where r_i r_i is the i i -th component of the residual.","title":"Absolute norm"},{"location":"convergence_criteria.html#settings_1","text":"The settings are as follows: parameter type description order int Order p p of the norm. tolerance double Limit value for convergence.","title":"Settings"},{"location":"convergence_criteria.html#relative-norm","text":"The type convergence_criterion.relative_norm is completely analogous to the absolute norm. Instead of the norm of the last residual being smaller than a set tolerance , now the ratio norm of the residual of the last coupling iteration to the norm of the residual of the first coupling iteration is compared to a tolerance . Zero divisions are avoided internally by comparing the norm of the residual of the first coupling iteration to the machine limit for floating points, i.e. the smallest number different from zero. In case this initial norm is too small, an exception will be raised. Should this happen, it is advised to opt for the absolute norm criterion instead of relative norm.","title":"Relative norm"},{"location":"convergence_criteria.html#settings_2","text":"These are the same as for convergence_criterion.absolute_norm .","title":"Settings"},{"location":"convergence_criteria.html#combining-multiple-convergence-criteria","text":"In most cases, it is wise to combine two criteria: one to ensure a high enough accuracy and an iteration limit in order to break loops that are not converging fast enough. In that case, the criteria are combined via or or and statements. In that case, the type is set to convergence_criterion.or (alternatively, convergence_criterion.and ) and the settings contain a criteria_list that contains single criteria in the same way as described above. In the following example, the iteration_limit and relative_norm criteria are combined using an or statement. Note that the number of criteria is not limited to two. Moreover, the or and and statements can be combined multiple times, if needed. { \"type\" : \"convergence_criteria.or\" , \"settings\" : { \"criteria_list\" : [ { \"type\" : \"convergence_criteria.iteration_limit\" , \"settings\" : { \"maximum\" : 20 } }, { \"type\" : \"convergence_criteria.relative_norm\" , \"settings\" : { \"order\" : 2 , \"tolerance\" : 1e-3 } } ] } }","title":"Combining multiple convergence criteria"},{"location":"coupled_solvers.html","text":"Coupled solvers This documentation describes the different types of coupled solvers which are available. A coupled solver refers to a coupling algorithm used to couple two solvers, typically a flow and a structure solver. Some of these coupled solvers make use of one or more models . An odd one out is test_single_solver which allows to test only one solver by coupling it to a dummy solver. All coupled solvers inherit from the class CoupledSolverGaussSeidel . In the parameter JSON file, the dictionary coupled_solver holds the type and the dictionary settings , but also the dictionary predictor , the dictionary convergence_criterion and the list solver_wrappers containing 2 dictionaries: one for each solver wrapper. More information on these last three can be found in the predictors , convergence criteria and the solver wrappers documentation, respectively. In the following subsections, explanatory schematics will be shown. In those schematics, \\mathcal{F} \\mathcal{F} is the first solver with input x x and output \\tilde{y} \\tilde{y} and \\mathcal{S} \\mathcal{S} is the second solver with input y y and output \\tilde{x} \\tilde{x} . Typically, these solvers are a flow and structure solver, respectively. Note that the column vectors such as x x and y y typically contain different components of the same variables or even different variables. Often, the vectors x x and \\tilde{x} \\tilde{x} contain the three components of displacement, whereas the vectors y y and \\tilde{y} \\tilde{y} contain the pressure and the three components of traction. However, this has no importance for the coupled solver, as long as the in- and outputs of both solvers correspond to each other. Further, the superscript k=0\\dots k=0\\dots denotes the iteration, where k+1 k+1 is the current iteration. Finally, the difference between the output \\tilde{x}^k \\tilde{x}^k and input x^k x^k in the same iteration is defined as the residual r^k=\\tilde{x}^k-x^k r^k=\\tilde{x}^k-x^k , which is used to monitor the convergence of the calculation. Gauss-Seidel The type for this coupled solver is coupled_solvers.gauss_seidel . Algorithm Gauss-Seidel or fixed-point iterations are the simplest way of coupling two solvers: the output of one solver is given to the other one without adjustment. The following figure shows the basic methodology. Gauss-Seidel iterations are very simple, but unstable for cases with incompressible flow and high added-mass. A considerable convergence stabilization and acceleration is obtained by modifying the input to one or both of the solvers using derivative information, as will be shown further. Settings The following parameters need to be included in the settings dictionary. Here they are listed in alphabetical order. parameter type description delta_t float Fixed time step size used in both solvers. For a steady simulation typically a value of 1 is taken. case_name string (optional) Default: \"case\" . Name of the case. This name is used to store a pickle file with results ( <name>_results.pickle ) and a restart file ( <name>_restart_ts<time_step>.pickle ). If a files already exists, it is overwritten with the exception of the results file upon restart. In that case the new data is appended. restart_case string (optional) Default: case_name . Only used when restart is performed ( timestep_start > 0). Refers to the case which has to be restarted. The following pickle file will be used: <restart_case>_restart_ts<timestep_start>.pickle . This file path starts in the folder from where the simulation is performed. save_restart int (optional) Default: -1 . Indicates the time step interval at which a restart pickle file has to be saved. A minus sign indicates only the file from the last interval is retained. A save of restart information also triggers a results save , if save_results is non-zero. save_results int (optional) Default: 0 . Time step interval at which a pickle file is written containing some main results for ALL previous time steps. If 0 , no such information is stored and no pickle file is written. time_step_start int Time step number to (re)start a transient FSI calculation. If 0 is given, the simulation starts from scratch. Otherwise, the code looks for the relevant files to start from the corresponding time step. Not every solver wrapper implements restart, see the corresponding documentation for more information. For a steady simulation, the value should be 0 . timestep_start and delta_t are necessary parameters (also in a steady simulation), but can also defined in the solver wrapper directly (e.g. for standalone testing). If they are defined both here and in the solver wrapper, then the former value is used and a warning is printed. These parameters should also be specified for the coupled solvers inheriting from CoupledSolverGaussSeidel . Relaxation This coupled solver inherits from the class CoupledSolverGaussSeidel . The type for this coupled solver is coupled_solvers.relaxation . Algorithm Gauss-Seidel iterations are very simple, but are unstable for cases with incompressible flow and high added-mass. A simple approach to mitigate this is applying relaxation, also called simple mixing. In this coupling method the output of first solver is still given to the other one without adjustment, but the output of the second solver is relaxed as follows: $$ x^{k+1}=(1-\\omega)x^k+\\omega\\tilde{x}^k=x^k+\\omega r^k $$ with x^k x^k and \\tilde{x}^k \\tilde{x}^k , respectively the input for the first solver and the output of the second solver in iteration k k . The difference between both is called the residual r^k=\\tilde{x}^k-x^k r^k=\\tilde{x}^k-x^k . The mixing or relaxation factor is \\omega \\omega . A symbolic schematic is given in the following figure. This method is again quite simple, but able to stabilize some cases that fail with Gauss-Seidel iterations. One can see that a lower \\omega \\omega corresponds to a larger portion of the previous solution to be used. This increases stability, but decreases convergence speed. For more challenging problems, with incompressible flow and high added-mass, this approach will result in a very slow convergence, if it converges at all. Settings Besides the parameters required in the class CoupledSolverGaussSeidel , the following parameters need to be included in the settings dictionary. They are listed in alphabetical order. parameter type description omega float Relaxation factor. Aitken This coupled solver inherits from the class CoupledSolverGaussSeidel . The type for this coupled solver is coupled_solvers.aitken . Algorithm Gauss-Seidel iterations are very simple, but are unstable for many cases. An approach to mitigate this is applying relaxation. However, the choice of a relaxation factor can be difficult: a high factor leads to a higher degree of stability, but a lower convergence speed. In more challenging cases there will be no acceptable value for \\omega \\omega . In this coupling method a dynamic relaxation factor is used. The output of the first solver is still given to the other one without adjustment, but the output of the second solver is relaxed as follows: $$ x^{k+1}=(1-\\omega^k)x^k+\\omega^k\\tilde{x}^k=x^k+\\omega^k r^k $$ with x^k x^k and \\tilde{x}^k \\tilde{x}^k , respectively the input for the first solver and the output of the second solver in iteration k k . The difference between both is called the residual r^k=\\tilde{x}^k-x^k r^k=\\tilde{x}^k-x^k . The mixing or relaxation factor is \\omega^k \\omega^k is dynamic in the sense that its value changes between iterations. A symbolic schematic is given in the following figure. The value of \\omega^k \\omega^k is determined by applying the secant method for scalars directly to vectors and projecting it on r^k-r^{k-1} r^k-r^{k-1} as follows $$ \\omega^k=-\\omega^{k-1}\\frac{(r^{k-1})^T(r^k-r^{k-1})}{(r^k-r^{k-1})^T(r^k-r^{k-1})}. $$ The first relaxation factor in a time step is equal to the last relaxation factor from the previous time step \\omega^n \\omega^n , but limited to \\omega^{max} \\omega^{max} . $$ \\omega^0=\\textrm{sign}(\\omega^n)\\min(|\\omega^n|,\\omega^{max}). $$ The relaxation factor in the first time step is equal to \\omega^{max} \\omega^{max} . This method improves convergence speed drastically compared to Gauss-Seidel iterations, but even faster convergence can be obtained using quasi-Newton methods, which can be interpreted as using different relaxation factors for different Fourier modes of the output of the second solver. Settings Besides the parameters required in the class CoupledSolverGaussSeidel , the following parameters need to be included in the settings dictionary. They are listed in alphabetical order. parameter type description omega_max float Maximal relaxation factor. IQNI This coupled solver inherits from the class CoupledSolverGaussSeidel . The type for this coupled solver is coupled_solvers.iqni . Algorithm The abbreviation IQNI refers to interface quasi-Newton with inverse Jacobian . In this type of coupling algorithm, the combination of the two solvers is seen as one system. The input of the first solver \\mathcal{F} \\mathcal{F} in iteration k k is denoted by x^k x^k . The output of this solver is transferred unchanged to the second solver. The output of the second solver is denoted \\tilde{x}^k \\tilde{x}^k . The difference between input and output is called the residual r^k=\\tilde{x}^k-x^k r^k=\\tilde{x}^k-x^k . A residual operator \\mathcal{R}(x) \\mathcal{R}(x) is defined, which returns the residual r^k r^k as a function of x^k x^k . The goal is to find x x for which \\mathcal{R}(x)=0 \\mathcal{R}(x)=0 , i.e. the root. This system of non-linear equations is solved using Newton-Raphson iterations as follows $$ \\Delta x^k=\\mathcal{R}'^{-1}(x^k)\\Delta r, $$ where \\mathcal{R}' \\mathcal{R}' is the Jacobian of \\mathcal{R} \\mathcal{R} with respect to x x , \\Delta x^k=x^{k+1}-x^k \\Delta x^k=x^{k+1}-x^k is the difference between the input of two subsequent iterations and \\Delta r^k=0-r^k=-r^k \\Delta r^k=0-r^k=-r^k is the difference between the desired and the current residual. The iteration update can also be written as $$ x^{k+1}=x^k-\\mathcal{R}'^{-1}(x^k)r^k. $$ However, this Jacobian is not accessible and therefore has to be approximated. Instead of approximating \\mathcal{R}' \\mathcal{R}' , solving the linear system can be avoided by approximating its inverse directly. The approximation procedure typically results in a low-rank Jacobian. Whereas, a full rank Jacobian is required for the Newton-Raphson update to function properly. Therefore, the inverse Jacobian of an altered residual operator \\tilde{\\mathcal{R}} \\tilde{\\mathcal{R}} is approximated. This altered residual operator is defined as follows $$ r^{k+1}=\\tilde{\\mathcal{R}}(\\tilde{x}^{k+1})=\\mathcal{R}(\\tilde{x}^{k+1}-r^{k+1}). $$ The inverse of both Jacobians are linked by $$ \\tilde{\\mathcal{R}}'^{-1}=\\mathcal{R}'^{-1}+I, $$ where \\tilde{\\mathcal{R}}' \\tilde{\\mathcal{R}}' is the Jacobian of \\tilde{\\mathcal{R}} \\tilde{\\mathcal{R}} with respect to \\tilde{x} \\tilde{x} and I I is the identity matrix. For this Jacobian the following is valid $$ \\Delta \\tilde{x}^k=\\tilde{\\mathcal{R}}'^{-1}(x^k)\\Delta r^k, $$ where \\Delta\\tilde{x}^k=\\tilde{x}^{k+1}-\\tilde{x}^k \\Delta\\tilde{x}^k=\\tilde{x}^{k+1}-\\tilde{x}^k is the difference between the the output of two subsequent iterations. This Jacobian is also not known, but is approximated using a model and denoted by \\tilde{N}^k \\tilde{N}^k . The type of model and its settings are specified in the settings dictionary. This model returns an estimation of \\Delta\\tilde{x}^k \\Delta\\tilde{x}^k given a value \\Delta r^k=-r^k \\Delta r^k=-r^k $$ \\Delta\\tilde{x}^k=\\tilde{N}^k \\Delta r^k. $$ Finally resulting in the update formula $$ x^{k+1}=x^k+(\\tilde{N}^k-I)\\Delta r^k=x^k-\\tilde{N}^k r^k+r^k. $$ A symbolic schematic is given in the following figure. For more information with respect to the approximation of the Jacobian, refer to the models documentation . More information about residual operator methods can be found in [ 1 ]. Settings Besides the parameters required in the class CoupledSolverGaussSeidel , the following parameters need to be included in the settings dictionary. They are listed in alphabetical order. parameter type description model dict Model component. omega float Relaxation factor. IBQN This coupled solver inherits from the class CoupledSolverGaussSeidel . The type for this coupled solver is coupled_solvers.ibqn . Algorithm The abbreviation IBQN refers to interface block quasi-Newton . In type of coupling iteration, the system $$ \\begin{cases} \\mathcal{F}(x)-y=0 \\newline \\mathcal{S}(y)-x=0 \\end{cases} $$ is solved in block form. Again, \\mathcal{F} \\mathcal{F} is the first solver with input x x and output \\tilde{y} \\tilde{y} and \\mathcal{S} \\mathcal{S} is the second solver with input y y and output \\tilde{x} \\tilde{x} . In this iteration scheme, the output of each solver is altered before being transferred to the other one. Solving the system in block Newton-Raphson iterations results in $$ \\begin{bmatrix} \\mathcal{F}'(x) & -I \\newline -I & \\mathcal{S}'(y) \\end{bmatrix} \\begin{bmatrix} \\Delta x \\newline \\Delta y \\end{bmatrix} =- \\begin{bmatrix} \\mathcal{F}(x)-y \\newline \\mathcal{S}(y)-x \\end{bmatrix}, $$ where \\mathcal{F}' \\mathcal{F}' and \\mathcal{S}' \\mathcal{S}' denote the Jacobians of the first and second solver, respectively. These Jacobians are, however, not accessible and are approximated using a model as specified in the settings dictionary. To the first and second solver correspond model_f , denoted here by M_f M_f , and model_s , denoted bye M_s M_s , respectively. For example, model_f returns an estimation of \\Delta\\tilde{y}^k=\\tilde{y}^{k+1}-\\tilde{y}^k \\Delta\\tilde{y}^k=\\tilde{y}^{k+1}-\\tilde{y}^k given \\Delta x^k=x^{k+1}-x^k \\Delta x^k=x^{k+1}-x^k $$ \\Delta\\tilde{y}^k=M_f^k \\Delta x^k. $$ Solving for x^{k+1}=x^k+\\Delta x^k x^{k+1}=x^k+\\Delta x^k requires solving the system $$ \\left(I-M_s^k M_f^k\\right)\\Delta x^k =\\tilde{x}^k-x^k+M_s^k(\\tilde{y}^k-y^k) $$ for \\Delta x^k \\Delta x^k . This is done matrix-free using the Generalized minimal residual method (GMRES). Analogously, the input y^{k+1}=y^k+\\Delta y^k y^{k+1}=y^k+\\Delta y^k for the structural solver by solving $$ \\left(I-M_f^{k+1}M_s^k\\right)\\Delta y^k =\\tilde{y}^{k+1}-y^k+M_f^{k+1}(\\tilde{x}^k-x^{k+1}) $$ for \\Delta y^k \\Delta y^k . A symbolic schematic is given in the following figure. The actual approximation of the Jacobian occurs with the same models as before. More information about block methods can be found in [ 1 ]. Settings Besides the parameters required in the class CoupledSolverGaussSeidel , the following parameters need to be included in the settings dictionary. They are listed in alphabetical order. parameter type description absolute_tolerance_gmres float Absolute tolerance used in the GMRES method. model_f dict Model component corresponding to the first solver wrapper. model_s dict Model component corresponding to the second solver wrapper. omega float Relaxation factor. relative_tolerance_gmres float Relative tolerance used in the GMRES method. Test single solver The solver test_single_solver can be used to test new cases and solver settings. The idea behind this component is to only test one of the two solvers, while the other one is replaced by a dummy. This test environment inherits from the class CoupledSolverGaussSeidel . The type for this coupled solver is coupled_solvers.test_single_solver . Dummy solver To test only one solver, a dummy solver must be used. Such a dummy solver is implemented by a test class in the file dummy_solver.py . Its path starts in the folder from where the simulation is performed, e.g. the same folder level as run_simulation.py . Upon run-time an instance of this class is made. The test class requires methods of the form calculate_<variable>(x,y,z,n) , with <variable> being a variable required by the tested solver, e.g. displacement , pressure or traction . How these variables are defined inside these methods, is up to the user. However, the methods need to return the right format: a 3-element list or numpy array for vector variables and a 1-element list or numpy array for scalar variables. Some examples are given in the example test_single_solver . The test class name is provided in the JSON settings as a string. If no test class is provided or the value None is used, zero input will be used. Settings The JSON file requirements for the class CoupledSolverTestSingleSolver are different from the other coupled solvers in the sense that they only require the type , which is coupled_solvers.test_single_solver , the dictionary test_settings and the list solver_wrappers containing at least one solver wrapper. The keys for the test_settings dictionary are listed in alphabetical order below. parameter type description delta_t float (optional) Time step size to be used in the test. Is optional as long as this value is defined in the settings dictionary. If a different value is defined in both dictionaries, the one defined in test_settings is chosen. case_name string (optional) Name of the case used to store a pickle file with results. The pickle file will have the name <name>_<test_solver_working_directory>_results.pickle . If not provided, the value from settings is used or if settings is not present: \"case\" . save_results int (optional) Default: 0 . Time step interval at which a pickle file is written containing some main results for ALL previous time steps. If 0 , no such information is stored and no pickle file is written. If not provided, the value from settings is used or if settings is not present: 0 . solver_index int Has a value 0 or 1 and indicates the solver that one wants to test. 0 indicates the first solver wrapper that appears in the JSON-file, 1 the second one. test_class string (optional) Refers to the class to use in the dummy_solver.py . If not provided or None , zero input will be used. timestep_start int (optional) Time step to start from. If not provided the value defined in the settings dictionary is used. If the settings dictionary is not present, zero is used. Other dictionaries, used for the actual calculation can be kept, but will not be used, with the possible exception of the settings dictionary. The settings dictionary is used to look up delta_t , timestep_start , save_results and case_name if not provided in test_settings . Note that test_settings has priority over the parameters defined in settings . This means a calculation can be tested, by only adding the test_settings dictionary and changing the coupled solver type to coupled_solvers.test_single_solver and without altering anything else. An illustration can be found in the example test_single_solver . The working directory of the solver is copied to a new directory with the same name and a suffix _testX with X an integer starting from 0. As such, previous test solver working directories are not overwritten. The optional pickle file, which saves some results , uses the name as specified by the JSON settings followed by an underscore and the solver test working directory. As such, the pickle file can always be linked to the corresponding test working directory. During run time, the norm of x x and y y are printed. A residual does not exist here. The arrays x x and y y do not have a physical meaning, but are the in- and output of the first solver, which is typically the flow solver. Then, the vector y y will contain pressure and traction components for all points. Nonetheless, these values can be useful to verify that the solver wrapper runs. The test environment test_single_solver tests only the solver_wrapper itself, no mapping is included. Save results In each coupled solver, a positive non-zero value can be assigned to the save_results parameter, in order to save some results into a pickle file. The key case_name dictates the name of this file as explained above. The pickle file is written corresponding to the time step interval as dictated by save_results , but contains information for all time steps. In other words, if the parameter is non-zero, it only controls the writing frequency and not the content of the file. If save_results is zero, no result are kept and no file is written. For a non-zero value of save_restart , a save for restart purposes also triggers the saving of the results file. The pickle file may be used by the postprocessing files included with the examples. It contains a dictionary with the following keys: key value type description solution_x numpy array Contains the values of the vector x x (typically displacement) for every time step as columns of a 2 dimensional np-array. The initial value is included as well, such that the number of column will be one higher than the number of calculated time steps. The vector x x refers to the input of the first solver wrapper. solution_y numpy array Contains the values of the vector y y (typically pressure and traction) for every time step as columns of a 2 dimensional np-array, similar to solution_x . The vector y y refers to the input of the second solver wrapper. interface_x interface Interface object used as input for the first solver wrapper. interface_y interface Interface object used as input for the second solver wrapper. iterations list Contains the performed number of coupling iterations for every time step. run_time float Equals the total computation time, i.e. the time between initialization and finalization (excluding initialization). residual list Nested list, which contains for each time step a list, on its turn containing residuals, one for every iteration of that time step. delta_t float Equals the used time step size. timestep_start int Equals the used start time step. case_name string Name of the case. info string Additional info, such as date, restart history and hostname of machine on which simulation is run. In simulations with a large number of points on the interface and a very large number of time steps, this file might take up a larger amount of storage. Finally, there is also a debug option, which can be activated by setting the boolean self.debug on True in the code file itself. Then, the above information is stored every iteration. Additionally, the residual vector is saved as well using the key solution_r , analogously to solution_x and solution_y . Note, however, that the pickle file can be become very large in that case. This option is only meant for debugging a new coupling algorithm. It should not be used in combination with restart. Restart The restart functionality is very useful to continue a calculation which has been stopped, either intentionally or unintentionally. The goal is to continue as if the code had never been interrupted. In order to restart from time step n n , the coupled solver saves the predictor and possibly one or more models in the state at the end of time step n n in a pickle file. By saving the predictor, the initial guess at the start of the first time step(s) will be the same, as the predictor typically extrapolates the solution from the previous time step(s) in some way. The model(s) are saved such that the behavior of the coupling algorithm is the same. This is only important if the model behavior depends on data from previous time steps, e.g. models with reuse (q>0). The following table gives an overview of the coupled solvers which save one or more additional components or values. type additional components saved for restart coupled_solvers.aitken omega coupled_solvers.iqni model coupled_solvers.ibqn model_f and model_s However, not only the predictor and coupling algorithm depend on previous time steps; this is typically also the case for the solvers. Therefore, it is the responsibility of the solver wrappers, to setup the solvers correctly for restart: they need to ensure that the variables in the whole computational domain are set to the value of time step n n . Moreover, its vital that they reconstruct the exact same model parts as in the initial calculation. In other words, the undeformed coordinates must be the same. Conversely, they are not required to initialize the interfaces with the correct data from time step n n , as this taken care of by the predictor in the coupled solver. Only when both solver wrappers allow restart, is is possible to restart a calculation! Saving restart files During a calculation it is possible to save restart pickle files. As described above the pickle file for restart has a name ( <name>_restart_ts<time_step>.pickle ), based on the setting case_name . The frequency of saving a restart pickle file is determined by the save_restart interval as described above. Remark that it is only useful to save the restart pickle file, when the solver data are saved as well. Therefore, the save_restart parameter is transferred automatically to the solver wrappers. If save_results is non-zero, a save of restart information also triggers the saving of the results pickle file , to avoid discontinuity of this file. Performing restart To restart a case, timestep_start has to be a positive integer above zero. The first time step that will be calculated is timestep_start plus one. The methodology described above does not allow to change any settings of the predictor or model(s), nor the type of coupled solver. Upon restart, this condition is checked, as well as the presence of the pickle file for restart. This file is identified by the setting restart_case as <restart_case>_restart_ts<timestep_start>.pickle . Additionally, it is checked that the new model parts are exactly the same as the previous ones. It is important to realize that the pickle file only makes sure that the initial guess and coupling algorithm work as before. The physical effect of previous time steps dealt with by the solver wrappers. Therefore, in order to be able to perform a restart, the solver files for the corresponding time step also need to be present! When performing restart, the new data will be neatly appended to the already existing results pickle file, leaving out existing time step data after the new time step start. As a result, the results pickle file looks exactly as if the calculation was never stopped, with the exception of the fields run_time and info . The latter provides a very shot log of when restart is performed. If the results pickle file would not be found for any reason, the user is informed and a new one is made, with the correct timestep_start . Note that the presence of the restart pickle file on the other hand is required. If the case_name is changed, the restart can still be performed by providing the case name for restart using restart_case (see explanation above). References [1] Delaiss\u00e9 N., Demeester T., Fauconnier D. and Degroote J., \"Comparison of different quasi-Newton techniques for coupling of black box solvers\", in ECCOMAS 2020, Proceedings, Paris, France, 2021.","title":"Coupled solvers"},{"location":"coupled_solvers.html#coupled-solvers","text":"This documentation describes the different types of coupled solvers which are available. A coupled solver refers to a coupling algorithm used to couple two solvers, typically a flow and a structure solver. Some of these coupled solvers make use of one or more models . An odd one out is test_single_solver which allows to test only one solver by coupling it to a dummy solver. All coupled solvers inherit from the class CoupledSolverGaussSeidel . In the parameter JSON file, the dictionary coupled_solver holds the type and the dictionary settings , but also the dictionary predictor , the dictionary convergence_criterion and the list solver_wrappers containing 2 dictionaries: one for each solver wrapper. More information on these last three can be found in the predictors , convergence criteria and the solver wrappers documentation, respectively. In the following subsections, explanatory schematics will be shown. In those schematics, \\mathcal{F} \\mathcal{F} is the first solver with input x x and output \\tilde{y} \\tilde{y} and \\mathcal{S} \\mathcal{S} is the second solver with input y y and output \\tilde{x} \\tilde{x} . Typically, these solvers are a flow and structure solver, respectively. Note that the column vectors such as x x and y y typically contain different components of the same variables or even different variables. Often, the vectors x x and \\tilde{x} \\tilde{x} contain the three components of displacement, whereas the vectors y y and \\tilde{y} \\tilde{y} contain the pressure and the three components of traction. However, this has no importance for the coupled solver, as long as the in- and outputs of both solvers correspond to each other. Further, the superscript k=0\\dots k=0\\dots denotes the iteration, where k+1 k+1 is the current iteration. Finally, the difference between the output \\tilde{x}^k \\tilde{x}^k and input x^k x^k in the same iteration is defined as the residual r^k=\\tilde{x}^k-x^k r^k=\\tilde{x}^k-x^k , which is used to monitor the convergence of the calculation.","title":"Coupled solvers"},{"location":"coupled_solvers.html#gauss-seidel","text":"The type for this coupled solver is coupled_solvers.gauss_seidel .","title":"Gauss-Seidel"},{"location":"coupled_solvers.html#algorithm","text":"Gauss-Seidel or fixed-point iterations are the simplest way of coupling two solvers: the output of one solver is given to the other one without adjustment. The following figure shows the basic methodology. Gauss-Seidel iterations are very simple, but unstable for cases with incompressible flow and high added-mass. A considerable convergence stabilization and acceleration is obtained by modifying the input to one or both of the solvers using derivative information, as will be shown further.","title":"Algorithm"},{"location":"coupled_solvers.html#settings","text":"The following parameters need to be included in the settings dictionary. Here they are listed in alphabetical order. parameter type description delta_t float Fixed time step size used in both solvers. For a steady simulation typically a value of 1 is taken. case_name string (optional) Default: \"case\" . Name of the case. This name is used to store a pickle file with results ( <name>_results.pickle ) and a restart file ( <name>_restart_ts<time_step>.pickle ). If a files already exists, it is overwritten with the exception of the results file upon restart. In that case the new data is appended. restart_case string (optional) Default: case_name . Only used when restart is performed ( timestep_start > 0). Refers to the case which has to be restarted. The following pickle file will be used: <restart_case>_restart_ts<timestep_start>.pickle . This file path starts in the folder from where the simulation is performed. save_restart int (optional) Default: -1 . Indicates the time step interval at which a restart pickle file has to be saved. A minus sign indicates only the file from the last interval is retained. A save of restart information also triggers a results save , if save_results is non-zero. save_results int (optional) Default: 0 . Time step interval at which a pickle file is written containing some main results for ALL previous time steps. If 0 , no such information is stored and no pickle file is written. time_step_start int Time step number to (re)start a transient FSI calculation. If 0 is given, the simulation starts from scratch. Otherwise, the code looks for the relevant files to start from the corresponding time step. Not every solver wrapper implements restart, see the corresponding documentation for more information. For a steady simulation, the value should be 0 . timestep_start and delta_t are necessary parameters (also in a steady simulation), but can also defined in the solver wrapper directly (e.g. for standalone testing). If they are defined both here and in the solver wrapper, then the former value is used and a warning is printed. These parameters should also be specified for the coupled solvers inheriting from CoupledSolverGaussSeidel .","title":"Settings"},{"location":"coupled_solvers.html#relaxation","text":"This coupled solver inherits from the class CoupledSolverGaussSeidel . The type for this coupled solver is coupled_solvers.relaxation .","title":"Relaxation"},{"location":"coupled_solvers.html#algorithm_1","text":"Gauss-Seidel iterations are very simple, but are unstable for cases with incompressible flow and high added-mass. A simple approach to mitigate this is applying relaxation, also called simple mixing. In this coupling method the output of first solver is still given to the other one without adjustment, but the output of the second solver is relaxed as follows: $$ x^{k+1}=(1-\\omega)x^k+\\omega\\tilde{x}^k=x^k+\\omega r^k $$ with x^k x^k and \\tilde{x}^k \\tilde{x}^k , respectively the input for the first solver and the output of the second solver in iteration k k . The difference between both is called the residual r^k=\\tilde{x}^k-x^k r^k=\\tilde{x}^k-x^k . The mixing or relaxation factor is \\omega \\omega . A symbolic schematic is given in the following figure. This method is again quite simple, but able to stabilize some cases that fail with Gauss-Seidel iterations. One can see that a lower \\omega \\omega corresponds to a larger portion of the previous solution to be used. This increases stability, but decreases convergence speed. For more challenging problems, with incompressible flow and high added-mass, this approach will result in a very slow convergence, if it converges at all.","title":"Algorithm"},{"location":"coupled_solvers.html#settings_1","text":"Besides the parameters required in the class CoupledSolverGaussSeidel , the following parameters need to be included in the settings dictionary. They are listed in alphabetical order. parameter type description omega float Relaxation factor.","title":"Settings"},{"location":"coupled_solvers.html#aitken","text":"This coupled solver inherits from the class CoupledSolverGaussSeidel . The type for this coupled solver is coupled_solvers.aitken .","title":"Aitken"},{"location":"coupled_solvers.html#algorithm_2","text":"Gauss-Seidel iterations are very simple, but are unstable for many cases. An approach to mitigate this is applying relaxation. However, the choice of a relaxation factor can be difficult: a high factor leads to a higher degree of stability, but a lower convergence speed. In more challenging cases there will be no acceptable value for \\omega \\omega . In this coupling method a dynamic relaxation factor is used. The output of the first solver is still given to the other one without adjustment, but the output of the second solver is relaxed as follows: $$ x^{k+1}=(1-\\omega^k)x^k+\\omega^k\\tilde{x}^k=x^k+\\omega^k r^k $$ with x^k x^k and \\tilde{x}^k \\tilde{x}^k , respectively the input for the first solver and the output of the second solver in iteration k k . The difference between both is called the residual r^k=\\tilde{x}^k-x^k r^k=\\tilde{x}^k-x^k . The mixing or relaxation factor is \\omega^k \\omega^k is dynamic in the sense that its value changes between iterations. A symbolic schematic is given in the following figure. The value of \\omega^k \\omega^k is determined by applying the secant method for scalars directly to vectors and projecting it on r^k-r^{k-1} r^k-r^{k-1} as follows $$ \\omega^k=-\\omega^{k-1}\\frac{(r^{k-1})^T(r^k-r^{k-1})}{(r^k-r^{k-1})^T(r^k-r^{k-1})}. $$ The first relaxation factor in a time step is equal to the last relaxation factor from the previous time step \\omega^n \\omega^n , but limited to \\omega^{max} \\omega^{max} . $$ \\omega^0=\\textrm{sign}(\\omega^n)\\min(|\\omega^n|,\\omega^{max}). $$ The relaxation factor in the first time step is equal to \\omega^{max} \\omega^{max} . This method improves convergence speed drastically compared to Gauss-Seidel iterations, but even faster convergence can be obtained using quasi-Newton methods, which can be interpreted as using different relaxation factors for different Fourier modes of the output of the second solver.","title":"Algorithm"},{"location":"coupled_solvers.html#settings_2","text":"Besides the parameters required in the class CoupledSolverGaussSeidel , the following parameters need to be included in the settings dictionary. They are listed in alphabetical order. parameter type description omega_max float Maximal relaxation factor.","title":"Settings"},{"location":"coupled_solvers.html#iqni","text":"This coupled solver inherits from the class CoupledSolverGaussSeidel . The type for this coupled solver is coupled_solvers.iqni .","title":"IQNI"},{"location":"coupled_solvers.html#algorithm_3","text":"The abbreviation IQNI refers to interface quasi-Newton with inverse Jacobian . In this type of coupling algorithm, the combination of the two solvers is seen as one system. The input of the first solver \\mathcal{F} \\mathcal{F} in iteration k k is denoted by x^k x^k . The output of this solver is transferred unchanged to the second solver. The output of the second solver is denoted \\tilde{x}^k \\tilde{x}^k . The difference between input and output is called the residual r^k=\\tilde{x}^k-x^k r^k=\\tilde{x}^k-x^k . A residual operator \\mathcal{R}(x) \\mathcal{R}(x) is defined, which returns the residual r^k r^k as a function of x^k x^k . The goal is to find x x for which \\mathcal{R}(x)=0 \\mathcal{R}(x)=0 , i.e. the root. This system of non-linear equations is solved using Newton-Raphson iterations as follows $$ \\Delta x^k=\\mathcal{R}'^{-1}(x^k)\\Delta r, $$ where \\mathcal{R}' \\mathcal{R}' is the Jacobian of \\mathcal{R} \\mathcal{R} with respect to x x , \\Delta x^k=x^{k+1}-x^k \\Delta x^k=x^{k+1}-x^k is the difference between the input of two subsequent iterations and \\Delta r^k=0-r^k=-r^k \\Delta r^k=0-r^k=-r^k is the difference between the desired and the current residual. The iteration update can also be written as $$ x^{k+1}=x^k-\\mathcal{R}'^{-1}(x^k)r^k. $$ However, this Jacobian is not accessible and therefore has to be approximated. Instead of approximating \\mathcal{R}' \\mathcal{R}' , solving the linear system can be avoided by approximating its inverse directly. The approximation procedure typically results in a low-rank Jacobian. Whereas, a full rank Jacobian is required for the Newton-Raphson update to function properly. Therefore, the inverse Jacobian of an altered residual operator \\tilde{\\mathcal{R}} \\tilde{\\mathcal{R}} is approximated. This altered residual operator is defined as follows $$ r^{k+1}=\\tilde{\\mathcal{R}}(\\tilde{x}^{k+1})=\\mathcal{R}(\\tilde{x}^{k+1}-r^{k+1}). $$ The inverse of both Jacobians are linked by $$ \\tilde{\\mathcal{R}}'^{-1}=\\mathcal{R}'^{-1}+I, $$ where \\tilde{\\mathcal{R}}' \\tilde{\\mathcal{R}}' is the Jacobian of \\tilde{\\mathcal{R}} \\tilde{\\mathcal{R}} with respect to \\tilde{x} \\tilde{x} and I I is the identity matrix. For this Jacobian the following is valid $$ \\Delta \\tilde{x}^k=\\tilde{\\mathcal{R}}'^{-1}(x^k)\\Delta r^k, $$ where \\Delta\\tilde{x}^k=\\tilde{x}^{k+1}-\\tilde{x}^k \\Delta\\tilde{x}^k=\\tilde{x}^{k+1}-\\tilde{x}^k is the difference between the the output of two subsequent iterations. This Jacobian is also not known, but is approximated using a model and denoted by \\tilde{N}^k \\tilde{N}^k . The type of model and its settings are specified in the settings dictionary. This model returns an estimation of \\Delta\\tilde{x}^k \\Delta\\tilde{x}^k given a value \\Delta r^k=-r^k \\Delta r^k=-r^k $$ \\Delta\\tilde{x}^k=\\tilde{N}^k \\Delta r^k. $$ Finally resulting in the update formula $$ x^{k+1}=x^k+(\\tilde{N}^k-I)\\Delta r^k=x^k-\\tilde{N}^k r^k+r^k. $$ A symbolic schematic is given in the following figure. For more information with respect to the approximation of the Jacobian, refer to the models documentation . More information about residual operator methods can be found in [ 1 ].","title":"Algorithm"},{"location":"coupled_solvers.html#settings_3","text":"Besides the parameters required in the class CoupledSolverGaussSeidel , the following parameters need to be included in the settings dictionary. They are listed in alphabetical order. parameter type description model dict Model component. omega float Relaxation factor.","title":"Settings"},{"location":"coupled_solvers.html#ibqn","text":"This coupled solver inherits from the class CoupledSolverGaussSeidel . The type for this coupled solver is coupled_solvers.ibqn .","title":"IBQN"},{"location":"coupled_solvers.html#algorithm_4","text":"The abbreviation IBQN refers to interface block quasi-Newton . In type of coupling iteration, the system $$ \\begin{cases} \\mathcal{F}(x)-y=0 \\newline \\mathcal{S}(y)-x=0 \\end{cases} $$ is solved in block form. Again, \\mathcal{F} \\mathcal{F} is the first solver with input x x and output \\tilde{y} \\tilde{y} and \\mathcal{S} \\mathcal{S} is the second solver with input y y and output \\tilde{x} \\tilde{x} . In this iteration scheme, the output of each solver is altered before being transferred to the other one. Solving the system in block Newton-Raphson iterations results in $$ \\begin{bmatrix} \\mathcal{F}'(x) & -I \\newline -I & \\mathcal{S}'(y) \\end{bmatrix} \\begin{bmatrix} \\Delta x \\newline \\Delta y \\end{bmatrix} =- \\begin{bmatrix} \\mathcal{F}(x)-y \\newline \\mathcal{S}(y)-x \\end{bmatrix}, $$ where \\mathcal{F}' \\mathcal{F}' and \\mathcal{S}' \\mathcal{S}' denote the Jacobians of the first and second solver, respectively. These Jacobians are, however, not accessible and are approximated using a model as specified in the settings dictionary. To the first and second solver correspond model_f , denoted here by M_f M_f , and model_s , denoted bye M_s M_s , respectively. For example, model_f returns an estimation of \\Delta\\tilde{y}^k=\\tilde{y}^{k+1}-\\tilde{y}^k \\Delta\\tilde{y}^k=\\tilde{y}^{k+1}-\\tilde{y}^k given \\Delta x^k=x^{k+1}-x^k \\Delta x^k=x^{k+1}-x^k $$ \\Delta\\tilde{y}^k=M_f^k \\Delta x^k. $$ Solving for x^{k+1}=x^k+\\Delta x^k x^{k+1}=x^k+\\Delta x^k requires solving the system $$ \\left(I-M_s^k M_f^k\\right)\\Delta x^k =\\tilde{x}^k-x^k+M_s^k(\\tilde{y}^k-y^k) $$ for \\Delta x^k \\Delta x^k . This is done matrix-free using the Generalized minimal residual method (GMRES). Analogously, the input y^{k+1}=y^k+\\Delta y^k y^{k+1}=y^k+\\Delta y^k for the structural solver by solving $$ \\left(I-M_f^{k+1}M_s^k\\right)\\Delta y^k =\\tilde{y}^{k+1}-y^k+M_f^{k+1}(\\tilde{x}^k-x^{k+1}) $$ for \\Delta y^k \\Delta y^k . A symbolic schematic is given in the following figure. The actual approximation of the Jacobian occurs with the same models as before. More information about block methods can be found in [ 1 ].","title":"Algorithm"},{"location":"coupled_solvers.html#settings_4","text":"Besides the parameters required in the class CoupledSolverGaussSeidel , the following parameters need to be included in the settings dictionary. They are listed in alphabetical order. parameter type description absolute_tolerance_gmres float Absolute tolerance used in the GMRES method. model_f dict Model component corresponding to the first solver wrapper. model_s dict Model component corresponding to the second solver wrapper. omega float Relaxation factor. relative_tolerance_gmres float Relative tolerance used in the GMRES method.","title":"Settings"},{"location":"coupled_solvers.html#test-single-solver","text":"The solver test_single_solver can be used to test new cases and solver settings. The idea behind this component is to only test one of the two solvers, while the other one is replaced by a dummy. This test environment inherits from the class CoupledSolverGaussSeidel . The type for this coupled solver is coupled_solvers.test_single_solver .","title":"Test single solver"},{"location":"coupled_solvers.html#dummy-solver","text":"To test only one solver, a dummy solver must be used. Such a dummy solver is implemented by a test class in the file dummy_solver.py . Its path starts in the folder from where the simulation is performed, e.g. the same folder level as run_simulation.py . Upon run-time an instance of this class is made. The test class requires methods of the form calculate_<variable>(x,y,z,n) , with <variable> being a variable required by the tested solver, e.g. displacement , pressure or traction . How these variables are defined inside these methods, is up to the user. However, the methods need to return the right format: a 3-element list or numpy array for vector variables and a 1-element list or numpy array for scalar variables. Some examples are given in the example test_single_solver . The test class name is provided in the JSON settings as a string. If no test class is provided or the value None is used, zero input will be used.","title":"Dummy solver"},{"location":"coupled_solvers.html#settings_5","text":"The JSON file requirements for the class CoupledSolverTestSingleSolver are different from the other coupled solvers in the sense that they only require the type , which is coupled_solvers.test_single_solver , the dictionary test_settings and the list solver_wrappers containing at least one solver wrapper. The keys for the test_settings dictionary are listed in alphabetical order below. parameter type description delta_t float (optional) Time step size to be used in the test. Is optional as long as this value is defined in the settings dictionary. If a different value is defined in both dictionaries, the one defined in test_settings is chosen. case_name string (optional) Name of the case used to store a pickle file with results. The pickle file will have the name <name>_<test_solver_working_directory>_results.pickle . If not provided, the value from settings is used or if settings is not present: \"case\" . save_results int (optional) Default: 0 . Time step interval at which a pickle file is written containing some main results for ALL previous time steps. If 0 , no such information is stored and no pickle file is written. If not provided, the value from settings is used or if settings is not present: 0 . solver_index int Has a value 0 or 1 and indicates the solver that one wants to test. 0 indicates the first solver wrapper that appears in the JSON-file, 1 the second one. test_class string (optional) Refers to the class to use in the dummy_solver.py . If not provided or None , zero input will be used. timestep_start int (optional) Time step to start from. If not provided the value defined in the settings dictionary is used. If the settings dictionary is not present, zero is used. Other dictionaries, used for the actual calculation can be kept, but will not be used, with the possible exception of the settings dictionary. The settings dictionary is used to look up delta_t , timestep_start , save_results and case_name if not provided in test_settings . Note that test_settings has priority over the parameters defined in settings . This means a calculation can be tested, by only adding the test_settings dictionary and changing the coupled solver type to coupled_solvers.test_single_solver and without altering anything else. An illustration can be found in the example test_single_solver . The working directory of the solver is copied to a new directory with the same name and a suffix _testX with X an integer starting from 0. As such, previous test solver working directories are not overwritten. The optional pickle file, which saves some results , uses the name as specified by the JSON settings followed by an underscore and the solver test working directory. As such, the pickle file can always be linked to the corresponding test working directory. During run time, the norm of x x and y y are printed. A residual does not exist here. The arrays x x and y y do not have a physical meaning, but are the in- and output of the first solver, which is typically the flow solver. Then, the vector y y will contain pressure and traction components for all points. Nonetheless, these values can be useful to verify that the solver wrapper runs. The test environment test_single_solver tests only the solver_wrapper itself, no mapping is included.","title":"Settings"},{"location":"coupled_solvers.html#save-results","text":"In each coupled solver, a positive non-zero value can be assigned to the save_results parameter, in order to save some results into a pickle file. The key case_name dictates the name of this file as explained above. The pickle file is written corresponding to the time step interval as dictated by save_results , but contains information for all time steps. In other words, if the parameter is non-zero, it only controls the writing frequency and not the content of the file. If save_results is zero, no result are kept and no file is written. For a non-zero value of save_restart , a save for restart purposes also triggers the saving of the results file. The pickle file may be used by the postprocessing files included with the examples. It contains a dictionary with the following keys: key value type description solution_x numpy array Contains the values of the vector x x (typically displacement) for every time step as columns of a 2 dimensional np-array. The initial value is included as well, such that the number of column will be one higher than the number of calculated time steps. The vector x x refers to the input of the first solver wrapper. solution_y numpy array Contains the values of the vector y y (typically pressure and traction) for every time step as columns of a 2 dimensional np-array, similar to solution_x . The vector y y refers to the input of the second solver wrapper. interface_x interface Interface object used as input for the first solver wrapper. interface_y interface Interface object used as input for the second solver wrapper. iterations list Contains the performed number of coupling iterations for every time step. run_time float Equals the total computation time, i.e. the time between initialization and finalization (excluding initialization). residual list Nested list, which contains for each time step a list, on its turn containing residuals, one for every iteration of that time step. delta_t float Equals the used time step size. timestep_start int Equals the used start time step. case_name string Name of the case. info string Additional info, such as date, restart history and hostname of machine on which simulation is run. In simulations with a large number of points on the interface and a very large number of time steps, this file might take up a larger amount of storage. Finally, there is also a debug option, which can be activated by setting the boolean self.debug on True in the code file itself. Then, the above information is stored every iteration. Additionally, the residual vector is saved as well using the key solution_r , analogously to solution_x and solution_y . Note, however, that the pickle file can be become very large in that case. This option is only meant for debugging a new coupling algorithm. It should not be used in combination with restart.","title":"Save results"},{"location":"coupled_solvers.html#restart","text":"The restart functionality is very useful to continue a calculation which has been stopped, either intentionally or unintentionally. The goal is to continue as if the code had never been interrupted. In order to restart from time step n n , the coupled solver saves the predictor and possibly one or more models in the state at the end of time step n n in a pickle file. By saving the predictor, the initial guess at the start of the first time step(s) will be the same, as the predictor typically extrapolates the solution from the previous time step(s) in some way. The model(s) are saved such that the behavior of the coupling algorithm is the same. This is only important if the model behavior depends on data from previous time steps, e.g. models with reuse (q>0). The following table gives an overview of the coupled solvers which save one or more additional components or values. type additional components saved for restart coupled_solvers.aitken omega coupled_solvers.iqni model coupled_solvers.ibqn model_f and model_s However, not only the predictor and coupling algorithm depend on previous time steps; this is typically also the case for the solvers. Therefore, it is the responsibility of the solver wrappers, to setup the solvers correctly for restart: they need to ensure that the variables in the whole computational domain are set to the value of time step n n . Moreover, its vital that they reconstruct the exact same model parts as in the initial calculation. In other words, the undeformed coordinates must be the same. Conversely, they are not required to initialize the interfaces with the correct data from time step n n , as this taken care of by the predictor in the coupled solver. Only when both solver wrappers allow restart, is is possible to restart a calculation!","title":"Restart"},{"location":"coupled_solvers.html#saving-restart-files","text":"During a calculation it is possible to save restart pickle files. As described above the pickle file for restart has a name ( <name>_restart_ts<time_step>.pickle ), based on the setting case_name . The frequency of saving a restart pickle file is determined by the save_restart interval as described above. Remark that it is only useful to save the restart pickle file, when the solver data are saved as well. Therefore, the save_restart parameter is transferred automatically to the solver wrappers. If save_results is non-zero, a save of restart information also triggers the saving of the results pickle file , to avoid discontinuity of this file.","title":"Saving restart files"},{"location":"coupled_solvers.html#performing-restart","text":"To restart a case, timestep_start has to be a positive integer above zero. The first time step that will be calculated is timestep_start plus one. The methodology described above does not allow to change any settings of the predictor or model(s), nor the type of coupled solver. Upon restart, this condition is checked, as well as the presence of the pickle file for restart. This file is identified by the setting restart_case as <restart_case>_restart_ts<timestep_start>.pickle . Additionally, it is checked that the new model parts are exactly the same as the previous ones. It is important to realize that the pickle file only makes sure that the initial guess and coupling algorithm work as before. The physical effect of previous time steps dealt with by the solver wrappers. Therefore, in order to be able to perform a restart, the solver files for the corresponding time step also need to be present! When performing restart, the new data will be neatly appended to the already existing results pickle file, leaving out existing time step data after the new time step start. As a result, the results pickle file looks exactly as if the calculation was never stopped, with the exception of the fields run_time and info . The latter provides a very shot log of when restart is performed. If the results pickle file would not be found for any reason, the user is informed and a new one is made, with the correct timestep_start . Note that the presence of the restart pickle file on the other hand is required. If the case_name is changed, the restart can still be performed by providing the case name for restart using restart_case (see explanation above).","title":"Performing restart"},{"location":"coupled_solvers.html#references","text":"[1] Delaiss\u00e9 N., Demeester T., Fauconnier D. and Degroote J., \"Comparison of different quasi-Newton techniques for coupling of black box solvers\", in ECCOMAS 2020, Proceedings, Paris, France, 2021.","title":"References"},{"location":"coupling_components.html","text":"Coupling components The coupling components are the basic building blocks of the CoCoNuT coupling tool. They are defined in the subdirectories of the coconut/coupling_components directory. There are five types: Convergence criteria which determine when the calculation has converged within a time step. Subdirectory: convergence_criteria . Coupled solvers (completed by Models , subdirectory coupled_solvers/models ) which perform the actual coupling, implementing a coupling algorithm. Subdirectory: coupled_solvers . Mappers which map from one interface discretization to another, i.e. interpolation between non-conformal meshes. Subdirectory: mappers . Predictors which provide an initial guess at the start of a new time step. Subdirectory: predictors . Solver wrappers which provide communication which the actual solvers. Subdirectory: solver_wrappers . The idea behind these components is modularity. For example, changing a solver wrapper or creating a new one can be done without having to adapt any other components. This allows for high degree of flexibility, a short learning curve and a limited development effort. Moreover, components can be used multiple times without the need for copying code. Detailed information on these components can be found in the specific documentation. All these coupling components inherit from a same superclass called Component , defined in coconut/coupling_components/component.py . In this class some methods are implemented, which control the flow within CoCoNuT. For every coupling component, there are initialize and finalize , which are called at the start and end of a calculation and there are initialize_solution_step and finalize_solution_step , which are called at the start and end of each time step. If needed these methods are overwritten to perform a specific action. For example in the finalize method of a solver_wrapper , the termination of the solver software could be implemented. A schematic of the relation between the coupling components for a basic calculation is given in the following figure. These coupling components have to communicate with each other. This is done through the use of interfaces , indicated with arrows on the figure. For these Interface objects (implemented in coconut/data_structure/interfaces.py ) containing the (discretized) solution data on the FSI-interface and references to, among others, the coordinates of the discretized interface. The implementation of this Interface class is explained in more detail in the documentation about the data structure . Start of the calculation The main coupling component in which all other coupling components are instantiated is the coupled solver. The coupled solver itself is created in the Analysis class ( coconut/analysis.py , which is the starting point of the CoCoNuT calculation. Upon the start of CoCoNuT, an instance of Analysis is made and its method run is executed. The coupled solver keeps track of all Components and runs the methods initialize , finalize , initialize_solution_step and finalize_solution_step , when its respective methods are executed. Tools Some code to perform specific tasks, like printing with a certain layout or performing a time measurement is useful throughout the code. These functionalities are grouped in the file coconut/tools.py . It suffices to import the file to make uses of its functions.","title":"General"},{"location":"coupling_components.html#coupling-components","text":"The coupling components are the basic building blocks of the CoCoNuT coupling tool. They are defined in the subdirectories of the coconut/coupling_components directory. There are five types: Convergence criteria which determine when the calculation has converged within a time step. Subdirectory: convergence_criteria . Coupled solvers (completed by Models , subdirectory coupled_solvers/models ) which perform the actual coupling, implementing a coupling algorithm. Subdirectory: coupled_solvers . Mappers which map from one interface discretization to another, i.e. interpolation between non-conformal meshes. Subdirectory: mappers . Predictors which provide an initial guess at the start of a new time step. Subdirectory: predictors . Solver wrappers which provide communication which the actual solvers. Subdirectory: solver_wrappers . The idea behind these components is modularity. For example, changing a solver wrapper or creating a new one can be done without having to adapt any other components. This allows for high degree of flexibility, a short learning curve and a limited development effort. Moreover, components can be used multiple times without the need for copying code. Detailed information on these components can be found in the specific documentation. All these coupling components inherit from a same superclass called Component , defined in coconut/coupling_components/component.py . In this class some methods are implemented, which control the flow within CoCoNuT. For every coupling component, there are initialize and finalize , which are called at the start and end of a calculation and there are initialize_solution_step and finalize_solution_step , which are called at the start and end of each time step. If needed these methods are overwritten to perform a specific action. For example in the finalize method of a solver_wrapper , the termination of the solver software could be implemented. A schematic of the relation between the coupling components for a basic calculation is given in the following figure. These coupling components have to communicate with each other. This is done through the use of interfaces , indicated with arrows on the figure. For these Interface objects (implemented in coconut/data_structure/interfaces.py ) containing the (discretized) solution data on the FSI-interface and references to, among others, the coordinates of the discretized interface. The implementation of this Interface class is explained in more detail in the documentation about the data structure .","title":"Coupling components"},{"location":"coupling_components.html#start-of-the-calculation","text":"The main coupling component in which all other coupling components are instantiated is the coupled solver. The coupled solver itself is created in the Analysis class ( coconut/analysis.py , which is the starting point of the CoCoNuT calculation. Upon the start of CoCoNuT, an instance of Analysis is made and its method run is executed. The coupled solver keeps track of all Components and runs the methods initialize , finalize , initialize_solution_step and finalize_solution_step , when its respective methods are executed.","title":"Start of the calculation"},{"location":"coupling_components.html#tools","text":"Some code to perform specific tasks, like printing with a certain layout or performing a time measurement is useful throughout the code. These functionalities are grouped in the file coconut/tools.py . It suffices to import the file to make uses of its functions.","title":"Tools"},{"location":"data_structure.html","text":"Data structure The data structure in CoCoNuT contains different classes that serve as containers of various types of data that are transferred between the components of CoCoNuT during the partitioned coupling. It consists of the following three classes: Model ModelPart Interface Model Model is simply a dict with keys as model part names and values as the reference to model parts. It serves as a container of instances of ModelParts . Additionally, it has one important method called create_model_part , which as the name suggests, creates an instance of the class ModelPart and adds it to the dictionary. ModelPart ModelPart is a container of boundary points, that are involved in the partitioned coupling. This contains the initial coordinates- x0 , y0 , z0 ( 1D numpy float array ), and point ids- id ( 1D numpy int array ). It is recommended to always instantiate ModelPart using the create_model_part method of the class Model , discussed above. Naturally, the size of x0 , y0 , z0 , and id should be equal, which is checked in the __init__ method. NOTE : The data in ModelPart once created, either by __init__ method of the ModelPart class or by create_model_part method of the Model class, cannot be changed later. This is because the initial coordinates of boundary points are always supplied from the solver wrapper and they don't change during the various stages of the coupling process. Interface Interface stores the variable data that are transferred between the different components ( coupling_components ) of CoCoNuT to perform partitioned coupling. Additionally, it contains a reference to an instance of Model , usually created in the solver wrapper. As described above, the Model contains several model parts corresponding to the boundaries in the solver wrappers. Therefore, in a way, the interface also contains coordinates of the boundary points that are involved in the coupling. The data in the interfaces are stored as numpy arrays in a nested dict . The following schematic illustrates the data structure in the Interface class, where the arrow points from a key to the value in the dict : For example, in the schematic above, the interface has a model part named \"mp_1_name\", which has several variable data. The data for the variable var_1 is stored in a numpy array with the number of rows equal to the number points in the model part and the number of columns equal to the number of components/dimensions of the variable. The number of dimensions for a variable is defined in the variable_dimensions dict in the file data_structure/variables.py variables.py, e.g the number of dimensions for the variables pressure and displacement is 1 and 3, respectively. The nested dict in the Interface is constructed during the instantiation of the class using a parameters dict given as an input argument. For the schematic shown above, the parameters dict would be: [ { \"model_part\": \"mp_1_name\", \"variables\": [\"var_1\", var_2, ..] ] }, { \"model_part\": \"mp_2_name\", \"variables\": [\"var_3\", ..] ] }, . . . ] The data in the interface can be accessed, added, or replaced by the various methods implemented in the Interface class, which can be looked in the file data_structure/interface.py . NOTE : The file data_structure/variables.py does not contain a class definition. It has a dict called variable_dimensions with keys as data variable names ( string ) and values as the number of components or dimensions ( int ). One important point to note is that only variables defined in this dictionary can be used in CoCoNuT. To use a new variable, the user first needs to add the variable name and its number of components in this dict .","title":"Data structure"},{"location":"data_structure.html#data-structure","text":"The data structure in CoCoNuT contains different classes that serve as containers of various types of data that are transferred between the components of CoCoNuT during the partitioned coupling. It consists of the following three classes: Model ModelPart Interface","title":"Data structure"},{"location":"data_structure.html#model","text":"Model is simply a dict with keys as model part names and values as the reference to model parts. It serves as a container of instances of ModelParts . Additionally, it has one important method called create_model_part , which as the name suggests, creates an instance of the class ModelPart and adds it to the dictionary.","title":"Model"},{"location":"data_structure.html#modelpart","text":"ModelPart is a container of boundary points, that are involved in the partitioned coupling. This contains the initial coordinates- x0 , y0 , z0 ( 1D numpy float array ), and point ids- id ( 1D numpy int array ). It is recommended to always instantiate ModelPart using the create_model_part method of the class Model , discussed above. Naturally, the size of x0 , y0 , z0 , and id should be equal, which is checked in the __init__ method. NOTE : The data in ModelPart once created, either by __init__ method of the ModelPart class or by create_model_part method of the Model class, cannot be changed later. This is because the initial coordinates of boundary points are always supplied from the solver wrapper and they don't change during the various stages of the coupling process.","title":"ModelPart"},{"location":"data_structure.html#interface","text":"Interface stores the variable data that are transferred between the different components ( coupling_components ) of CoCoNuT to perform partitioned coupling. Additionally, it contains a reference to an instance of Model , usually created in the solver wrapper. As described above, the Model contains several model parts corresponding to the boundaries in the solver wrappers. Therefore, in a way, the interface also contains coordinates of the boundary points that are involved in the coupling. The data in the interfaces are stored as numpy arrays in a nested dict . The following schematic illustrates the data structure in the Interface class, where the arrow points from a key to the value in the dict : For example, in the schematic above, the interface has a model part named \"mp_1_name\", which has several variable data. The data for the variable var_1 is stored in a numpy array with the number of rows equal to the number points in the model part and the number of columns equal to the number of components/dimensions of the variable. The number of dimensions for a variable is defined in the variable_dimensions dict in the file data_structure/variables.py variables.py, e.g the number of dimensions for the variables pressure and displacement is 1 and 3, respectively. The nested dict in the Interface is constructed during the instantiation of the class using a parameters dict given as an input argument. For the schematic shown above, the parameters dict would be: [ { \"model_part\": \"mp_1_name\", \"variables\": [\"var_1\", var_2, ..] ] }, { \"model_part\": \"mp_2_name\", \"variables\": [\"var_3\", ..] ] }, . . . ] The data in the interface can be accessed, added, or replaced by the various methods implemented in the Interface class, which can be looked in the file data_structure/interface.py . NOTE : The file data_structure/variables.py does not contain a class definition. It has a dict called variable_dimensions with keys as data variable names ( string ) and values as the number of components or dimensions ( int ). One important point to note is that only variables defined in this dictionary can be used in CoCoNuT. To use a new variable, the user first needs to add the variable name and its number of components in this dict .","title":"Interface"},{"location":"docs.html","text":"Documentation This website is a collection of all MarkDown (MD) files found in the coconut package. These files are converted to a static website using MkDocs , based on the outline defined in the mkdocs.yml file. Documentation in MarkDown MD files are easy to write and read in raw form, and can easily be converted to HTML for nicer rendering. It is easy to learn, see e.g. this MarkDown tutorial . Several flavors of MD exist, which differ only in some details. GitHub has its own GitHub Flavored Markdown (GFM) , which is used to render MD documents found in repositories on the run. PyCharm comes with an automatic rendering tool built in, and I assume many other IDE's too. The MD documents for the CoCoNuT documentation must be written in the Python-Markdown flavor, because they are processed by MkDocs . This flavor stays very close to the reference implementation of MD. Pay attention to lists: they should be indented with 4 spaces (contrary to GFM). An important rule for writing MD files for this documentation website is that the name of the file must be unique: use names like fluent.md or examples.md , not readme.md . Links to other MarkDown files It is possible to use relative links to other MarkDown files in CoCoNuT, using the syntax [ link description ]( relative_path ) where relative_path is the relative path to another MarkDown file, e.g. ../coupling_components/mappers/mappers.md . These links can be used in rendered MarkDown, e.g. in PyCharm, but also on GitHub itself (see this blogpost ). These links also work on the documentation website, as they are automatically replaced by the correct URL. Take for example a look at the documentation of the mappers or the examples . In addition, it is also possible to link to (sub)sections of a file. It is less straightforward to find the correct address in this case, but PyCharm gives you suggestions if you type a # behind the filename. Some examples: this paragraph , a CoCoNuT tutorial , setting up a Fluent case , radial basis mappers . This feature has some limitations: it is not possible to link to a section name that appears several times in a file (non-unique name), or to a section name that is a link itself. Math LaTeX notation can be used for writing mathematical expressions. Inline equations must be enclosed in single dollar signs (e.g. E = m c^2 E = m c^2 ), block-style equations in double dolar signs, e.g. e^{i \\pi} + 1 = 0. e^{i \\pi} + 1 = 0. LaTeX expressions will not be rendered on GitHub, but only on the documentation website. For the latter, the MD extension Arithmatex is used to render the expressions with MathJax. Note that MathJax syntax is a little more restrictive than a real LaTeX installation. Images External images can be included with their URL. Adding locally stored images is a bit more complicated: these images must be stored in a directory images next to the MD file. If another location is used, they will not be shown on the website, only on GitHub. Furthermore, images must have a unique name. A warning is shown when this is not the case. An image can be added with the MD command ![ alt ]( images/example.png \"description\" ) with alt displayed when the image cannot be shown/viewed for some reason, and description appearing when hovering over the image with your mouse. For example: Only image formats specified in run_mkdocs.py (i.e. png, jpg, jpeg, gif, svg) are copied to the website; missing extensions can be added. Images from all coconut subdirectories called images are copied to the website, so care must be taken that images is not used in e.g. the output of the test examples. Style & layout guide This section gives some guidelines about style and layout of MarkDown files, to keep the documentation consistent. Use code style for: class and method names (and plurals): Model , ModelParts , __init__ , finalize JSON keys and values: coupled_solver , delta_t Use code style + italics for: files: run_simulation.py , parameters.json folders: data_structure paths: coupling_components/solver_wrappers/mapped.py Use normal text for: referring to abstract terms and concepts in CoCoNuT (i.e. not a specific class): solver wrappers, mappers, coupled solver, data structure Titles of MD files (e.g. # Mappers , the first line of the MarkDown file): should be brief and not repeat information that can be deducted from the structure of the documentation, e.g. for the Fluent solver wrapper: just use # Fluent and not # Fluent solver wrapper , as it is beneath Solver wrappers on the website. don't use class names (and hence no camelcase ), e.g. not # SolverWrapperOpenFOAM If you refer to other MarkDown pages in the documentation, it can be useful to use a relative link . Recommendation for links: it is nice that the link text gives you some information about where the link goes, for example: good example: coconut documentation bad example: this link Creating a static website with MkDocs MkDocs can be installed using pip: pip install mkdocs-material Apart from MkDocs, this also automatically installs the Material theme and the PyMdown MD extensions (including Arithmatex). To install locally, add a relative or absolute path with the -t argument: pip install mkdocs-material -t /some/absolute/path In this case, two lines must be added to your .bashrc file: export PYTHONPATH = /some/absolute/path: $PYTHONPATH export PATH = /some/absolute/path/bin: $PATH The structure/outline of the website is dictated by the nav variable in mkdocs.yml . This is the only variable that must be adjusted when new MD files are added to the code. The complete process to create the documentation website is automated by run_mkdocs.py . This does the following things: Copy all MD files in coconut and its subfolders to folder docs . Check if there are duplicate filenames: these overwrite each other! If duplicates are found, a warning is given with the original paths. Check if each MD file is mentioned in mkdocs.yml . If a file is not mentioned, a warning is given. Build static HTML website using mkdocs build . You can run run_mkdocs.py with an extra command line argument: python run_mkdocs.py --preview example opens a preview of the website in Firefox, showing the webpage corresponding to the file example.md . This can be used to check MD and LaTeX syntax. python run_mkdocs.py --deploy deploys the website on GitHub Pages using mkdocs gh-deploy . It seems this is currently only possible if the remote is configured with SSH, not with HTTPS.","title":"Documentation"},{"location":"docs.html#documentation","text":"This website is a collection of all MarkDown (MD) files found in the coconut package. These files are converted to a static website using MkDocs , based on the outline defined in the mkdocs.yml file.","title":"Documentation"},{"location":"docs.html#documentation-in-markdown","text":"MD files are easy to write and read in raw form, and can easily be converted to HTML for nicer rendering. It is easy to learn, see e.g. this MarkDown tutorial . Several flavors of MD exist, which differ only in some details. GitHub has its own GitHub Flavored Markdown (GFM) , which is used to render MD documents found in repositories on the run. PyCharm comes with an automatic rendering tool built in, and I assume many other IDE's too. The MD documents for the CoCoNuT documentation must be written in the Python-Markdown flavor, because they are processed by MkDocs . This flavor stays very close to the reference implementation of MD. Pay attention to lists: they should be indented with 4 spaces (contrary to GFM). An important rule for writing MD files for this documentation website is that the name of the file must be unique: use names like fluent.md or examples.md , not readme.md .","title":"Documentation in MarkDown"},{"location":"docs.html#links-to-other-markdown-files","text":"It is possible to use relative links to other MarkDown files in CoCoNuT, using the syntax [ link description ]( relative_path ) where relative_path is the relative path to another MarkDown file, e.g. ../coupling_components/mappers/mappers.md . These links can be used in rendered MarkDown, e.g. in PyCharm, but also on GitHub itself (see this blogpost ). These links also work on the documentation website, as they are automatically replaced by the correct URL. Take for example a look at the documentation of the mappers or the examples . In addition, it is also possible to link to (sub)sections of a file. It is less straightforward to find the correct address in this case, but PyCharm gives you suggestions if you type a # behind the filename. Some examples: this paragraph , a CoCoNuT tutorial , setting up a Fluent case , radial basis mappers . This feature has some limitations: it is not possible to link to a section name that appears several times in a file (non-unique name), or to a section name that is a link itself.","title":"Links to other MarkDown files"},{"location":"docs.html#math","text":"LaTeX notation can be used for writing mathematical expressions. Inline equations must be enclosed in single dollar signs (e.g. E = m c^2 E = m c^2 ), block-style equations in double dolar signs, e.g. e^{i \\pi} + 1 = 0. e^{i \\pi} + 1 = 0. LaTeX expressions will not be rendered on GitHub, but only on the documentation website. For the latter, the MD extension Arithmatex is used to render the expressions with MathJax. Note that MathJax syntax is a little more restrictive than a real LaTeX installation.","title":"Math"},{"location":"docs.html#images","text":"External images can be included with their URL. Adding locally stored images is a bit more complicated: these images must be stored in a directory images next to the MD file. If another location is used, they will not be shown on the website, only on GitHub. Furthermore, images must have a unique name. A warning is shown when this is not the case. An image can be added with the MD command ![ alt ]( images/example.png \"description\" ) with alt displayed when the image cannot be shown/viewed for some reason, and description appearing when hovering over the image with your mouse. For example: Only image formats specified in run_mkdocs.py (i.e. png, jpg, jpeg, gif, svg) are copied to the website; missing extensions can be added. Images from all coconut subdirectories called images are copied to the website, so care must be taken that images is not used in e.g. the output of the test examples.","title":"Images"},{"location":"docs.html#style-layout-guide","text":"This section gives some guidelines about style and layout of MarkDown files, to keep the documentation consistent. Use code style for: class and method names (and plurals): Model , ModelParts , __init__ , finalize JSON keys and values: coupled_solver , delta_t Use code style + italics for: files: run_simulation.py , parameters.json folders: data_structure paths: coupling_components/solver_wrappers/mapped.py Use normal text for: referring to abstract terms and concepts in CoCoNuT (i.e. not a specific class): solver wrappers, mappers, coupled solver, data structure Titles of MD files (e.g. # Mappers , the first line of the MarkDown file): should be brief and not repeat information that can be deducted from the structure of the documentation, e.g. for the Fluent solver wrapper: just use # Fluent and not # Fluent solver wrapper , as it is beneath Solver wrappers on the website. don't use class names (and hence no camelcase ), e.g. not # SolverWrapperOpenFOAM If you refer to other MarkDown pages in the documentation, it can be useful to use a relative link . Recommendation for links: it is nice that the link text gives you some information about where the link goes, for example: good example: coconut documentation bad example: this link","title":"Style &amp; layout guide"},{"location":"docs.html#creating-a-static-website-with-mkdocs","text":"MkDocs can be installed using pip: pip install mkdocs-material Apart from MkDocs, this also automatically installs the Material theme and the PyMdown MD extensions (including Arithmatex). To install locally, add a relative or absolute path with the -t argument: pip install mkdocs-material -t /some/absolute/path In this case, two lines must be added to your .bashrc file: export PYTHONPATH = /some/absolute/path: $PYTHONPATH export PATH = /some/absolute/path/bin: $PATH The structure/outline of the website is dictated by the nav variable in mkdocs.yml . This is the only variable that must be adjusted when new MD files are added to the code. The complete process to create the documentation website is automated by run_mkdocs.py . This does the following things: Copy all MD files in coconut and its subfolders to folder docs . Check if there are duplicate filenames: these overwrite each other! If duplicates are found, a warning is given with the original paths. Check if each MD file is mentioned in mkdocs.yml . If a file is not mentioned, a warning is given. Build static HTML website using mkdocs build . You can run run_mkdocs.py with an extra command line argument: python run_mkdocs.py --preview example opens a preview of the website in Firefox, showing the webpage corresponding to the file example.md . This can be used to check MD and LaTeX syntax. python run_mkdocs.py --deploy deploys the website on GitHub Pages using mkdocs gh-deploy . It seems this is currently only possible if the remote is configured with SSH, not with HTTPS.","title":"Creating a static website with MkDocs"},{"location":"examples.html","text":"Examples This documentation describes the different example cases. Currently all these examples calculate the flow in a flexible tube. Folder and file structure This section describes the different folders and files that are provided. The examples folder contains following subfolders: debug_files : Python scripts that are useful for debugging of the cases. These files might need some adjustments to work. In order to use them, the debug boolean self.debug has to be set to True in the settings of the corresponding solver wrappers. post_processing : contains scripts to visualize your results. In particular, the animate_example.py script provides the means to animate the variables stored in the interface (pressure, traction, displacement), given that your results are stored in a pickle file, see the documentation on save results . setup_files : contains the necessary files to set up the case for each solver and the run_simulation.py script necessary to start the actual simulation. test_single_solver : example to check the correct set up of your solver specific cases. tube_<flow solver>_<structural solver> : main directory of the example cases. The main directory of each example case contains following files: parameters.json : parameter file in JSON format. setup.py : python script, which needs to be run to set up the case. tube_<flow solver>_<structural solver>.md : description of the specific example. When the setup file is run, working directories are created that have to match the ones specified in the parameter file. These folders are expandable and are deleted when the setup files are (re)run. The script copies first the run_simulation.py file into the main directory and then the necessary case files from setup_files into the correct working directory. After the completion of this script, the example case is ready to run. Project Parameters The parameter file parameters.json can be interpreted as a dictionary. There are two main keys. The first is settings in which the number of time steps for which the calculation is run is specified. The second is coupled_solver in which all parameters related to solver algorithm are given: coupling algorithm, predictor, convergence criteria and solvers. Running a case In order to run an example case, first, the setup script has to be run to create the working directories. Then, the calculation is started by running run_simulation.py . Make sure to add the module-load commands for the required solvers in solverload_cmd_dict in the coconut/solver_modules.py file, to load the necessary modules for your solvers during the simulation. By default, the solvers for the UGent-cluster are added to the file. In practice, you would run the following commands: python setup.py python run_simulation.py Setting up your own case To set up your own case, following items should be present in the main directory: A JSON file containing the parameters of your simulation. In the example cases, it is called parameters.json . In case you wish another name, make sure to adapt the variable parameter_file_name in the run_simulation.py script. The run_simulation.py script which initiates the CoCoNuT simulation when run. Working directories for the flow and structural solvers. In the examples they are named CFD and CSM , respectively. In practice, they can bear any name as long as you make sure they are referenced correctly in the parameter file under the keyword working_directory . These working directories should contain the case files for the flow and structural calculations.","title":"General"},{"location":"examples.html#examples","text":"This documentation describes the different example cases. Currently all these examples calculate the flow in a flexible tube.","title":"Examples"},{"location":"examples.html#folder-and-file-structure","text":"This section describes the different folders and files that are provided. The examples folder contains following subfolders: debug_files : Python scripts that are useful for debugging of the cases. These files might need some adjustments to work. In order to use them, the debug boolean self.debug has to be set to True in the settings of the corresponding solver wrappers. post_processing : contains scripts to visualize your results. In particular, the animate_example.py script provides the means to animate the variables stored in the interface (pressure, traction, displacement), given that your results are stored in a pickle file, see the documentation on save results . setup_files : contains the necessary files to set up the case for each solver and the run_simulation.py script necessary to start the actual simulation. test_single_solver : example to check the correct set up of your solver specific cases. tube_<flow solver>_<structural solver> : main directory of the example cases. The main directory of each example case contains following files: parameters.json : parameter file in JSON format. setup.py : python script, which needs to be run to set up the case. tube_<flow solver>_<structural solver>.md : description of the specific example. When the setup file is run, working directories are created that have to match the ones specified in the parameter file. These folders are expandable and are deleted when the setup files are (re)run. The script copies first the run_simulation.py file into the main directory and then the necessary case files from setup_files into the correct working directory. After the completion of this script, the example case is ready to run.","title":"Folder and file structure"},{"location":"examples.html#project-parameters","text":"The parameter file parameters.json can be interpreted as a dictionary. There are two main keys. The first is settings in which the number of time steps for which the calculation is run is specified. The second is coupled_solver in which all parameters related to solver algorithm are given: coupling algorithm, predictor, convergence criteria and solvers.","title":"Project Parameters"},{"location":"examples.html#running-a-case","text":"In order to run an example case, first, the setup script has to be run to create the working directories. Then, the calculation is started by running run_simulation.py . Make sure to add the module-load commands for the required solvers in solverload_cmd_dict in the coconut/solver_modules.py file, to load the necessary modules for your solvers during the simulation. By default, the solvers for the UGent-cluster are added to the file. In practice, you would run the following commands: python setup.py python run_simulation.py","title":"Running a case"},{"location":"examples.html#setting-up-your-own-case","text":"To set up your own case, following items should be present in the main directory: A JSON file containing the parameters of your simulation. In the example cases, it is called parameters.json . In case you wish another name, make sure to adapt the variable parameter_file_name in the run_simulation.py script. The run_simulation.py script which initiates the CoCoNuT simulation when run. Working directories for the flow and structural solvers. In the examples they are named CFD and CSM , respectively. In practice, they can bear any name as long as you make sure they are referenced correctly in the parameter file under the keyword working_directory . These working directories should contain the case files for the flow and structural calculations.","title":"Setting up your own case"},{"location":"fluent.html","text":"Fluent This is the documentation for all Fluent solver wrappers. The focus of this page is on fluid-structure interaction (FSI). Currently no other multiphysics problems are supported, but these are envisioned in future developments. FSI with inviscid flows is not supported, but that would be straightforward to add if required. Fluid-structure interaction with Fluent ANSYS Fluent can be used to solve the flow field in partitioned FSI simulations. The FSI interface consists of one or several surface threads in Fluent. During each FSI iteration, the solver wrapper imposes a certain displacement on this FSI interface. Fluent then automatically deforms the rest of the mesh (using dynamic mesh capabilities), solves the flow field and returns the calculated loads on the FSI interface to the solver wrapper. Displacements are applied in Fluent in nodes . As displacements are the input of Fluent, these nodes are collected in one or more ModelParts in the input Interface . Loads (pressure and traction) can be obtained from the Fluent faces . As loads are the output of Fluent, these faces are collected in one or more ModelParts in the output Interface . A fixed naming convention is used for the Fluent ModelParts in CoCoNuT: each ModelPart gets the name of the corresponding Fluent surface thread, plus \"_nodes\" or \"_faces\", depending on their content. As a consequence, each ModelPart in the input Interface has a counterpart in the output Interface . More information about ModelParts and Interfaces can be found in the data structure documentation . Parameters This section describes the parameters in the JSON file, listed in alphabetical order. parameter type description case_file string Name of the case file. It must be present in the folder specified by working_directory . The corresponding data file must also be present but has no key in the JSON file. cores int Number of processor cores to use when running Fluent (tested only on single node so far). dimensions int Dimension used in flow solver: 2 for 2D and axisymmetric, 3 for 3D. delta_t float Fixed time step size in flow solver. This parameter is usually specified in a higher Component . end_of_timestep_commands string Fluent journal command(s) to be executed after every time step, to store drag and lift forces for example. flow_iterations int Number of non-linear iterations in Fluent per coupling iteration. fluent_gui bool Set to true to run Fluent with the graphical interface. interface_input list List of dictionaries to describe the input Interface (Fluent nodes). Each dictionary defines one ModelPart with two keys: model_part contains the name of the ModelPart and variables contains a list of variable names. Each ModelPart name must be the concatenation of an entry from thread_names and \"_nodes\". The variable names must be chosen from data_structure/variables.py . interface_output dict Analogous to interface_input , but for the output Interface (Fluent faces). Each ModelPart name must be the concatenation of an entry from the file thread_names and \"_faces\". max_nodes_per_face int This value is used to construct unique IDs for faces, based on unique IDs of nodes (provided by Fluent). It should be at least as high as the maximum number of nodes on a face on the interface. Use e.g. 4 for rectangular faces, 3 for triangular faces and 2 in 2D simulations (edges). multiphase bool (optional) Default false . true for multiphase Fluent case, false for singlephase. save_iterations int Number of time steps between consecutive saves of the Fluent case and data files. thread_names list List with Fluent names of the surface threads on the FSI interface. timestep_start int Time step number to (re)start a transient FSI calculation. If 0 is given, the simulation starts from the case_file , else the code looks for the relevant case and data files. This parameter is usually specified in a higher Component . unsteady bool true for transient FSI, false for steady FSI. working_directory string Absolute path to the working directory or relative path w.r.t the current directory. timestep_start and delta_t are necessary parameters, but are usually defined already in the parameters of the coupled solver. However, they can also be given directly as parameter of the solver wrapper (e.g. for standalone testing). If they are defined both in the coupled solver and in the solver wrapper, then the former value is used and a warning is printed. If different parameters are used with different Fluent versions, this should be specified both in this section and in the version specific documentation section. Overview of operation The solver wrapper consists of 3 files (with X the Fluent version, e.g. \"v2019R1\"): X.py : defines the SolverWrapperFluentX class, X.jou : Fluent journal file to interactively run the FSI simulation, written in Scheme, X.c : Fluent UDF file that implements additional functionality used in Fluent, written in C. The initialize method During initialization, the journal and UDF files are adapted (parameter values are filled in) and copied to the working_directory . Fluent is then started in that directory using the parameters cores , dimensions and fluent_gui . Fluent then writes a case summary, so that the solver wrapper can link the interface thread names (specified in thread_names ) to Fluent thread IDs, for use in the UDFs. Then the Model and ModelParts are created, based on data written by Fluent in time step 0. After a restart, this same data must be found, i.e. if those data files are removed from the working_directory folder, the simulation cannot be restarted. Finally, the Interfaces are created. Files created during simulation In these file conventions, A is the time step number and B the Fluent thread ID. Fluent case and data files are saved as files of the form case_timestepA.cas and case_timestepA.dat . Current node and face coordinates are passed from Fluent to CoCoNuT with files of the form nodes_timestepA_threadB.dat and faces_timestepA_threadB.dat . The new node coordinates are passed from CoCoNuT to Fluent with files of the form nodes_update_timestepA_threadB.dat . Pressure and tractions are passed from Fluent to CoCoNuT with files of the form pressure_traction_timestepA_threadB.dat . Files with extension .coco are used to exchange messages between CoCoNuT and Fluent. Setting up a new case Following items should be set up and saved in the Fluent case file (this list may be non-exhaustive): additional UDFs must be configured, steady/unsteady (should match with the unsteady parameter), 2D, 3D or axisymmetric (should match with the dimensions parameter), dynamic mesh zones for all deforming surfaces, except for the FSI interfaces, dynamic mesh smoothing parameters, boundary conditions, material properties, numerical models, discretization schemes, operating conditions, turbulence modeling, convergence criteria. A data file should also be present with the fields either initialized or containing the results of a previous calculation. Following items are taken care of by CoCoNuT, and must therefore not be included in the Fluent case file: dynamic mesh zones for the FSI interfaces (these are defined in thread_names ), the time step ( delta_t ). Version specific documentation v2019R1 (19.3.0) First version. v2019R2 (19.4.0) No changes. v2019R3 (19.5.0) The solutions in this version are (slightly) different because the Rhie-Chow face flux interpolation in the pressure-based solver has changed. This setting can be reverted with the TUI command solve set previous undo-2019r3 y n , which is included in v2019R3.jou . The results can be slightly different when restarts are used for multi-core simulations for the following reason: For parallel cases with smoothing that do not use dynamic load balancing, a zonal partitioning with Laplace smoothing will automatically be applied when the file is read, which should result in better load balancing for the mesh smoothing calculations. After a restart, the partitioning can be different and hence the mesh deformation can be slightly different. v2020R1 (20.1.0) Same behavior as v2019R3.","title":"Fluent"},{"location":"fluent.html#fluent","text":"This is the documentation for all Fluent solver wrappers. The focus of this page is on fluid-structure interaction (FSI). Currently no other multiphysics problems are supported, but these are envisioned in future developments. FSI with inviscid flows is not supported, but that would be straightforward to add if required.","title":"Fluent"},{"location":"fluent.html#fluid-structure-interaction-with-fluent","text":"ANSYS Fluent can be used to solve the flow field in partitioned FSI simulations. The FSI interface consists of one or several surface threads in Fluent. During each FSI iteration, the solver wrapper imposes a certain displacement on this FSI interface. Fluent then automatically deforms the rest of the mesh (using dynamic mesh capabilities), solves the flow field and returns the calculated loads on the FSI interface to the solver wrapper. Displacements are applied in Fluent in nodes . As displacements are the input of Fluent, these nodes are collected in one or more ModelParts in the input Interface . Loads (pressure and traction) can be obtained from the Fluent faces . As loads are the output of Fluent, these faces are collected in one or more ModelParts in the output Interface . A fixed naming convention is used for the Fluent ModelParts in CoCoNuT: each ModelPart gets the name of the corresponding Fluent surface thread, plus \"_nodes\" or \"_faces\", depending on their content. As a consequence, each ModelPart in the input Interface has a counterpart in the output Interface . More information about ModelParts and Interfaces can be found in the data structure documentation .","title":"Fluid-structure interaction with Fluent"},{"location":"fluent.html#parameters","text":"This section describes the parameters in the JSON file, listed in alphabetical order. parameter type description case_file string Name of the case file. It must be present in the folder specified by working_directory . The corresponding data file must also be present but has no key in the JSON file. cores int Number of processor cores to use when running Fluent (tested only on single node so far). dimensions int Dimension used in flow solver: 2 for 2D and axisymmetric, 3 for 3D. delta_t float Fixed time step size in flow solver. This parameter is usually specified in a higher Component . end_of_timestep_commands string Fluent journal command(s) to be executed after every time step, to store drag and lift forces for example. flow_iterations int Number of non-linear iterations in Fluent per coupling iteration. fluent_gui bool Set to true to run Fluent with the graphical interface. interface_input list List of dictionaries to describe the input Interface (Fluent nodes). Each dictionary defines one ModelPart with two keys: model_part contains the name of the ModelPart and variables contains a list of variable names. Each ModelPart name must be the concatenation of an entry from thread_names and \"_nodes\". The variable names must be chosen from data_structure/variables.py . interface_output dict Analogous to interface_input , but for the output Interface (Fluent faces). Each ModelPart name must be the concatenation of an entry from the file thread_names and \"_faces\". max_nodes_per_face int This value is used to construct unique IDs for faces, based on unique IDs of nodes (provided by Fluent). It should be at least as high as the maximum number of nodes on a face on the interface. Use e.g. 4 for rectangular faces, 3 for triangular faces and 2 in 2D simulations (edges). multiphase bool (optional) Default false . true for multiphase Fluent case, false for singlephase. save_iterations int Number of time steps between consecutive saves of the Fluent case and data files. thread_names list List with Fluent names of the surface threads on the FSI interface. timestep_start int Time step number to (re)start a transient FSI calculation. If 0 is given, the simulation starts from the case_file , else the code looks for the relevant case and data files. This parameter is usually specified in a higher Component . unsteady bool true for transient FSI, false for steady FSI. working_directory string Absolute path to the working directory or relative path w.r.t the current directory. timestep_start and delta_t are necessary parameters, but are usually defined already in the parameters of the coupled solver. However, they can also be given directly as parameter of the solver wrapper (e.g. for standalone testing). If they are defined both in the coupled solver and in the solver wrapper, then the former value is used and a warning is printed. If different parameters are used with different Fluent versions, this should be specified both in this section and in the version specific documentation section.","title":"Parameters"},{"location":"fluent.html#overview-of-operation","text":"The solver wrapper consists of 3 files (with X the Fluent version, e.g. \"v2019R1\"): X.py : defines the SolverWrapperFluentX class, X.jou : Fluent journal file to interactively run the FSI simulation, written in Scheme, X.c : Fluent UDF file that implements additional functionality used in Fluent, written in C.","title":"Overview of operation"},{"location":"fluent.html#the-initialize-method","text":"During initialization, the journal and UDF files are adapted (parameter values are filled in) and copied to the working_directory . Fluent is then started in that directory using the parameters cores , dimensions and fluent_gui . Fluent then writes a case summary, so that the solver wrapper can link the interface thread names (specified in thread_names ) to Fluent thread IDs, for use in the UDFs. Then the Model and ModelParts are created, based on data written by Fluent in time step 0. After a restart, this same data must be found, i.e. if those data files are removed from the working_directory folder, the simulation cannot be restarted. Finally, the Interfaces are created.","title":"The initialize method"},{"location":"fluent.html#files-created-during-simulation","text":"In these file conventions, A is the time step number and B the Fluent thread ID. Fluent case and data files are saved as files of the form case_timestepA.cas and case_timestepA.dat . Current node and face coordinates are passed from Fluent to CoCoNuT with files of the form nodes_timestepA_threadB.dat and faces_timestepA_threadB.dat . The new node coordinates are passed from CoCoNuT to Fluent with files of the form nodes_update_timestepA_threadB.dat . Pressure and tractions are passed from Fluent to CoCoNuT with files of the form pressure_traction_timestepA_threadB.dat . Files with extension .coco are used to exchange messages between CoCoNuT and Fluent.","title":"Files created during simulation"},{"location":"fluent.html#setting-up-a-new-case","text":"Following items should be set up and saved in the Fluent case file (this list may be non-exhaustive): additional UDFs must be configured, steady/unsteady (should match with the unsteady parameter), 2D, 3D or axisymmetric (should match with the dimensions parameter), dynamic mesh zones for all deforming surfaces, except for the FSI interfaces, dynamic mesh smoothing parameters, boundary conditions, material properties, numerical models, discretization schemes, operating conditions, turbulence modeling, convergence criteria. A data file should also be present with the fields either initialized or containing the results of a previous calculation. Following items are taken care of by CoCoNuT, and must therefore not be included in the Fluent case file: dynamic mesh zones for the FSI interfaces (these are defined in thread_names ), the time step ( delta_t ).","title":"Setting up a new case"},{"location":"fluent.html#version-specific-documentation","text":"","title":"Version specific documentation"},{"location":"fluent.html#v2019r1-1930","text":"First version.","title":"v2019R1 (19.3.0)"},{"location":"fluent.html#v2019r2-1940","text":"No changes.","title":"v2019R2 (19.4.0)"},{"location":"fluent.html#v2019r3-1950","text":"The solutions in this version are (slightly) different because the Rhie-Chow face flux interpolation in the pressure-based solver has changed. This setting can be reverted with the TUI command solve set previous undo-2019r3 y n , which is included in v2019R3.jou . The results can be slightly different when restarts are used for multi-core simulations for the following reason: For parallel cases with smoothing that do not use dynamic load balancing, a zonal partitioning with Laplace smoothing will automatically be applied when the file is read, which should result in better load balancing for the mesh smoothing calculations. After a restart, the partitioning can be different and hence the mesh deformation can be slightly different.","title":"v2019R3 (19.5.0)"},{"location":"fluent.html#v2020r1-2010","text":"Same behavior as v2019R3.","title":"v2020R1 (20.1.0)"},{"location":"kratos.html","text":"Kratos KratosMultiphysics is an open source framework for finite element simulations. More information on Kratos and the source code can be found on the Kratos Github page . The StructuralMechanicsApplication in Kratos has been implemented in CoCoNuT and the basics of the solver wrapper and the setup of a case are explained below. Parameters This section describes the parameters in the JSON file, listed in alphabetical order. parameter type description cores int Number of processor cores to use when running Kratos (works with 1 core, multi-processing is work in progress). delta_t double (optional) Fixed time step size in structural solver. input_file string Project parameters file used by Kratos in JSON format. In the example cases , this is typically called ProjectParameters.json . interface_input dict List of dictionaries that describes the input Interface . This provides the interface boundary conditions for the Kratos solver. Each entry in the list has two keys: model_part and variables , with values as name of the model part and list of input variables, respectively. The input variables in the list should be chosen from the variables_dimensions dict in the file coconut/data_structure/variables.py . The model part name must be the concatenation of an entry from kratos_interface_sub_model_parts_list and the string _input . interface_output dict Analogous to interface_input , but here the name must be the concatenation of an entry from kratos_interface_sub_model_parts_list and the string _output . The entries in the list provides boundary conditions for the other solver(s) participating in the coupled simulation. kratos_interface_sub_model_parts_list string Names of sub-model parts used for input and output in Kratos. solver_load_cmd string Bash commands for loading required modules and environmental variables to run Kratos. timestep_start int (optional) Time step to (re)start a transient FSI calculation from. If 0 is given, the simulation starts from t = 0, else the code looks for the relevant case and data files. working_directory string Path to the working directory (i.e. where the input_file for Kratos is located), either absolute or relative w.r.t the current directory (i.e. from where the analysis is started). timestep_start and delta_t are usually defined already in the parameters of the coupled_solver . However, they can also be given directly as a parameter of the solver wrapper (e.g. for standalone testing). If they are defined both in the coupled solver and in the solver wrapper, then the former value is used and a warning is printed. If different parameters are used with different Kratos versions, this should be specified both in this section and in the version specific documentation section. Overview of operation The solver wrapper consists of 2 files, where X is the Kratos version without decimal, e.g. for version 6.0 this becomes 60 : vX.py : defines the SolverWrapperKratosStructureX class, run_kratos_structural_X.py : The Python file which runs Kratos in the background. This interacts with CoCoNuT for coupling. The __init__ method During initialization, the ProjectParameters.json file required for Kratos simulation is read and modified (parameter values are filled in) in the working_directory . One additional parameter called interface_sub_model_parts_list is added in the ProjectParameters.json that tells Kratos about the interface model parts used in the coupling. Kratos structural simulation is then started in that directory using the parameter cores (multi-processing not implemented yet). The solver wrapper waits for the Kratos simulation to output interface sub-model parts nodes, so that SolverWrapperKratosStructureX can create model parts in CoCoNuT for each entry in interface_input and interface_output . Finally, the interfaces are created. Files created during simulation The interface sub-model parts nodes are saved as <sub_model_part_name>_nodes.csv . The displacement from Kratos is written in a file named <sub_model_part_name>_displacement.csv . Pressure and tractions are passed from python to Kratos with files of the form <sub_model_part_name>_pressure.csv and <sub_model_part_name>_surface_load.csv , respectively. Files with extension .coco are used to pass messages between Python and Kratos. Setting up a new case Following items should be set up and saved in the working_directory (this list may be non-exhaustive): ProjectParameters.json with all the required parameters (see the example cases ), Mesh file with extension .mdpa , StructuralMaterials.json with the material properties. Following items are taken care of by CoCoNuT, and must therefore will be automatically changed at the begining of the simulation: the start time ( timestep_start ), the time step ( delta_t ), initialization of the solution field. Version specific documentation v60 (6.0) First version.","title":"Kratos"},{"location":"kratos.html#kratos","text":"KratosMultiphysics is an open source framework for finite element simulations. More information on Kratos and the source code can be found on the Kratos Github page . The StructuralMechanicsApplication in Kratos has been implemented in CoCoNuT and the basics of the solver wrapper and the setup of a case are explained below.","title":"Kratos"},{"location":"kratos.html#parameters","text":"This section describes the parameters in the JSON file, listed in alphabetical order. parameter type description cores int Number of processor cores to use when running Kratos (works with 1 core, multi-processing is work in progress). delta_t double (optional) Fixed time step size in structural solver. input_file string Project parameters file used by Kratos in JSON format. In the example cases , this is typically called ProjectParameters.json . interface_input dict List of dictionaries that describes the input Interface . This provides the interface boundary conditions for the Kratos solver. Each entry in the list has two keys: model_part and variables , with values as name of the model part and list of input variables, respectively. The input variables in the list should be chosen from the variables_dimensions dict in the file coconut/data_structure/variables.py . The model part name must be the concatenation of an entry from kratos_interface_sub_model_parts_list and the string _input . interface_output dict Analogous to interface_input , but here the name must be the concatenation of an entry from kratos_interface_sub_model_parts_list and the string _output . The entries in the list provides boundary conditions for the other solver(s) participating in the coupled simulation. kratos_interface_sub_model_parts_list string Names of sub-model parts used for input and output in Kratos. solver_load_cmd string Bash commands for loading required modules and environmental variables to run Kratos. timestep_start int (optional) Time step to (re)start a transient FSI calculation from. If 0 is given, the simulation starts from t = 0, else the code looks for the relevant case and data files. working_directory string Path to the working directory (i.e. where the input_file for Kratos is located), either absolute or relative w.r.t the current directory (i.e. from where the analysis is started). timestep_start and delta_t are usually defined already in the parameters of the coupled_solver . However, they can also be given directly as a parameter of the solver wrapper (e.g. for standalone testing). If they are defined both in the coupled solver and in the solver wrapper, then the former value is used and a warning is printed. If different parameters are used with different Kratos versions, this should be specified both in this section and in the version specific documentation section.","title":"Parameters"},{"location":"kratos.html#overview-of-operation","text":"The solver wrapper consists of 2 files, where X is the Kratos version without decimal, e.g. for version 6.0 this becomes 60 : vX.py : defines the SolverWrapperKratosStructureX class, run_kratos_structural_X.py : The Python file which runs Kratos in the background. This interacts with CoCoNuT for coupling.","title":"Overview of operation"},{"location":"kratos.html#the-__init__-method","text":"During initialization, the ProjectParameters.json file required for Kratos simulation is read and modified (parameter values are filled in) in the working_directory . One additional parameter called interface_sub_model_parts_list is added in the ProjectParameters.json that tells Kratos about the interface model parts used in the coupling. Kratos structural simulation is then started in that directory using the parameter cores (multi-processing not implemented yet). The solver wrapper waits for the Kratos simulation to output interface sub-model parts nodes, so that SolverWrapperKratosStructureX can create model parts in CoCoNuT for each entry in interface_input and interface_output . Finally, the interfaces are created.","title":"The __init__ method"},{"location":"kratos.html#files-created-during-simulation","text":"The interface sub-model parts nodes are saved as <sub_model_part_name>_nodes.csv . The displacement from Kratos is written in a file named <sub_model_part_name>_displacement.csv . Pressure and tractions are passed from python to Kratos with files of the form <sub_model_part_name>_pressure.csv and <sub_model_part_name>_surface_load.csv , respectively. Files with extension .coco are used to pass messages between Python and Kratos.","title":"Files created during simulation"},{"location":"kratos.html#setting-up-a-new-case","text":"Following items should be set up and saved in the working_directory (this list may be non-exhaustive): ProjectParameters.json with all the required parameters (see the example cases ), Mesh file with extension .mdpa , StructuralMaterials.json with the material properties. Following items are taken care of by CoCoNuT, and must therefore will be automatically changed at the begining of the simulation: the start time ( timestep_start ), the time step ( delta_t ), initialization of the solution field.","title":"Setting up a new case"},{"location":"kratos.html#version-specific-documentation","text":"","title":"Version specific documentation"},{"location":"kratos.html#v60-60","text":"First version.","title":"v60 (6.0)"},{"location":"mappers.html","text":"Mappers The coupling interfaces in different solvers are often discretized (meshed) differently, resulting in non-conforming ModelParts . For this reason, mapping is usually required, to transfer data from the output Interface of one solver to the input Interface of another. The terms from and to will be used to denote respectively the side that provides the original data and the side that receives the mapped data. General concepts Hierarchy of mapping-related objects CoCoNuT interacts with the mappers through an instance of the SolverWrapperMapped class. This special solver wrapper appears and behaves exactly the same as real solver wrappers. It contains 3 Components : a mapper for the input, a real solver wrapper and a mapper for the output. TODO: add links to Interfaces and ModelParts documentation sections when the terms are first mentioned here (that documentation doesn't exist yet...) The two mappers in the SolverWrapperMapped are of a special type: they work on the level of the Interfaces , while the actual mapping will be done on a lower level: the ModelPart level. The Interface mapper effectively acts as a wrapper around the actual ModelPart mappers. Currently only one mapper is available on the Interface level, aptly called MapperInterface . At the lowest level, mappers interpolate variable data (stored in Interfaces ) between two ModelParts , based on their coordinates. Interpolation is always done from the from ModelPart to the to - ModelPart . Multiple ModelPart mappers can be chained together in a MapperCombined object, to add additional functionality, for example swapping the coordinate axes with the permutation mapper . Interpolators and transformers The ModelPart -level mappers have two main methods: initialize and __call__ . The initialize method performs one-time expensive operations, such as a nearest-neighbour search and the calculation of interpolation coefficients. The __call__ method is used for the actual mapping. It takes two tuples as arguments ( from and to respectively). Each tuple contains an Interface object, the name of the affected ModelPart and the name of the variable that must be mapped. This method returns nothing: the mapping is done in-place in the to - Interface . There are two types of ModelPart mappers: interpolators and transformers . They can be distinguished by their superclass. All interpolators inherit from the superclass MappedInterpolator . These mappers do the actual interpolation. Currently a nearest-neighbour mapper , a linear mapper and a radial basis mapper are available. All transformers inherit from the superclass MappedTransformer . They provide additional functionality that can be useful during mapping. They do not map values from one point cloud to another like the interpolators, but perform one-sided transformations on the coordinates and/or the data. One example is the permutation transformer: it swaps the coordinate axes of the ModelPart and accordingly the components of vector variables. A transformer can never be used by itself, it must always be combined with an interpolator. The reason is that interpolators use information that comes from two sides, which is exactly what the higher-level SolverWrapperMapped and MapperInterface objects are supplying. To chain together multiple ModelPart mappers, the MapperCombined is used: it contains always one interpolator and zero or more transformers, on either side of the interpolator. Special mapper classes MapperInterface Class that maps on the level of Interface objects. It takes two Interfaces , and maps the ModelParts to each other in the order in which the Interfaces are defined in the JSON file. The same type of ModelPart mapper is used for each pair of ModelParts : this can either be an interpolator or a combined mapper. To use a different ModelPart mapper for the different ModelParts in the Interface , or even for different variables, a new Interface mapper would have to be written. JSON setting type description type str ModelPart mapper to be used. settings dict All the settings for the ModelPart mapper specified in type . MapperInterpolator Superclass for all interpolators . JSON setting type description directions list List of coordinate directions, maximum three entries, may contain \"x\" , \"y\" , \"z\" . scaling list Optional. List of scaling factors, must be same length as directions . Coordinates are scaled with these factors, this may improve interpolation e.g. when cells have a high aspect ratio with respect to one of the axes. balanced_tree bool Optional, default false . If set to true a balanced cKDTree is created, which is more stable, but takes longer to build. Set to true in the rare case that the tree gives problems. The initialize method must be defined in all child classes. It takes as arguments the from - ModelPart and the to - ModelPart . It does the following: read and store the coordinates from the from - and to - ModelParts , scale coordinates if necessary, check if the bounding boxes of the from - and to - ModelParts overlap, do an efficient nearest neighbour search using scipy.spatial.cKDTree , check if the from - ModelPart does not contain duplicate coordinates. The __call__ method should not be overridden in the child classes. It interpolates data based on coefficients that are calculated in the initialize method of the child classes. Both scalar and vector variables can be mapped. MapperTransformer Superclass for all transformers . A transformer cannot be used as a standalone mapper, but will always be part of a combined mapper. The initialization of transformers is very different from that of interpolators. A transformer is initialized from one side (either the from or the to side), i.e. based on a single ModelPart . From this input ModelPart , the initialize method creates and returns another ModelPart that is stored and used in the combined mapper. MapperCombined JSON setting type description mappers list An ordered list of all the ModelPart mappers to be used. The MapperCombined is used to chain together multiple mappers. It always contains a single interpolator and zero or more transformers, which can be on either side of the interpolator. If transformers are present, intermediate ModelParts are created during initialization. This is done by working inwards towards the interpolator. This means that transformers upstream of the interpolator, are initialized based on the from - ModelPart (input), while downstream transformers are initialized based on the to - ModelPart (output). Some transformers can only be initialized in one direction, e.g. for MapperAxisymmetric3DTo2D , the 2D to - ModelPart must be supplied, therefore this transformer must be downstream of the interpolator. These concepts are clarified further using an excerpt from the JSON file of the Fluent 3D - Abaqus 2D tube example: { \"type\" : \"mappers.combined\" , \"settings\" : { \"mappers\" : [ { \"type\" : \"mappers.permutation\" , \"settings\" : { \"permutation\" : [ 1 , 0 , 2 ]}}, { \"type\" : \"mappers.radial_basis\" , \"settings\" : { \"directions\" : [ \"x\" , \"y\" , \"z\" ]}}, { \"type\" : \"mappers.axisymmetric_3d*to*2d\" , \"settings\" : { \"direction_axial\" : \"y\" , \"direction_radial\" : \"x\" , \"n_tangential\" : 8 }} ] } } This combined mapper contains 3 ModelPart mappers. In the initialize method, the following happens (in this order): A first intermediate ModelPart is created by calling the initialize method of the permutation transformer. This is done by swapping the x and y coordinates of the from - ModelPart . A second intermediate ModelPart is created by calling the initialize method of the axisymmetric transformer. The coordinates of the 2D to - ModelPart are used to create the 3D intermediate ModelPart by adding points in the circumferential direction. The mapping coefficients of the radial basis interpolator are calculated by calling its initialize method. The first intermediate ModelPart is used as from - ModelPart , the second intermediate ModelPart is used as to - ModelPart . When the __call__ method of the combined mapper is used, the following happens (in this order): The from -data (stored in the from - Interface ) is mapped from the from - ModelPart to the first intermediate ModelPart using the __call__ method of the permutation mapper: scalar variables are unchanged, vector variables are permuted. The resulting data is now interpolated to the second intermediate ModelPart , using the __call__ method of the radial basis mapper. Finally that data is mapped to the to - ModelPart using the __call__ method of the axisymmetric transformer, reducing it from 3D to 2D. That data is written to the to - Interface . Transformers MapperPermutation Permutates the coordinates and the vector variables according to the given permutation . This transformer can be initialized in both directions. JSON setting type description permutation list A permutation of the list [0, 1, 2]. MapperAxisymmetric2DTo3D Transforms a 2D axisymmetric geometry to a 3D geometry. This transformer can only be initialized in the forward direction, i.e. based on the 2D axisymmetric ModelPart . Therefore, it should be upstream of the interpolator in the combined mapper. The 3D ModelPart is returned by the initialization. angle defines the 3D geometry and is based on the geometry of the 3D solver, e.g. the geometry of an axisymmtric simulation with an OpenFoam solver is defined with an angle of 5\u00b0. n_tangential specifies the number of points in the tangential (circumferential) direction, so that for each point in the 2D ModelPart , n_tangential points are created in the 3D ModelPart . It is important to make the value of n_tangential large enough, ideally close to the number of points in the tangential direction in the 3D solver. The code knows which directions are axial, radial and tangential thanks to the input parameters direction_axial and direction_radial . It is not possible to change the axial direction between 2D and 3D: a separate MapperPermutation should be added to the combined mapper for that purpose. Scalar data is simply copied from the 2D point to all corresponding 3D points. For vector data, the axial component is simply copied, the radial component is rotated. The tangential component (e.g. swirl) is not taken into account currently. Points that lie on the symmetry axis can not be handled by the current transformer. JSON setting type description direction_axial string Must be \"x\" , \"y\" or \"z\" , specifies the symmetry axis. direction_radial string Must be \"x\" , \"y\" or \"z\" , specifies the second (radial) axis in 2D. n_tangential int Degrees of freedom in tangential (circumferential) direction of 3D ModelPart that is created during initialization. The minimum setting of n_tangential points depends of the definition of the angle. angle int (optional) Default: 360 . Angle of the (partial) 3D cylinder constructed from the 2D geometry, centred around the radial direction. MapperAxisymmetric3DTo2D Transforms a 3D geometry to a 2D axisymmetric geometry. This transformer can only be initialized in the backward direction, i.e. based on the 2D axisymmetric ModelPart . Therefore, it should be downstream of the interpolator in the combined mapper. For scalar data, the circumferential average is taken for each 2D point. For vector data too, taking into account the correct radial direction in each 3D point. Again, swirl cannot be taken into account: if a tangential component is present in 3D, it is not transferred to 2D. More information and JSON settings can be found under MapperAxisymmetric2DTo3D . Interpolators MapperNearest Does not require additional settings compared to the MapperInterpolator . Does simple nearest-neighbour mapping. MapperLinear Additional settings: JSON setting type description parallel bool Optional, default false . If true the package multiprocessing is used to parallellize the loop that the calculates the interpolation coefficients. This is only useful for ModelParts with a very high number of degrees of freedom. The kind of linear mapping depends on the number of coordinate directions, as given in the directions setting. 1D: If the to -point lies between the 2 nearest from -points, linear interpolation is done. Else, nearest neighbour interpolation is done. 2D: The to -point is first projected on the line through the 2 nearest from -points. If the projected point lies between the from -points, linear interpolation is done. Else, nearest neighbour interpolation is done. 3D: The to -point is first projected on the plane through the 3 nearest from -points. If the triangle consisting of those 3 points is deprecated (colinear points), the 2D-methodology is followed. Else, if the projected point lies inside the triangle, barycentric interpolation is done. If it lies outside the triangle, the 2D-methodology is followed. MapperRadialBasis Additional settings: JSON setting type description parallel bool Optional, default false . If true the package multiprocessing is used to parallellize the loop that the calculates the interpolation coefficients. This is only useful for ModelParts with a very high number of degrees of freedom. shape_parameter int Optional, default 200 . Should be chosen as large as possible without rendering the interpolation matrix ill-conditioned. Radial basis function interpolation is relatively straightforward: implementation for 1D, 2D and 3D is exactly the same and can be written in a condensed way using scipy.spatial.distance . Normal radial basis interpolation is done as follows. \\phi(r) \\phi(r) is a radial basis function defined as \\phi(r) = \\begin{cases} (1-\\frac{r}{d_{ref}})^4 (1 + 4\\frac{r}{d_{ref}}) \\quad &\\mathrm{for} \\quad 0 \\leq \\frac{r}{d_{ref}} < 1 \\\\ 0 &\\mathrm{for} \\quad 1 \\leq \\frac{r}{d_{ref}} \\end{cases} \\phi(r) = \\begin{cases} (1-\\frac{r}{d_{ref}})^4 (1 + 4\\frac{r}{d_{ref}}) \\quad &\\mathrm{for} \\quad 0 \\leq \\frac{r}{d_{ref}} < 1 \\\\ 0 &\\mathrm{for} \\quad 1 \\leq \\frac{r}{d_{ref}} \\end{cases} with r r a positive distance. To control the width of the function, r r is scaled with a reference distance d_{ref} d_{ref} . Assume that n n nearest from -points will be used in the interpolation. An unknown function f(\\boldsymbol{x}) f(\\boldsymbol{x}) can then be approximated as the weighted sum of n n shifted radial basis functions: f(\\boldsymbol{x}) = \\sum_j \\alpha_j \\phi(||\\boldsymbol{x} - \\boldsymbol{x}_j||) f(\\boldsymbol{x}) = \\sum_j \\alpha_j \\phi(||\\boldsymbol{x} - \\boldsymbol{x}_j||) To determine the coefficients \\alpha_j \\alpha_j , we require that the exact function value is returned at the n n from -points. This gives us n n equations f(\\boldsymbol{x}_i) = f_i = \\sum_j \\alpha_j \\phi(||\\boldsymbol{x}_i - \\boldsymbol{x}_j||) f(\\boldsymbol{x}_i) = f_i = \\sum_j \\alpha_j \\phi(||\\boldsymbol{x}_i - \\boldsymbol{x}_j||) which can be written in matrix form as \\boldsymbol{f} = \\boldsymbol{\\Phi} \\boldsymbol{\\alpha} \\boldsymbol{f} = \\boldsymbol{\\Phi} \\boldsymbol{\\alpha} with \\boldsymbol{f}, \\boldsymbol{\\alpha} \\in \\mathbb{R}^{n \\times 1} \\boldsymbol{f}, \\boldsymbol{\\alpha} \\in \\mathbb{R}^{n \\times 1} , and \\boldsymbol{\\Phi} \\in \\mathbb{R}^{n \\times n} \\boldsymbol{\\Phi} \\in \\mathbb{R}^{n \\times n} . This system can be solved for the weights-vector \\boldsymbol{\\alpha} \\boldsymbol{\\alpha} . However, in our case, the from -point values vector \\boldsymbol{f} \\boldsymbol{f} is not known in advance: it contains the values of the Variable that will be interpolated. Therefore, the approximation to calculate the interpolatoin in the to -point is rewritten as follows: f(\\boldsymbol{x}_{to}) = \\sum_j \\alpha_j \\phi(||\\boldsymbol{x}_{to} - \\boldsymbol{x}_j||) = \\boldsymbol{\\Phi}_{to}^T \\boldsymbol{\\alpha} = \\boldsymbol{\\Phi}_{to}^T \\boldsymbol{\\Phi}^{-1} \\boldsymbol{f} = \\boldsymbol{c}^T \\boldsymbol{f} f(\\boldsymbol{x}_{to}) = \\sum_j \\alpha_j \\phi(||\\boldsymbol{x}_{to} - \\boldsymbol{x}_j||) = \\boldsymbol{\\Phi}_{to}^T \\boldsymbol{\\alpha} = \\boldsymbol{\\Phi}_{to}^T \\boldsymbol{\\Phi}^{-1} \\boldsymbol{f} = \\boldsymbol{c}^T \\boldsymbol{f} The coefficients vector \\boldsymbol{c} \\boldsymbol{c} can now be calculated based only on the coordinates by solving the system \\boldsymbol{\\Phi} \\ \\boldsymbol{c} = \\boldsymbol{\\Phi}_{to}. \\boldsymbol{\\Phi} \\ \\boldsymbol{c} = \\boldsymbol{\\Phi}_{to}. As every to-point has different nearest neighbours in the from -points, the coefficient vector \\boldsymbol{c} \\boldsymbol{c} must be calculated for each to -point independently. The matrix \\boldsymbol{\\Phi} \\boldsymbol{\\Phi} and vector \\boldsymbol{\\Phi}_{to} \\boldsymbol{\\Phi}_{to} must also be calculated for every to -point independently. For every to -point, the reference distance d_{ref} d_{ref} is determined as the product of the shape_parameter and the distance between the to -point and the furthest from -point. In order to ensure that the basis function of each of the nearest from -points covers every from -point, the shape_parameter should be larger than two. This value may however lead to an interpolation function which consists of sharp peaks or wiggles, with the correct value near the from -points, but a deviating value away from them. In the extreme case of d_{ref} d_{ref} approaching zero, the so-called \"bed-of-nails interpolant\" is obtained, which is close to zero everywhere, except near the from -points where it sharply peaks. In this case the interpolation matrix approaches the identity matrix. Choosing a higher value improves the interpolation as the basis functions become wider, but the interpolation matrix becomes less stable, i.e. the condition number increases. The default value is 200. In practice, the shape_parameter is chosen so that the interpolation matrix is \"on the edge of ill-conditioning\" (eg. with a condition number of roughly 10^{13} 10^{13} for double-precision floating point). A warning is printed when the condition number of an interpolation matrix becomes higher than 10^{13} 10^{13} .","title":"Mappers"},{"location":"mappers.html#mappers","text":"The coupling interfaces in different solvers are often discretized (meshed) differently, resulting in non-conforming ModelParts . For this reason, mapping is usually required, to transfer data from the output Interface of one solver to the input Interface of another. The terms from and to will be used to denote respectively the side that provides the original data and the side that receives the mapped data.","title":"Mappers"},{"location":"mappers.html#general-concepts","text":"","title":"General concepts"},{"location":"mappers.html#hierarchy-of-mapping-related-objects","text":"CoCoNuT interacts with the mappers through an instance of the SolverWrapperMapped class. This special solver wrapper appears and behaves exactly the same as real solver wrappers. It contains 3 Components : a mapper for the input, a real solver wrapper and a mapper for the output. TODO: add links to Interfaces and ModelParts documentation sections when the terms are first mentioned here (that documentation doesn't exist yet...) The two mappers in the SolverWrapperMapped are of a special type: they work on the level of the Interfaces , while the actual mapping will be done on a lower level: the ModelPart level. The Interface mapper effectively acts as a wrapper around the actual ModelPart mappers. Currently only one mapper is available on the Interface level, aptly called MapperInterface . At the lowest level, mappers interpolate variable data (stored in Interfaces ) between two ModelParts , based on their coordinates. Interpolation is always done from the from ModelPart to the to - ModelPart . Multiple ModelPart mappers can be chained together in a MapperCombined object, to add additional functionality, for example swapping the coordinate axes with the permutation mapper .","title":"Hierarchy of mapping-related objects"},{"location":"mappers.html#interpolators-and-transformers","text":"The ModelPart -level mappers have two main methods: initialize and __call__ . The initialize method performs one-time expensive operations, such as a nearest-neighbour search and the calculation of interpolation coefficients. The __call__ method is used for the actual mapping. It takes two tuples as arguments ( from and to respectively). Each tuple contains an Interface object, the name of the affected ModelPart and the name of the variable that must be mapped. This method returns nothing: the mapping is done in-place in the to - Interface . There are two types of ModelPart mappers: interpolators and transformers . They can be distinguished by their superclass. All interpolators inherit from the superclass MappedInterpolator . These mappers do the actual interpolation. Currently a nearest-neighbour mapper , a linear mapper and a radial basis mapper are available. All transformers inherit from the superclass MappedTransformer . They provide additional functionality that can be useful during mapping. They do not map values from one point cloud to another like the interpolators, but perform one-sided transformations on the coordinates and/or the data. One example is the permutation transformer: it swaps the coordinate axes of the ModelPart and accordingly the components of vector variables. A transformer can never be used by itself, it must always be combined with an interpolator. The reason is that interpolators use information that comes from two sides, which is exactly what the higher-level SolverWrapperMapped and MapperInterface objects are supplying. To chain together multiple ModelPart mappers, the MapperCombined is used: it contains always one interpolator and zero or more transformers, on either side of the interpolator.","title":"Interpolators and transformers"},{"location":"mappers.html#special-mapper-classes","text":"","title":"Special mapper classes"},{"location":"mappers.html#mapperinterface","text":"Class that maps on the level of Interface objects. It takes two Interfaces , and maps the ModelParts to each other in the order in which the Interfaces are defined in the JSON file. The same type of ModelPart mapper is used for each pair of ModelParts : this can either be an interpolator or a combined mapper. To use a different ModelPart mapper for the different ModelParts in the Interface , or even for different variables, a new Interface mapper would have to be written. JSON setting type description type str ModelPart mapper to be used. settings dict All the settings for the ModelPart mapper specified in type .","title":"MapperInterface"},{"location":"mappers.html#mapperinterpolator","text":"Superclass for all interpolators . JSON setting type description directions list List of coordinate directions, maximum three entries, may contain \"x\" , \"y\" , \"z\" . scaling list Optional. List of scaling factors, must be same length as directions . Coordinates are scaled with these factors, this may improve interpolation e.g. when cells have a high aspect ratio with respect to one of the axes. balanced_tree bool Optional, default false . If set to true a balanced cKDTree is created, which is more stable, but takes longer to build. Set to true in the rare case that the tree gives problems. The initialize method must be defined in all child classes. It takes as arguments the from - ModelPart and the to - ModelPart . It does the following: read and store the coordinates from the from - and to - ModelParts , scale coordinates if necessary, check if the bounding boxes of the from - and to - ModelParts overlap, do an efficient nearest neighbour search using scipy.spatial.cKDTree , check if the from - ModelPart does not contain duplicate coordinates. The __call__ method should not be overridden in the child classes. It interpolates data based on coefficients that are calculated in the initialize method of the child classes. Both scalar and vector variables can be mapped.","title":"MapperInterpolator"},{"location":"mappers.html#mappertransformer","text":"Superclass for all transformers . A transformer cannot be used as a standalone mapper, but will always be part of a combined mapper. The initialization of transformers is very different from that of interpolators. A transformer is initialized from one side (either the from or the to side), i.e. based on a single ModelPart . From this input ModelPart , the initialize method creates and returns another ModelPart that is stored and used in the combined mapper.","title":"MapperTransformer"},{"location":"mappers.html#mappercombined","text":"JSON setting type description mappers list An ordered list of all the ModelPart mappers to be used. The MapperCombined is used to chain together multiple mappers. It always contains a single interpolator and zero or more transformers, which can be on either side of the interpolator. If transformers are present, intermediate ModelParts are created during initialization. This is done by working inwards towards the interpolator. This means that transformers upstream of the interpolator, are initialized based on the from - ModelPart (input), while downstream transformers are initialized based on the to - ModelPart (output). Some transformers can only be initialized in one direction, e.g. for MapperAxisymmetric3DTo2D , the 2D to - ModelPart must be supplied, therefore this transformer must be downstream of the interpolator. These concepts are clarified further using an excerpt from the JSON file of the Fluent 3D - Abaqus 2D tube example: { \"type\" : \"mappers.combined\" , \"settings\" : { \"mappers\" : [ { \"type\" : \"mappers.permutation\" , \"settings\" : { \"permutation\" : [ 1 , 0 , 2 ]}}, { \"type\" : \"mappers.radial_basis\" , \"settings\" : { \"directions\" : [ \"x\" , \"y\" , \"z\" ]}}, { \"type\" : \"mappers.axisymmetric_3d*to*2d\" , \"settings\" : { \"direction_axial\" : \"y\" , \"direction_radial\" : \"x\" , \"n_tangential\" : 8 }} ] } } This combined mapper contains 3 ModelPart mappers. In the initialize method, the following happens (in this order): A first intermediate ModelPart is created by calling the initialize method of the permutation transformer. This is done by swapping the x and y coordinates of the from - ModelPart . A second intermediate ModelPart is created by calling the initialize method of the axisymmetric transformer. The coordinates of the 2D to - ModelPart are used to create the 3D intermediate ModelPart by adding points in the circumferential direction. The mapping coefficients of the radial basis interpolator are calculated by calling its initialize method. The first intermediate ModelPart is used as from - ModelPart , the second intermediate ModelPart is used as to - ModelPart . When the __call__ method of the combined mapper is used, the following happens (in this order): The from -data (stored in the from - Interface ) is mapped from the from - ModelPart to the first intermediate ModelPart using the __call__ method of the permutation mapper: scalar variables are unchanged, vector variables are permuted. The resulting data is now interpolated to the second intermediate ModelPart , using the __call__ method of the radial basis mapper. Finally that data is mapped to the to - ModelPart using the __call__ method of the axisymmetric transformer, reducing it from 3D to 2D. That data is written to the to - Interface .","title":"MapperCombined"},{"location":"mappers.html#transformers","text":"","title":"Transformers"},{"location":"mappers.html#mapperpermutation","text":"Permutates the coordinates and the vector variables according to the given permutation . This transformer can be initialized in both directions. JSON setting type description permutation list A permutation of the list [0, 1, 2].","title":"MapperPermutation"},{"location":"mappers.html#mapperaxisymmetric2dto3d","text":"Transforms a 2D axisymmetric geometry to a 3D geometry. This transformer can only be initialized in the forward direction, i.e. based on the 2D axisymmetric ModelPart . Therefore, it should be upstream of the interpolator in the combined mapper. The 3D ModelPart is returned by the initialization. angle defines the 3D geometry and is based on the geometry of the 3D solver, e.g. the geometry of an axisymmtric simulation with an OpenFoam solver is defined with an angle of 5\u00b0. n_tangential specifies the number of points in the tangential (circumferential) direction, so that for each point in the 2D ModelPart , n_tangential points are created in the 3D ModelPart . It is important to make the value of n_tangential large enough, ideally close to the number of points in the tangential direction in the 3D solver. The code knows which directions are axial, radial and tangential thanks to the input parameters direction_axial and direction_radial . It is not possible to change the axial direction between 2D and 3D: a separate MapperPermutation should be added to the combined mapper for that purpose. Scalar data is simply copied from the 2D point to all corresponding 3D points. For vector data, the axial component is simply copied, the radial component is rotated. The tangential component (e.g. swirl) is not taken into account currently. Points that lie on the symmetry axis can not be handled by the current transformer. JSON setting type description direction_axial string Must be \"x\" , \"y\" or \"z\" , specifies the symmetry axis. direction_radial string Must be \"x\" , \"y\" or \"z\" , specifies the second (radial) axis in 2D. n_tangential int Degrees of freedom in tangential (circumferential) direction of 3D ModelPart that is created during initialization. The minimum setting of n_tangential points depends of the definition of the angle. angle int (optional) Default: 360 . Angle of the (partial) 3D cylinder constructed from the 2D geometry, centred around the radial direction.","title":"MapperAxisymmetric2DTo3D"},{"location":"mappers.html#mapperaxisymmetric3dto2d","text":"Transforms a 3D geometry to a 2D axisymmetric geometry. This transformer can only be initialized in the backward direction, i.e. based on the 2D axisymmetric ModelPart . Therefore, it should be downstream of the interpolator in the combined mapper. For scalar data, the circumferential average is taken for each 2D point. For vector data too, taking into account the correct radial direction in each 3D point. Again, swirl cannot be taken into account: if a tangential component is present in 3D, it is not transferred to 2D. More information and JSON settings can be found under MapperAxisymmetric2DTo3D .","title":"MapperAxisymmetric3DTo2D"},{"location":"mappers.html#interpolators","text":"","title":"Interpolators"},{"location":"mappers.html#mappernearest","text":"Does not require additional settings compared to the MapperInterpolator . Does simple nearest-neighbour mapping.","title":"MapperNearest"},{"location":"mappers.html#mapperlinear","text":"Additional settings: JSON setting type description parallel bool Optional, default false . If true the package multiprocessing is used to parallellize the loop that the calculates the interpolation coefficients. This is only useful for ModelParts with a very high number of degrees of freedom. The kind of linear mapping depends on the number of coordinate directions, as given in the directions setting. 1D: If the to -point lies between the 2 nearest from -points, linear interpolation is done. Else, nearest neighbour interpolation is done. 2D: The to -point is first projected on the line through the 2 nearest from -points. If the projected point lies between the from -points, linear interpolation is done. Else, nearest neighbour interpolation is done. 3D: The to -point is first projected on the plane through the 3 nearest from -points. If the triangle consisting of those 3 points is deprecated (colinear points), the 2D-methodology is followed. Else, if the projected point lies inside the triangle, barycentric interpolation is done. If it lies outside the triangle, the 2D-methodology is followed.","title":"MapperLinear"},{"location":"mappers.html#mapperradialbasis","text":"Additional settings: JSON setting type description parallel bool Optional, default false . If true the package multiprocessing is used to parallellize the loop that the calculates the interpolation coefficients. This is only useful for ModelParts with a very high number of degrees of freedom. shape_parameter int Optional, default 200 . Should be chosen as large as possible without rendering the interpolation matrix ill-conditioned. Radial basis function interpolation is relatively straightforward: implementation for 1D, 2D and 3D is exactly the same and can be written in a condensed way using scipy.spatial.distance . Normal radial basis interpolation is done as follows. \\phi(r) \\phi(r) is a radial basis function defined as \\phi(r) = \\begin{cases} (1-\\frac{r}{d_{ref}})^4 (1 + 4\\frac{r}{d_{ref}}) \\quad &\\mathrm{for} \\quad 0 \\leq \\frac{r}{d_{ref}} < 1 \\\\ 0 &\\mathrm{for} \\quad 1 \\leq \\frac{r}{d_{ref}} \\end{cases} \\phi(r) = \\begin{cases} (1-\\frac{r}{d_{ref}})^4 (1 + 4\\frac{r}{d_{ref}}) \\quad &\\mathrm{for} \\quad 0 \\leq \\frac{r}{d_{ref}} < 1 \\\\ 0 &\\mathrm{for} \\quad 1 \\leq \\frac{r}{d_{ref}} \\end{cases} with r r a positive distance. To control the width of the function, r r is scaled with a reference distance d_{ref} d_{ref} . Assume that n n nearest from -points will be used in the interpolation. An unknown function f(\\boldsymbol{x}) f(\\boldsymbol{x}) can then be approximated as the weighted sum of n n shifted radial basis functions: f(\\boldsymbol{x}) = \\sum_j \\alpha_j \\phi(||\\boldsymbol{x} - \\boldsymbol{x}_j||) f(\\boldsymbol{x}) = \\sum_j \\alpha_j \\phi(||\\boldsymbol{x} - \\boldsymbol{x}_j||) To determine the coefficients \\alpha_j \\alpha_j , we require that the exact function value is returned at the n n from -points. This gives us n n equations f(\\boldsymbol{x}_i) = f_i = \\sum_j \\alpha_j \\phi(||\\boldsymbol{x}_i - \\boldsymbol{x}_j||) f(\\boldsymbol{x}_i) = f_i = \\sum_j \\alpha_j \\phi(||\\boldsymbol{x}_i - \\boldsymbol{x}_j||) which can be written in matrix form as \\boldsymbol{f} = \\boldsymbol{\\Phi} \\boldsymbol{\\alpha} \\boldsymbol{f} = \\boldsymbol{\\Phi} \\boldsymbol{\\alpha} with \\boldsymbol{f}, \\boldsymbol{\\alpha} \\in \\mathbb{R}^{n \\times 1} \\boldsymbol{f}, \\boldsymbol{\\alpha} \\in \\mathbb{R}^{n \\times 1} , and \\boldsymbol{\\Phi} \\in \\mathbb{R}^{n \\times n} \\boldsymbol{\\Phi} \\in \\mathbb{R}^{n \\times n} . This system can be solved for the weights-vector \\boldsymbol{\\alpha} \\boldsymbol{\\alpha} . However, in our case, the from -point values vector \\boldsymbol{f} \\boldsymbol{f} is not known in advance: it contains the values of the Variable that will be interpolated. Therefore, the approximation to calculate the interpolatoin in the to -point is rewritten as follows: f(\\boldsymbol{x}_{to}) = \\sum_j \\alpha_j \\phi(||\\boldsymbol{x}_{to} - \\boldsymbol{x}_j||) = \\boldsymbol{\\Phi}_{to}^T \\boldsymbol{\\alpha} = \\boldsymbol{\\Phi}_{to}^T \\boldsymbol{\\Phi}^{-1} \\boldsymbol{f} = \\boldsymbol{c}^T \\boldsymbol{f} f(\\boldsymbol{x}_{to}) = \\sum_j \\alpha_j \\phi(||\\boldsymbol{x}_{to} - \\boldsymbol{x}_j||) = \\boldsymbol{\\Phi}_{to}^T \\boldsymbol{\\alpha} = \\boldsymbol{\\Phi}_{to}^T \\boldsymbol{\\Phi}^{-1} \\boldsymbol{f} = \\boldsymbol{c}^T \\boldsymbol{f} The coefficients vector \\boldsymbol{c} \\boldsymbol{c} can now be calculated based only on the coordinates by solving the system \\boldsymbol{\\Phi} \\ \\boldsymbol{c} = \\boldsymbol{\\Phi}_{to}. \\boldsymbol{\\Phi} \\ \\boldsymbol{c} = \\boldsymbol{\\Phi}_{to}. As every to-point has different nearest neighbours in the from -points, the coefficient vector \\boldsymbol{c} \\boldsymbol{c} must be calculated for each to -point independently. The matrix \\boldsymbol{\\Phi} \\boldsymbol{\\Phi} and vector \\boldsymbol{\\Phi}_{to} \\boldsymbol{\\Phi}_{to} must also be calculated for every to -point independently. For every to -point, the reference distance d_{ref} d_{ref} is determined as the product of the shape_parameter and the distance between the to -point and the furthest from -point. In order to ensure that the basis function of each of the nearest from -points covers every from -point, the shape_parameter should be larger than two. This value may however lead to an interpolation function which consists of sharp peaks or wiggles, with the correct value near the from -points, but a deviating value away from them. In the extreme case of d_{ref} d_{ref} approaching zero, the so-called \"bed-of-nails interpolant\" is obtained, which is close to zero everywhere, except near the from -points where it sharply peaks. In this case the interpolation matrix approaches the identity matrix. Choosing a higher value improves the interpolation as the basis functions become wider, but the interpolation matrix becomes less stable, i.e. the condition number increases. The default value is 200. In practice, the shape_parameter is chosen so that the interpolation matrix is \"on the edge of ill-conditioning\" (eg. with a condition number of roughly 10^{13} 10^{13} for double-precision floating point). A warning is printed when the condition number of an interpolation matrix becomes higher than 10^{13} 10^{13} .","title":"MapperRadialBasis"},{"location":"models.html","text":"Models This documentation describes the different types of available models. The purpose of a model is always to approximate a (inverse) Jacobian of a system, based on secant information from input and output pairs. In order to approximate the Jacobian \\mathcal{A}' \\mathcal{A}' of a general function a=\\mathcal{A}(b) a=\\mathcal{A}(b) , the model needs to be supplied with matching input and output pairs, ( b^i b^i , a^i=\\mathcal{A}(b^i) a^i=\\mathcal{A}(b^i) ). Once at least two pairs have been supplied, the model is able to approximately predict the product of the Jacobian with an arbitrary vector \\Delta b \\Delta b . In other words, when the a vector \\Delta b \\Delta b is given it outputs \\Delta a=\\widehat{\\mathcal{A}}'\\Delta b \\Delta a=\\widehat{\\mathcal{A}}'\\Delta b , where the hat symbol is used to denote that an approximation of the Jacobain is used. Which Jacobian is approximated in practice will depend on the use of the model in the coupled solver. For example, using the coupled solver CoupledSolverIQNI with the model ModelLS corresponds to the IQN-ILS method developed by Degroote et al. [ 1 ]. In that case, the approximated Jacobian is \\mathcal{R}'^{-1} \\mathcal{R}'^{-1} . If the coupled solver CoupledSolverIBQN is combined with two instances the model ModelLS , the resulting algorithm corresponds to the IBQN-LS method developed by Vierendeels et al. [ 2 ]. Then, the two models each approximate one Jacobian: \\mathcal{F}' \\mathcal{F}' and \\mathcal{S}' \\mathcal{S}' . Refer to the coupled solvers documentation for more information on these notations. In the following, the example from IQN-ILS will be used: the inverse Jacobian of \\mathcal{R}' \\mathcal{R}' with respect to \\tilde{x} \\tilde{x} is approximated which has an input vector r r and an output vector \\tilde{x} \\tilde{x} . For brevity, the approximation will denoted by N^k N^k , where the superscript k k referes to the iteration. Common methods There are three model-specific methods which are implemented by all models. The first of which is the predict(dr) method, which returns an estimation of \\Delta \\tilde{x}=N^k\\Delta r \\Delta \\tilde{x}=N^k\\Delta r from an input \\Delta r \\Delta r , based on stored input and output pairs. Second, in order to improve the estimation, input-output pairs can be added to the model using the method add(r, xt) . Third, the method filter_q(dr) returns the part of vector \\Delta r \\Delta r which is orthogonal to the columnspace of the matrix containing the differences between consecutively stored inputs. In other words, it returns the part of the input vector \\Delta r \\Delta r for which the deficient approximation of the Jacobian holds no information. Note that it is equal to the part of the vector \\Delta r \\Delta r which is inside the nullspace of the approximation of the Jacobian represented by the model. Least-squares The type for this model is coupled_solvers.models.ls . The abbreviation LS stands for least-squares . From the received input vectors r^i r^i and output vectors \\tilde{x}^i \\tilde{x}^i , differences are constructed $$ \\delta r^{i-1}=r^i-r^{i-1}, \\; \\delta \\tilde{x}^{i-1}=\\tilde{x}^i-\\tilde{x}^{i-1}. $$ These are stored as column of the matrices V V and W W . This model requires the approximation of the Jacobian, denoted by N^k N^k , to fulfill the secant equations: $$ W=N^k V. $$ In addition to this a minimal norm requirement is imposed (hence the name). The differences can be limited to the current time step only. However, using the reuse parameter q , the differences from the q previous time steps are included as well. It is important to note that differences between the input and outputs from different time steps are not considered. Reuse may greatly improve the convergence speed and stability. The optimal value of q is problem dependent. Typically, however, an optimal value is around 10. This model is matrix-free, due to an implementation using QR-decomposition. With matrix-free is meant that no large dense matrices are constructed, not that no matrices are used at all. The R R matrix from the QR-decomposition has to be invertible. Therefore, (almost) linearly dependent columns in the matrix containing the input information from the current and previous time steps should be removed. This is called filtering. The larger q , the more important filtering becomes. If the diagonal element in R R is smaller than an absolute tolerance level min_significant , the corresponding column is removed. The implementation is as such that the most recent information is kept. For more information refer to [ 3 ]. As mentioned before, the combination of this model wiht the coupled solver CoupledSolverIQNI corresponds to the IQN-ILS method developed by Degroote et al. [ 1 ], while using twice this model with the coupled solver CoupledSolverIBQN corresponds to the IBQN-LS method developed by Vierendeels et al. [ 2 ]. Settings The following parameters need to be included in the settings dictionary. They are listed in alphabetical order. parameter type description min_significant double Absolute tolerance for filtering. To disable filtering set to 0 . q int Number of previous time steps that are reused. In a steady simulation there are no previous time steps, so then it should be 0 . Multi-vector The type for this model is coupled_solvers.models.mv . The abbreviation MV stands for multi-vector . In this model, differences are constructed similar to the least-squares model. However, it requires the approximation N^k N^k to fulfill the secant equations of the current time step only. Moreover, it is required that the approximation is as close as possible to the previous time step. In this model large dense matrices are constructed and is hence discouraged for cases with a large number of degrees of freedom on the interface. Filtering can also be applied here, then (almost) linear columns in the matrix containing the input information from the current time step are removed. However, filtering is much less critical compared to the LS model as it concerns only the information from the current time step. If no filtering is wanted, the tolerance level should be set to zero. For more information refer to [ 3 ]. The combination of this model with the coupled solver CoupledSolverIQNI corresponds to the IQN-MVJ from Lindner et al. [ 4 ], while using twice this model with the coupled solver CoupledSolverIBQN corresponds to the MVQN method developed by Bogaers et al. [ 5 ]. Settings The following parameters need to be included in the settings dictionary. They are listed in alphabetical order. parameter type description min_significant double (optional) Default: 0 (disabled). Absolute tolerance for filtering. Multi-vector matrix-free The type for this model is coupled_solvers.models.mv_mf . The abbreviation MV-MF stands for multi-vector matrix-free . By combining the QR-approach from the least-squares model with the time step wise storage of secant information, a matrix-free implementation of the multi-vector approach is obtained quite naturally. This implementation was also thought of by Spenke et al. [ 6 ]. In this approach, the contribution of each time step is grouped into a separate term, where the most recent time step has priority over the later ones. Therefore, a parameter q is used to denote how many time steps are reused. Setting this parameter very large, this model will act the same as MV , which reuses all time steps. Generally, the performance will increase when this parameter is chosen larger, but so will be the computational cost. Nonetheless, this cost is much smaller compared to the non-matrix-free multi-vector approach. Filtering can be applied similar to the above described models, but this is typically not necessary. Settings The following parameters need to be included in the settings dictionary. They are listed in alphabetical order. parameter type description min_significant double (optional) Default: 0 (disabled). Absolute tolerance for filtering. q int Number of previous time steps that are reused. In a steady simulation there are no previous time steps, so then it should be 0. References [1] Degroote J., Bathe K.-J., Vierendeels J., \"Performance of a new partitioned procedure versus a monolithic procedure in fluid-structure interaction\", Computers & Structures, vol. 87, no. 11\u201312, pp. 793-801, 2009. [2] Vierendeels J., Lanoye L., Degroote J., Verdonck P., \"Implicit coupling of partitioned fluid-structure interaction problems with reduced order models\", Computers & Structures, vol. 85, no. 11\u201314, pp. 970\u2013976, 2007. [3] Delaiss\u00e9 N., Demeester T., Fauconnier D. and Degroote J., \"Comparison of different quasi-Newton techniques for coupling of black box solvers\", in ECCOMAS 2020, Proceedings, Paris, France, 2021. [4] Lindner F., Mehl M., Scheufele K., Uekermann B., \"A comparison of various quasi-Newton schemes for partitioned fluid-structure interaction\", in: B. Schrefler, E. O\u00f1ate, M. Papadrakakis (Eds.), 6th International Conference on Computational 975 Methods for Coupled Problems in Science and Engineering, pp. 477\u2013488, 2015. [5] Bogaers A., Kok S., Reddy B., Franz T., \"Quasi-Newton methods for implicit black-box FSI coupling\", ComputerMethods in AppliedMechanics and Engineering, vol. 279, pp. 113\u2013132, 2014. [6] Spenke T., Hosters N., Behr M., \"A multi-vector interface quasi-newton method with linear complexity for partitioned fluid\u2013structure interaction\", Computer Methods in Applied Mechanics and Engineering, vol. 361, pp. 112810, 2020.","title":"Models"},{"location":"models.html#models","text":"This documentation describes the different types of available models. The purpose of a model is always to approximate a (inverse) Jacobian of a system, based on secant information from input and output pairs. In order to approximate the Jacobian \\mathcal{A}' \\mathcal{A}' of a general function a=\\mathcal{A}(b) a=\\mathcal{A}(b) , the model needs to be supplied with matching input and output pairs, ( b^i b^i , a^i=\\mathcal{A}(b^i) a^i=\\mathcal{A}(b^i) ). Once at least two pairs have been supplied, the model is able to approximately predict the product of the Jacobian with an arbitrary vector \\Delta b \\Delta b . In other words, when the a vector \\Delta b \\Delta b is given it outputs \\Delta a=\\widehat{\\mathcal{A}}'\\Delta b \\Delta a=\\widehat{\\mathcal{A}}'\\Delta b , where the hat symbol is used to denote that an approximation of the Jacobain is used. Which Jacobian is approximated in practice will depend on the use of the model in the coupled solver. For example, using the coupled solver CoupledSolverIQNI with the model ModelLS corresponds to the IQN-ILS method developed by Degroote et al. [ 1 ]. In that case, the approximated Jacobian is \\mathcal{R}'^{-1} \\mathcal{R}'^{-1} . If the coupled solver CoupledSolverIBQN is combined with two instances the model ModelLS , the resulting algorithm corresponds to the IBQN-LS method developed by Vierendeels et al. [ 2 ]. Then, the two models each approximate one Jacobian: \\mathcal{F}' \\mathcal{F}' and \\mathcal{S}' \\mathcal{S}' . Refer to the coupled solvers documentation for more information on these notations. In the following, the example from IQN-ILS will be used: the inverse Jacobian of \\mathcal{R}' \\mathcal{R}' with respect to \\tilde{x} \\tilde{x} is approximated which has an input vector r r and an output vector \\tilde{x} \\tilde{x} . For brevity, the approximation will denoted by N^k N^k , where the superscript k k referes to the iteration.","title":"Models"},{"location":"models.html#common-methods","text":"There are three model-specific methods which are implemented by all models. The first of which is the predict(dr) method, which returns an estimation of \\Delta \\tilde{x}=N^k\\Delta r \\Delta \\tilde{x}=N^k\\Delta r from an input \\Delta r \\Delta r , based on stored input and output pairs. Second, in order to improve the estimation, input-output pairs can be added to the model using the method add(r, xt) . Third, the method filter_q(dr) returns the part of vector \\Delta r \\Delta r which is orthogonal to the columnspace of the matrix containing the differences between consecutively stored inputs. In other words, it returns the part of the input vector \\Delta r \\Delta r for which the deficient approximation of the Jacobian holds no information. Note that it is equal to the part of the vector \\Delta r \\Delta r which is inside the nullspace of the approximation of the Jacobian represented by the model.","title":"Common methods"},{"location":"models.html#least-squares","text":"The type for this model is coupled_solvers.models.ls . The abbreviation LS stands for least-squares . From the received input vectors r^i r^i and output vectors \\tilde{x}^i \\tilde{x}^i , differences are constructed $$ \\delta r^{i-1}=r^i-r^{i-1}, \\; \\delta \\tilde{x}^{i-1}=\\tilde{x}^i-\\tilde{x}^{i-1}. $$ These are stored as column of the matrices V V and W W . This model requires the approximation of the Jacobian, denoted by N^k N^k , to fulfill the secant equations: $$ W=N^k V. $$ In addition to this a minimal norm requirement is imposed (hence the name). The differences can be limited to the current time step only. However, using the reuse parameter q , the differences from the q previous time steps are included as well. It is important to note that differences between the input and outputs from different time steps are not considered. Reuse may greatly improve the convergence speed and stability. The optimal value of q is problem dependent. Typically, however, an optimal value is around 10. This model is matrix-free, due to an implementation using QR-decomposition. With matrix-free is meant that no large dense matrices are constructed, not that no matrices are used at all. The R R matrix from the QR-decomposition has to be invertible. Therefore, (almost) linearly dependent columns in the matrix containing the input information from the current and previous time steps should be removed. This is called filtering. The larger q , the more important filtering becomes. If the diagonal element in R R is smaller than an absolute tolerance level min_significant , the corresponding column is removed. The implementation is as such that the most recent information is kept. For more information refer to [ 3 ]. As mentioned before, the combination of this model wiht the coupled solver CoupledSolverIQNI corresponds to the IQN-ILS method developed by Degroote et al. [ 1 ], while using twice this model with the coupled solver CoupledSolverIBQN corresponds to the IBQN-LS method developed by Vierendeels et al. [ 2 ].","title":"Least-squares"},{"location":"models.html#settings","text":"The following parameters need to be included in the settings dictionary. They are listed in alphabetical order. parameter type description min_significant double Absolute tolerance for filtering. To disable filtering set to 0 . q int Number of previous time steps that are reused. In a steady simulation there are no previous time steps, so then it should be 0 .","title":"Settings"},{"location":"models.html#multi-vector","text":"The type for this model is coupled_solvers.models.mv . The abbreviation MV stands for multi-vector . In this model, differences are constructed similar to the least-squares model. However, it requires the approximation N^k N^k to fulfill the secant equations of the current time step only. Moreover, it is required that the approximation is as close as possible to the previous time step. In this model large dense matrices are constructed and is hence discouraged for cases with a large number of degrees of freedom on the interface. Filtering can also be applied here, then (almost) linear columns in the matrix containing the input information from the current time step are removed. However, filtering is much less critical compared to the LS model as it concerns only the information from the current time step. If no filtering is wanted, the tolerance level should be set to zero. For more information refer to [ 3 ]. The combination of this model with the coupled solver CoupledSolverIQNI corresponds to the IQN-MVJ from Lindner et al. [ 4 ], while using twice this model with the coupled solver CoupledSolverIBQN corresponds to the MVQN method developed by Bogaers et al. [ 5 ].","title":"Multi-vector"},{"location":"models.html#settings_1","text":"The following parameters need to be included in the settings dictionary. They are listed in alphabetical order. parameter type description min_significant double (optional) Default: 0 (disabled). Absolute tolerance for filtering.","title":"Settings"},{"location":"models.html#multi-vector-matrix-free","text":"The type for this model is coupled_solvers.models.mv_mf . The abbreviation MV-MF stands for multi-vector matrix-free . By combining the QR-approach from the least-squares model with the time step wise storage of secant information, a matrix-free implementation of the multi-vector approach is obtained quite naturally. This implementation was also thought of by Spenke et al. [ 6 ]. In this approach, the contribution of each time step is grouped into a separate term, where the most recent time step has priority over the later ones. Therefore, a parameter q is used to denote how many time steps are reused. Setting this parameter very large, this model will act the same as MV , which reuses all time steps. Generally, the performance will increase when this parameter is chosen larger, but so will be the computational cost. Nonetheless, this cost is much smaller compared to the non-matrix-free multi-vector approach. Filtering can be applied similar to the above described models, but this is typically not necessary.","title":"Multi-vector matrix-free"},{"location":"models.html#settings_2","text":"The following parameters need to be included in the settings dictionary. They are listed in alphabetical order. parameter type description min_significant double (optional) Default: 0 (disabled). Absolute tolerance for filtering. q int Number of previous time steps that are reused. In a steady simulation there are no previous time steps, so then it should be 0.","title":"Settings"},{"location":"models.html#references","text":"[1] Degroote J., Bathe K.-J., Vierendeels J., \"Performance of a new partitioned procedure versus a monolithic procedure in fluid-structure interaction\", Computers & Structures, vol. 87, no. 11\u201312, pp. 793-801, 2009. [2] Vierendeels J., Lanoye L., Degroote J., Verdonck P., \"Implicit coupling of partitioned fluid-structure interaction problems with reduced order models\", Computers & Structures, vol. 85, no. 11\u201314, pp. 970\u2013976, 2007. [3] Delaiss\u00e9 N., Demeester T., Fauconnier D. and Degroote J., \"Comparison of different quasi-Newton techniques for coupling of black box solvers\", in ECCOMAS 2020, Proceedings, Paris, France, 2021. [4] Lindner F., Mehl M., Scheufele K., Uekermann B., \"A comparison of various quasi-Newton schemes for partitioned fluid-structure interaction\", in: B. Schrefler, E. O\u00f1ate, M. Papadrakakis (Eds.), 6th International Conference on Computational 975 Methods for Coupled Problems in Science and Engineering, pp. 477\u2013488, 2015. [5] Bogaers A., Kok S., Reddy B., Franz T., \"Quasi-Newton methods for implicit black-box FSI coupling\", ComputerMethods in AppliedMechanics and Engineering, vol. 279, pp. 113\u2013132, 2014. [6] Spenke T., Hosters N., Behr M., \"A multi-vector interface quasi-newton method with linear complexity for partitioned fluid\u2013structure interaction\", Computer Methods in Applied Mechanics and Engineering, vol. 361, pp. 112810, 2020.","title":"References"},{"location":"openfoam.html","text":"OpenFOAM This is the documentation for all OpenFOAM solver wrappers. Currently, only FSI simulations are supported, no other multiphysics problems. Parameters This section describes the parameters in the JSON file, listed in alphabetical order. parameter type description application string Name of the (adapted) OpenFOAM-solver to be used for the flow problem. This name should start with coconut_ . boundary_names list List of names of the patches corresponding to the interface. These names should match the patch names defined in the OpenFOAM-case. delta_t double (optional) Fixed timestep size in flow solver. density int The applied density of the fluid in an incompressible case. The density will be applied if is_incompressible is set to true . interface_input dict List of dictionaries that describes the input Interface . This provides the interface boundary conditions for the OpenFOAM solver. Each entry in the list has two keys: model_part and variables , with values as name of the model part and list of input variables, respectively. The input variables in the list should be chosen from the variables_dimensions dict in the file coconut/data_structure/variables.py . The model part name must be the concatenation of an entry from boundary_names and the string _input . interface_output dict Analogous to interface_input , but here the name must be the concatenation of an entry from boundary_names and the string _output . The entries in the list provides boundary conditions for the other solver(s) participating in the coupled simulation. is_incompressible boolean Set it to True if the solver solves incompressible Navier-Stokes equation. parallel boolean Set it to True if OpenFOAM solver is required to run in parallel. The required decomposition method and number of cores should be provided in the <case_directory>/system/decomposeParDict file. residual_variables list (optional) A list containing OpenFOAM variables whose residuals you need to output. If provided, this will output the last initial residual of the pimple iterations for each FSI-coupling iteration in <case_directory>/residuals.csv . time_precision int Number of digits after the decimal sign to be used in the name of the time step directories which are made during execution. timestep_start int (optional) Time step to (re)start a transient FSI calculation from. If 0 is given, the simulation starts from t = 0, else the code looks for the relevant case and data files. working_directory string Directory where the OpenFOAM-case is defined (and which contains the JSON-file). timestep_start and delta_t are necessary parameters, but are usually defined already in the parameters of the coupled solver. However, they can also be given directly as parameter of the solver wrapper (e.g. for standalone testing). If they are defined both in the coupled solver and in the solver wrapper, then the former value is used, and a warning is printed. Overview of the OpenFOAM-wrapper The solver wrapper can be found in solver_wrappers/openfoam and consists of a python-file named vX.py , with X the identifier of the OpenFOAM-version (e.g. v41.py for OpenFOAM 4.1). Finally, using an OpenFOAM-solver in CoCoNuT requires the adaptation of the solver to accommodate communications with the coupled_solvers during the FSI-simulation. Currently, only pimpleFoam and interFoam have been adapted; the solvers called by the solver wrapper have the same name as the original OpenFOAM-solver but with the prefix coconut_ . Upon using the OpenFOAM-wrapper, the solver to be used upon execution needs to be compiled using the default OpenFOAM-compilation method (loading the OpenFOAM-module and using wmake in the directory solver_wrapper/coconut_<solver_name> ). The __init__ method During initialization, the case settings as defined in the JSON-file are read into the corresponding python-variables. Afterwards, the required OpenFOAM-files are modified, and some checks are in place to verify whether the correct modules are loaded. Next, the model-parts for the interface_input/output are created. Finally, the variables on each interface are stored in the data-structure of CoCoNuT. The initialize method The OpenFOAM-solver, which should be adapted to work with CoCoNuT, is launched in a subprocess. Other variables, such as time step index and physical time, are initialized. The initialize_solution_step method This function is called at the start of every time step. The time step index is increased by one, the iteration index is set to zero, and the OpenFOAM file directory is made in which the time step data needs to be stored. The solve_solution_step method The interface displacement is converted into an OpenFOAM-readable format (with the function write_node_input ), after which the OpenFOAM-loop is called in a subprocess. After completion of the OpenFOAM-loop, the function read_node_output is called, which reads the interface loads from the corresponding OpenFOAM-directory (in the postProcessing folder). The finalize_solution_step method In this method, it is checked whether the other flow variables need to be written in an OpenFOAM-directory. This save-option is done in OpenFOAM. The finalize method The OpenFOAM-subprocess, which was launched in the Initialize method, is killed. Comments Files with extension .coco are used to pass messages between python-script and OpenFOAM. After sending a message from python to OpenFOAM, the python-script is paused until it receives the corresponding message from OpenFOAM. The OpenFOAM-solver is operating in an infinite while -loop until it receives a message from Python. Upon receipt of this message, OpenFOAM executes the corresponding action after which it sends a response to Python and reverts into its infinite loop (waiting mode). The aforementioned messaging procedure implies that OpenFOAM is constantly running during execution of the CoCoNuT-simulation. It is closed by the Python-code only in the Finalize method, but if CoCoNuT crashes, the OpenFOAM-programme keeps running. The user should take care to kill that OpenFOAM-loop manually (using kill or pkill in the Linux-terminal, e.g. pkill coconut_* ). The interface displacement is stored in a pointDisplacement field, which is read in by OpenFOAM in every iteration ( this required some adaptation of the solver, see next section). The dynamic mesh motion is handled by OpenFOAM itself. The interface loads are stored in the directory postProcessing , under the names PRESSURE_<boundary_name> and TRACTION_<boundary_name> . These are constructed from the file controlDict , defined in the _init_ method of the solver wrapper in python. Overview of an OpenFOAM-solver used in CoCoNuT Default OpenFOAM-solvers cannot be used in the CoCoNuT-framework, but need to be modified. The adapted solvers are stored in the coconut/coupling_components/solver_wrappers directory and receive the name coconut_<solver_name> , where solver_name is the name of the original solver, e.g. pimpleFoam . If a new solver needs to be adapted to work with CoCoNuT, one of the already established solvers can work as an example. In brief, the following steps should be undertaken: Except for the initial include -statements, the entire solver code should be put in a loop that starts with while(true) . Just before this while-loop, add the statement runTime.run(); ! This is important as it creates and initializes the functionObjects in the controlDict file which will be used for storing the interface loads. Due to the fact that the infinite loop is driven by while(true) and not the default OpenFOAM-expression while(runTime.run()) , OpenFOAM does not check itself whether the final time step is reached. In proper CoCoNuT-operation, OpenFOAM is killed when the solver wrapper reaches the final time step. Inside the while-loop, a sleep-command is added such that the solver is not constantly checking the conditional statements. The while-loop contains several conditional statements, each of which check whether the python-code in CoCoNuT has sent a message to the OpenFOAM-solver. This message is sent by creating an empty file with a specific name in the OpenFOAM-directory. The following file names should be checked by the OpenFOAM-solver: next.coco , continue.coco , save.coco , stop.coco . If the file next.coco exists, the runTime-object should be increased by one. OpenFOAM should create a file next_ready.coco upon completion. Do not forget to delete the original next.coco file, which is advised to do just before creating the next_ready.coco , so near the end of the if -clause. If the file continue.coco exists, the flow equations need to be solved. This if -statement consequently contains most of the original solver definition, in which the flow equations are called in the same order as in the original CFD solver. OpenFOAM should create a file continue_ready.coco upon completion. Do not forget to delete the original continue.coco -file, which is advised to do just before creating the continue_ready.coco , so near the end of the if -clause. If the file save.coco exists, OpenFOAM checks whether the flow variables should be stored in corresponding files, according to the user-defined save interval. OpenFOAM should create a file save_ready.coco upon completion. Do not forget to delete the original save.coco file, which is advised to do just before creating the save_ready.coco , so near the end of the if -clause. If the file stop.coco exists, a break -statement should end the infinite loop (the subprocess is also killed in the python-code). OpenFOAM should create a file stop_ready.coco before breaking the while -loop. Do not forget to delete the original stop.coco file, which is advised to do just before creating the stop_ready.coco , so near the end of the if -clause. Setting up a new case Following items should be present in the OpenFOAM-directory prior to launching CoCoNuT: The entire framework of the CFD-case in OpenFOAM which is to be used in the CoCoNuT simulation (so it should contain the constant and system directory as well as the 0 directory). The working directory should be defined as if you would like to run it as a CFD case. The working directory is defined in a JSON-file and therefore the CoCoNuT-files do not need to be in the same folder as the OpenFOAM-case. a JSON-file containing all the settings stipulated above. Following files are modified or used as a reference to create files by CoCoNuT, and must be included in the original OpenFOAM-directory: system/controlDict with compulsory arguments: key value writeControl timeStep writeInterval required write interval writeFormat ascii timeFormat fixed timePrecision required time precision based on delta_t (used in the names of time step folders) runTimeModifiable false adjustTimeStep no constant/dynamicMeshDict which contains the settings for OpenFOAM's dynamic motion solver system/decomposeParDict with the necessary decomposition of the fluid domain (if cores >1) 0/pointDisplacement with all the boundary conditions, including fixedValue boundary condition for the FSI boundaries. This is used as a template for the pointDisplacement_Next to supply displacement boundary conditon ( from structural solver) for the FSI-interface. Comments It is probably best to derive a new case from the directory containing FSI simulation with OpenFOAM in coconut/examples/ in order to copy its structure. If you do not use an OpenFOAM-solver which is already converted for operation in CoCoNuT, you will need to adapt the solver yourself. This can be done in a rather straightforward way by taking a look at already implemented solvers. You should compile the new solver before loading the CoCoNuT-modules as the overwriting of compiler modules can break the wmake -command. Once the new solver is compiled, it works fine even after loading the CoCoNuT-modules. OpenFOAM is known for generating a lot of files, which is not different in CoCoNuT-operation. Make sure you have sufficient storage space on your cluster and that you are able to write large number of files (the latter is specifically important when storing data in your home-directory). Version specific documentation v41 (OpenFOAM 4.1) First version. v8 (OpenFOAM 8) In this OpenFOAM version, the name of some commands and classes are different. The required changes are visible in the version specific solver wrapper python file v8.py . Moreover, there are some changes in the case setup. The following list provides some but is not all extensive: The interpolation point for arc definitions using blockMesh has to be on the arc and not just on its 'elongation' Using a macro expansion, such as $R , in combination with #calc , where an operator follows the macro expansion, requires using protection: use #calc \"${R}/2 instead of #calc \"$R/2 The file constant/turbulenceProperties has been renamed to constant/momentumTransport The keyword residualControl in the PIMPLE dictionary is now called outerCorrectorResidualControl . The keyword residualControl still exists, but has a different meaning and is used as in SIMPLE . The file system/fvSolution requires dictionaries pcorr and pcorrFinal , if the keyword correctPhi is true in system/fvSolution , which it is by default. The tolerance settings should be sufficiently low (similar to p ).","title":"OpenFOAM"},{"location":"openfoam.html#openfoam","text":"This is the documentation for all OpenFOAM solver wrappers. Currently, only FSI simulations are supported, no other multiphysics problems.","title":"OpenFOAM"},{"location":"openfoam.html#parameters","text":"This section describes the parameters in the JSON file, listed in alphabetical order. parameter type description application string Name of the (adapted) OpenFOAM-solver to be used for the flow problem. This name should start with coconut_ . boundary_names list List of names of the patches corresponding to the interface. These names should match the patch names defined in the OpenFOAM-case. delta_t double (optional) Fixed timestep size in flow solver. density int The applied density of the fluid in an incompressible case. The density will be applied if is_incompressible is set to true . interface_input dict List of dictionaries that describes the input Interface . This provides the interface boundary conditions for the OpenFOAM solver. Each entry in the list has two keys: model_part and variables , with values as name of the model part and list of input variables, respectively. The input variables in the list should be chosen from the variables_dimensions dict in the file coconut/data_structure/variables.py . The model part name must be the concatenation of an entry from boundary_names and the string _input . interface_output dict Analogous to interface_input , but here the name must be the concatenation of an entry from boundary_names and the string _output . The entries in the list provides boundary conditions for the other solver(s) participating in the coupled simulation. is_incompressible boolean Set it to True if the solver solves incompressible Navier-Stokes equation. parallel boolean Set it to True if OpenFOAM solver is required to run in parallel. The required decomposition method and number of cores should be provided in the <case_directory>/system/decomposeParDict file. residual_variables list (optional) A list containing OpenFOAM variables whose residuals you need to output. If provided, this will output the last initial residual of the pimple iterations for each FSI-coupling iteration in <case_directory>/residuals.csv . time_precision int Number of digits after the decimal sign to be used in the name of the time step directories which are made during execution. timestep_start int (optional) Time step to (re)start a transient FSI calculation from. If 0 is given, the simulation starts from t = 0, else the code looks for the relevant case and data files. working_directory string Directory where the OpenFOAM-case is defined (and which contains the JSON-file). timestep_start and delta_t are necessary parameters, but are usually defined already in the parameters of the coupled solver. However, they can also be given directly as parameter of the solver wrapper (e.g. for standalone testing). If they are defined both in the coupled solver and in the solver wrapper, then the former value is used, and a warning is printed.","title":"Parameters"},{"location":"openfoam.html#overview-of-the-openfoam-wrapper","text":"The solver wrapper can be found in solver_wrappers/openfoam and consists of a python-file named vX.py , with X the identifier of the OpenFOAM-version (e.g. v41.py for OpenFOAM 4.1). Finally, using an OpenFOAM-solver in CoCoNuT requires the adaptation of the solver to accommodate communications with the coupled_solvers during the FSI-simulation. Currently, only pimpleFoam and interFoam have been adapted; the solvers called by the solver wrapper have the same name as the original OpenFOAM-solver but with the prefix coconut_ . Upon using the OpenFOAM-wrapper, the solver to be used upon execution needs to be compiled using the default OpenFOAM-compilation method (loading the OpenFOAM-module and using wmake in the directory solver_wrapper/coconut_<solver_name> ).","title":"Overview of the OpenFOAM-wrapper"},{"location":"openfoam.html#the-__init__-method","text":"During initialization, the case settings as defined in the JSON-file are read into the corresponding python-variables. Afterwards, the required OpenFOAM-files are modified, and some checks are in place to verify whether the correct modules are loaded. Next, the model-parts for the interface_input/output are created. Finally, the variables on each interface are stored in the data-structure of CoCoNuT.","title":"The __init__ method"},{"location":"openfoam.html#the-initialize-method","text":"The OpenFOAM-solver, which should be adapted to work with CoCoNuT, is launched in a subprocess. Other variables, such as time step index and physical time, are initialized.","title":"The initialize method"},{"location":"openfoam.html#the-initialize_solution_step-method","text":"This function is called at the start of every time step. The time step index is increased by one, the iteration index is set to zero, and the OpenFOAM file directory is made in which the time step data needs to be stored.","title":"The initialize_solution_step method"},{"location":"openfoam.html#the-solve_solution_step-method","text":"The interface displacement is converted into an OpenFOAM-readable format (with the function write_node_input ), after which the OpenFOAM-loop is called in a subprocess. After completion of the OpenFOAM-loop, the function read_node_output is called, which reads the interface loads from the corresponding OpenFOAM-directory (in the postProcessing folder).","title":"The solve_solution_step method"},{"location":"openfoam.html#the-finalize_solution_step-method","text":"In this method, it is checked whether the other flow variables need to be written in an OpenFOAM-directory. This save-option is done in OpenFOAM.","title":"The finalize_solution_step method"},{"location":"openfoam.html#the-finalize-method","text":"The OpenFOAM-subprocess, which was launched in the Initialize method, is killed.","title":"The finalize method"},{"location":"openfoam.html#comments","text":"Files with extension .coco are used to pass messages between python-script and OpenFOAM. After sending a message from python to OpenFOAM, the python-script is paused until it receives the corresponding message from OpenFOAM. The OpenFOAM-solver is operating in an infinite while -loop until it receives a message from Python. Upon receipt of this message, OpenFOAM executes the corresponding action after which it sends a response to Python and reverts into its infinite loop (waiting mode). The aforementioned messaging procedure implies that OpenFOAM is constantly running during execution of the CoCoNuT-simulation. It is closed by the Python-code only in the Finalize method, but if CoCoNuT crashes, the OpenFOAM-programme keeps running. The user should take care to kill that OpenFOAM-loop manually (using kill or pkill in the Linux-terminal, e.g. pkill coconut_* ). The interface displacement is stored in a pointDisplacement field, which is read in by OpenFOAM in every iteration ( this required some adaptation of the solver, see next section). The dynamic mesh motion is handled by OpenFOAM itself. The interface loads are stored in the directory postProcessing , under the names PRESSURE_<boundary_name> and TRACTION_<boundary_name> . These are constructed from the file controlDict , defined in the _init_ method of the solver wrapper in python.","title":"Comments"},{"location":"openfoam.html#overview-of-an-openfoam-solver-used-in-coconut","text":"Default OpenFOAM-solvers cannot be used in the CoCoNuT-framework, but need to be modified. The adapted solvers are stored in the coconut/coupling_components/solver_wrappers directory and receive the name coconut_<solver_name> , where solver_name is the name of the original solver, e.g. pimpleFoam . If a new solver needs to be adapted to work with CoCoNuT, one of the already established solvers can work as an example. In brief, the following steps should be undertaken: Except for the initial include -statements, the entire solver code should be put in a loop that starts with while(true) . Just before this while-loop, add the statement runTime.run(); ! This is important as it creates and initializes the functionObjects in the controlDict file which will be used for storing the interface loads. Due to the fact that the infinite loop is driven by while(true) and not the default OpenFOAM-expression while(runTime.run()) , OpenFOAM does not check itself whether the final time step is reached. In proper CoCoNuT-operation, OpenFOAM is killed when the solver wrapper reaches the final time step. Inside the while-loop, a sleep-command is added such that the solver is not constantly checking the conditional statements. The while-loop contains several conditional statements, each of which check whether the python-code in CoCoNuT has sent a message to the OpenFOAM-solver. This message is sent by creating an empty file with a specific name in the OpenFOAM-directory. The following file names should be checked by the OpenFOAM-solver: next.coco , continue.coco , save.coco , stop.coco . If the file next.coco exists, the runTime-object should be increased by one. OpenFOAM should create a file next_ready.coco upon completion. Do not forget to delete the original next.coco file, which is advised to do just before creating the next_ready.coco , so near the end of the if -clause. If the file continue.coco exists, the flow equations need to be solved. This if -statement consequently contains most of the original solver definition, in which the flow equations are called in the same order as in the original CFD solver. OpenFOAM should create a file continue_ready.coco upon completion. Do not forget to delete the original continue.coco -file, which is advised to do just before creating the continue_ready.coco , so near the end of the if -clause. If the file save.coco exists, OpenFOAM checks whether the flow variables should be stored in corresponding files, according to the user-defined save interval. OpenFOAM should create a file save_ready.coco upon completion. Do not forget to delete the original save.coco file, which is advised to do just before creating the save_ready.coco , so near the end of the if -clause. If the file stop.coco exists, a break -statement should end the infinite loop (the subprocess is also killed in the python-code). OpenFOAM should create a file stop_ready.coco before breaking the while -loop. Do not forget to delete the original stop.coco file, which is advised to do just before creating the stop_ready.coco , so near the end of the if -clause.","title":"Overview of an OpenFOAM-solver used in CoCoNuT"},{"location":"openfoam.html#setting-up-a-new-case","text":"Following items should be present in the OpenFOAM-directory prior to launching CoCoNuT: The entire framework of the CFD-case in OpenFOAM which is to be used in the CoCoNuT simulation (so it should contain the constant and system directory as well as the 0 directory). The working directory should be defined as if you would like to run it as a CFD case. The working directory is defined in a JSON-file and therefore the CoCoNuT-files do not need to be in the same folder as the OpenFOAM-case. a JSON-file containing all the settings stipulated above. Following files are modified or used as a reference to create files by CoCoNuT, and must be included in the original OpenFOAM-directory: system/controlDict with compulsory arguments: key value writeControl timeStep writeInterval required write interval writeFormat ascii timeFormat fixed timePrecision required time precision based on delta_t (used in the names of time step folders) runTimeModifiable false adjustTimeStep no constant/dynamicMeshDict which contains the settings for OpenFOAM's dynamic motion solver system/decomposeParDict with the necessary decomposition of the fluid domain (if cores >1) 0/pointDisplacement with all the boundary conditions, including fixedValue boundary condition for the FSI boundaries. This is used as a template for the pointDisplacement_Next to supply displacement boundary conditon ( from structural solver) for the FSI-interface.","title":"Setting up a new case"},{"location":"openfoam.html#comments_1","text":"It is probably best to derive a new case from the directory containing FSI simulation with OpenFOAM in coconut/examples/ in order to copy its structure. If you do not use an OpenFOAM-solver which is already converted for operation in CoCoNuT, you will need to adapt the solver yourself. This can be done in a rather straightforward way by taking a look at already implemented solvers. You should compile the new solver before loading the CoCoNuT-modules as the overwriting of compiler modules can break the wmake -command. Once the new solver is compiled, it works fine even after loading the CoCoNuT-modules. OpenFOAM is known for generating a lot of files, which is not different in CoCoNuT-operation. Make sure you have sufficient storage space on your cluster and that you are able to write large number of files (the latter is specifically important when storing data in your home-directory).","title":"Comments"},{"location":"openfoam.html#version-specific-documentation","text":"","title":"Version specific documentation"},{"location":"openfoam.html#v41-openfoam-41","text":"First version.","title":"v41 (OpenFOAM 4.1)"},{"location":"openfoam.html#v8-openfoam-8","text":"In this OpenFOAM version, the name of some commands and classes are different. The required changes are visible in the version specific solver wrapper python file v8.py . Moreover, there are some changes in the case setup. The following list provides some but is not all extensive: The interpolation point for arc definitions using blockMesh has to be on the arc and not just on its 'elongation' Using a macro expansion, such as $R , in combination with #calc , where an operator follows the macro expansion, requires using protection: use #calc \"${R}/2 instead of #calc \"$R/2 The file constant/turbulenceProperties has been renamed to constant/momentumTransport The keyword residualControl in the PIMPLE dictionary is now called outerCorrectorResidualControl . The keyword residualControl still exists, but has a different meaning and is used as in SIMPLE . The file system/fvSolution requires dictionaries pcorr and pcorrFinal , if the keyword correctPhi is true in system/fvSolution , which it is by default. The tolerance settings should be sufficiently low (similar to p ).","title":"v8 (OpenFOAM 8)"},{"location":"predictors.html","text":"Predictors This documentation describes the available predictors. A predictor is used to determine the initial guess in each time step by extrapolating the solution from previous time steps. The predictors differ in the number of previous time steps they take into account and the polynomial degree that is used. The formulas in this document, use the index n n to refer to the time step, where n+1 n+1 is the current time step, i.e. the time step for which the initial guess is made. The vector x x is the input for the first solver, conform the coupled solvers documentation . A predictor is intialized in the coupled solver using an initial solution as determined by the coupled solver. As such, there is at least one previous solution available. In the JSON file, the predictor dictionary only requires a type (e.g. predictors.linear ), no settings dictionary has to be provided. Specification of a predictor is mandatory, also for a steady simulation. In that case, however, it does not matter which predictor is chosen as only one \"time step\" is performed. Constant The type for this predictor is predictors.constant . This predictor uses the result from the previous solution as the initial guess in the current time step: $$ x^{n+1}=x^{n}. $$ Linear The type for this predictor is predictors.linear . This predictor uses the results from the last two time steps to determine the initial guess in the current time step using a linear extrapolation as follows $$ x^{n+1}=2x^{n}-1x^{n-1}. $$ If no two previous solutions are available, the solution from the last time step is used, i.e. the predictor PredictorConstant . Legacy The type for this predictor is predictors.legacy . This predictor uses the results from the last three time steps to determine the initial guess in the current time step using a linear extrapolation as follows $$ x^{n+1}=\\frac{5}{2}x^{n}-2x^{n-1}+\\frac{1}{2}x^{n-2}. $$ If no three previous solutions are available, the predictor PredictorLinear is used. This predictor is called PredictorLegacy as it corresponds to the second order extrapolator in the coupling code Tango , the predecessor of CoCoNuT . Quadratic The type for this predictor is predictors.quadratic . This predictor uses the results from the last three time steps to determine the initial guess in the current time step using a quadratic extrapolation as follows $$ x^{n+1}=3x^{n}-3x^{n-1}+1x^{n-2}. $$ If no three previous solutions are available, the predictor PredictorLinear is used. Cubic The type for this predictor is predictors.cubic . This predictor uses the results from the last three time steps to determine the initial guess in the current time step using a cubic extrapolation as follows $$ x^{n+1}=4x^{n}-6x^{n-1}+4x^{n-2}-1x^{n-3}. $$ If no four previous solutions are available, the predictor PredictorQuadratic is used.","title":"Predictors"},{"location":"predictors.html#predictors","text":"This documentation describes the available predictors. A predictor is used to determine the initial guess in each time step by extrapolating the solution from previous time steps. The predictors differ in the number of previous time steps they take into account and the polynomial degree that is used. The formulas in this document, use the index n n to refer to the time step, where n+1 n+1 is the current time step, i.e. the time step for which the initial guess is made. The vector x x is the input for the first solver, conform the coupled solvers documentation . A predictor is intialized in the coupled solver using an initial solution as determined by the coupled solver. As such, there is at least one previous solution available. In the JSON file, the predictor dictionary only requires a type (e.g. predictors.linear ), no settings dictionary has to be provided. Specification of a predictor is mandatory, also for a steady simulation. In that case, however, it does not matter which predictor is chosen as only one \"time step\" is performed.","title":"Predictors"},{"location":"predictors.html#constant","text":"The type for this predictor is predictors.constant . This predictor uses the result from the previous solution as the initial guess in the current time step: $$ x^{n+1}=x^{n}. $$","title":"Constant"},{"location":"predictors.html#linear","text":"The type for this predictor is predictors.linear . This predictor uses the results from the last two time steps to determine the initial guess in the current time step using a linear extrapolation as follows $$ x^{n+1}=2x^{n}-1x^{n-1}. $$ If no two previous solutions are available, the solution from the last time step is used, i.e. the predictor PredictorConstant .","title":"Linear"},{"location":"predictors.html#legacy","text":"The type for this predictor is predictors.legacy . This predictor uses the results from the last three time steps to determine the initial guess in the current time step using a linear extrapolation as follows $$ x^{n+1}=\\frac{5}{2}x^{n}-2x^{n-1}+\\frac{1}{2}x^{n-2}. $$ If no three previous solutions are available, the predictor PredictorLinear is used. This predictor is called PredictorLegacy as it corresponds to the second order extrapolator in the coupling code Tango , the predecessor of CoCoNuT .","title":"Legacy"},{"location":"predictors.html#quadratic","text":"The type for this predictor is predictors.quadratic . This predictor uses the results from the last three time steps to determine the initial guess in the current time step using a quadratic extrapolation as follows $$ x^{n+1}=3x^{n}-3x^{n-1}+1x^{n-2}. $$ If no three previous solutions are available, the predictor PredictorLinear is used.","title":"Quadratic"},{"location":"predictors.html#cubic","text":"The type for this predictor is predictors.cubic . This predictor uses the results from the last three time steps to determine the initial guess in the current time step using a cubic extrapolation as follows $$ x^{n+1}=4x^{n}-6x^{n-1}+4x^{n-2}-1x^{n-3}. $$ If no four previous solutions are available, the predictor PredictorQuadratic is used.","title":"Cubic"},{"location":"python.html","text":"Python This is the documentation for all Python solver wrappers. Currently only solvers exist for the one-dimensional (1D) calculation of a straight flexible tube. Tube There are three tube solvers for a straight tube with circular cross-section. The axial direction is along the z-axis. All of them are 1D solvers. This means the tube is divided in m intervals in the axial z-direction and only variations in that direction are taken into account. In other words, all variables are uniform over a cross-section. They are calculated in the center of each of the m cells. There is one flow solver SolverWrapperTubeFlow and two structure solvers, one with inertia SolverWrapperTubeStructure and one without SolverWrapperTubeRingmodel . These solvers are very simple and provide insight in the physics, especially in the stability of fluid-structure interaction simulation. Nonetheless, they are not meant to provide an accurate representation of reality. Especially the pressure stabilization term in the flow solver smooths the pressure distribution. Settings The following parameters, listed in alphabetical order, need to be provided in the JSON parameter file as settings of the solver wrapper. parameter type description delta_t double Fixed time step size. This parameter is usually specified in a higher component. input_file string Name of the input file, which must be present in the folder given in working_directory . The file contains all parameters required for the solver, in JSON-format. interface_input list List of dictionaries; each dictionary requires two keys: model_part and variables . The former contains the name of the ModelPart as a string. The value of the latter is a list of variables. Even if there is only one variable, a list is required. For the Python solver wrappers these variables are fixed: ['displacement'] for a flow solver and ['pressure','traction'] for a structure solver. interface_output list Analogous to interface_input . However, the variables are different: ['pressure','traction'] for a flow solver and ['displacement'] for a structure solver. unsteady bool (optional) Default: true . Indicates if case is steady or unsteady. save_restart int (optional) Default: 0. Determines the time step interval upon which a pickle file case_timestep<time step>.pickle is written, to be used for restart purposes. A minus sign indicates only the file from the last interval is retained. time_step_start int (optional) Default: 0. Time step number to (re)start a transient FSI calculation. If 0 is given, the simulation starts from scratch. Otherwise, the code looks for the pickle file case_timestep<timestep_start>.pickle to start from the corresponding time step. For a steady simulation, the value should be 0 . working_directory string Absolute path to the working directory or relative path with respect to the current directory. delta_t is a necessary parameter, while timestep_start and save_restart are optional, but all are usually defined in a higher component. However, they can also be given directly as parameter of the solver wrapper (e.g. for standalone testing). If they are defined both in higher component and in the solver wrapper, then the former value is used and a warning is printed. Because these solvers are simple it is possible to omit the use of interpolation between two solver wrappers. In that case , the names of the ModelParts of both flow and structure solver need to be the same. Tube flow solver This flow solver calculates the flow inside a 1D straight and flexible tube. The type for this solver wrapper is solver_wrappers.python.tube_flow_solver . The required input is the radial displacement of the tube wall. The other components of displacement are ingnored. The resulting output is the pressure on the tube wall. Although a required variable in interface_output , traction is always returned as being zero. From the radial displacements the area of each cross-section is calculated. The flow is governed by the continuity and momentum equation $$ \\frac{\\partial a}{\\partial t}+\\frac{\\partial av}{\\partial z}=0 $$ $$ \\frac{\\partial av}{\\partial t}+\\frac{\\partial av^2}{\\partial z}+\\frac{1}{\\rho_f}\\left(\\frac{\\partial ap}{\\partial z}-p\\frac{\\partial a}{\\partial z}\\right)=0 $$ with a=\\pi r^2 a=\\pi r^2 the cross-sectional area of the tube and r r the inner radius. Furthermore, t t is the time, v v the velocity along the axis of the tube, p p the pressure and \\rho_f \\rho_f the density of the fluid. At the start and at the end of the tube the boundary conditions have to be applied. Discretizing these equations results in a system of linear algebraic equations which can be solved for the pressure and velocity by performing Newton-Raphson iterations. Inside the solver the kinematic pressure is used, which is the pressure divided by the density of the fluid. The boundary condtions are implemented by four additional equations: at the in- and outlet for both pressure and velocity. At the inlet, the pressure, velocity or total pressure can be specified. At the outlet, the pressure can be set to a fixed value or a non-reflecting boundary conditions. These settings are specified in the input_file in the working directory . For more information about the implementation this solver refer to [ 1 ]. Solver parameters The following parameters, listed in alphabetical order, need to be specified in a file with name input_file . This file should be located in the working_directory . Care should be taken that the values of d , e , h , l and rhof match the corresponding values of the structural solver. parameter type description axial_offset double (optional) Default: 0 . Distance over which tube is displaced axially in the coordinate system. d double Nominal diameter of the tube. e double Modulus of elasticity of the tube wall. h double Thickness of the tube wall. inlet_boundary dict Dictionary containing all information with respect to the inlet boundary condition. l double Length of the tube. m int Number of cells for discretization. The values are calculated in the cell centers. newtonmax double Maximum number of Newton-Raphson iterations for the flow solver calculation. newtontol double Relative tolerance for the Newton-Raphson iterations for the flow solver calculation. outlet_boundary dict Dictionary containing all information with respect to the outlet boundary condition. preference double (optional) Default: 0 . Reference pressure and initial pressure. u0 double (optional) Default: ureference . Initial velocity throughout the tube. ureference double Reference velocity used for determination of pressure stabilization term. rhof double Density of the fluid. Inlet Boundary This section describes all parameters that need to be specified in the dictionary inlet_boundary , listed in alphabetical order. parameter type description amplitude double Amplitude of the inlet boundary condition. period double Period of the inlet boundary condition. Period of oscillation for a periodic boundary condition, duration for a non-periodic boundary condition. Not used for a fixed value boundary condition (type 4 ). reference double (optional) Reference value of inlet boundary condition. If not provided, the value of this parameter is the corresponding reference value provided above, i.e. ureference , preference or preference + rhof * ureference ^2 / 2. type int Type of inlet boundary condition. If 1 , a sine wave is used with amplitude, reference and period as specified. If 2 , a pulse is used with amplitude as specified and a duration equal to the parameter period. After the pulse the variable is equal to the reference value. If 3 , a quadratic sine wave is used with amplitude, reference and period as specified. If 4 , a fixed value equal to the sum of the reference value and the amplitude. Used for steady cases. If other, a steady increase of the value at the inlet with slope of amplitude divided by period is used. variable string Variable upon which the inlet boundary condition is defined, either 'pressure' , 'velocity' or 'total pressure' . Outlet Boundary This section describes all parameters that need to be specified in the dictionary outlet_boundary , listed in alphabetical order. parameter type description type int Type of outlet boundary condition. If 1 , a non-reflecting boundary condition is applied. This type cannot be used for a steady calculation. If other, a fixed value equal to the reference pressure is applied. Tube Ringmodel solver This structure solver calculates the deformation of the wall of a straight and flexible tube. The type for this solver wrapper is solver_wrappers.python.ring_model_solver . The tube is regarded as made up of independent rings and no inertia is taken into account. Therefore, there is no dependence on previous time steps and the parameters delta_t and timestep_start are not used. The required input is the pressure on the tube wall. Traction is not taken into account, even though it is a required variable in interface_input . The resulting output is the radial displacement. For the other components of displacement, zero is returned. This solver is not suited to calculate the propagation of a pressure pulse. The behaviour of the elastic tube wall is described by a Hookean relation, which results in the following equation $$ a=a_0\\left(\\frac{p_0-2c^2_{MK}}{p_0-2c^2_{MK}}\\right)^2 $$ with a=\\pi r^2 a=\\pi r^2 the cross-sectional area of the tube and r r the inner radius. Furthermore, p p the pressure, p_0 p_0 the reference pressure, \\rho_f \\rho_f the density of the fluid and c^2_{MK} c^2_{MK} the Moens-Korteweg wave speed given by $$ c^2_{MK}=\\sqrt{\\frac{Eh}{2\\rho_f r_0}} $$ Here, E E is the modulus of elasticity, h h the thickness of the tube wall and r_0 r_0 the reference radius. No boundary conditions are required. Inside the solver the kinematic pressure is used, which is the pressure divided by the density of the fluid. More information about the implementation of this solver can be found in [ 2 ]. Solver parameters The following parameters, listed in alphabetical order, need to be specified in a file with name input_file . This file should be located in the working_directory . Care should be taken that the values of d , e , h , l and rhof match the corresponding values of the flow solver. parameter type description axial_offset double (optional) Defalult: 0 . Distance over which tube is displaced axially in the coordinate system. d double Nominal diameter of the tube. e double Modulus of elasticity of the tube wall. h double Thickness of tube wall. l double Length of the tube. m int Number of cells for discretization. The values are calculated in the cell centers. preference double (optional) Default: 0 . Reference pressure. rhof double Density of the fluid. Tube structure solver This structure solver calculates the deformation of the wall of a straight and flexible tube. The type for this solver wrapper is solver_wrappers.python.tube_structure_solver . In this model inertia is taken into account, but still only radial displacement is considered. The required input is the pressure on the tube wall. Traction is not taken into account, even though it is a required variable in interface_input . The resulting output is the radial displacement. For the other components of displacement, zero is returned. The deformation of the tube in the radial direction is determined by $$ \\rho_s h\\frac{\\partial^2 r}{\\partial t^2}+b_1\\frac{\\partial^4 r}{\\partial z^4}-b_2\\frac{\\partial^2 r}{\\partial z^2}+b_3(r-r_o)=p-p_o $$ with \\rho_s \\rho_s the solid density and h h the thickness of the tube wall. Further, r r is the inner radius, p p pressure and t t time. The variables r_0 r_0 and p_0 p_0 are a reference radius and pressure, respectively. The parameters b_1 b_1 and b_2 b_2 ( b_1, b_2 \\ge 0 b_1, b_2 \\ge 0 ) account for the inner action of the bending and the axial tension in the wall, while the parameter b_3 b_3 accounts for the circumferential stress in the tube wall. For a thin-walled tube that is clamped in the axial direction, they are defined as $$ b_1=\\frac{hE}{1-\\nu^2}\\frac{h^2}{12} \\textrm{, } b_2=\\frac{hE}{1-\\nu^2}\\frac{h^2}{12}\\frac{2\\nu}{r_o^2} \\textrm{ and } b_3=\\frac{hE}{1-\\nu^2}\\frac{1}{r_o^2}+\\frac{hE}{1-\\nu^2}\\frac{h^2}{12}\\frac{1}{r_o^4} $$ with E E the Young's modulus and \\nu \\nu Poisson's coefficient. The second term of b_3 b_3 is considered small compared to the first one because h\\ll r_o h\\ll r_o and is thus neglected. Discretizing these equations results in a system of linear algebraic equations with a Jacobian that does not depend on the pressure. The system can be solved for the radius in one step. The tube is considered clamped at both ends. This boundary condition is imposed by adding four equations: two at the inlet and two at the outlet. For more information about the implementation of this solver refer to [ 1 ]. In this work the Newmark-beta time discretization is used. Here, however, backward Euler time discretization is used as well. For the Newmark-beta time discretization, two Newmark parameters \\beta \\beta and \\gamma \\gamma are required, which result in an unconditionally stable integration scheme if $$ \\gamma\\geq\\frac{1}{2} \\textrm{ and } \\beta\\geq\\frac{1}{4}\\left(\\frac{1}{2}+\\gamma\\right)^2. $$ Typical values are \\gamma \\gamma equal to 1/2 and \\beta \\beta equal to 1/4. A different time discretization for flow and structure can lead to difficulties for strongly coupled problems, especially looking at the resulting pressure distributions. As most flow solvers are discretized using the backward Euler method, it is advised to chose the same method for the structure solver (the time discretization of SolverWrapperTubeFlowSolver is also backward Euler). This avoids the occurrence of spurious oscillations of the pressure in time [ 3 ]. Solver parameters The following parameters, listed in alphabetical order, need to be specified in a file with name input_file .This file should be located in the working_directory . Care should be taken that the values of d , e , h , l and rhof match the corresponding values of the flow solver. parameter type description axial_offset double (optional) Default: 0 . Distance over which tube is displaced axially in the coordinate system. beta double (optional) Newmark parameter \\beta \\beta . Only required when the Newmark-beta time discretization is used. d double Nominal diameter of the tube. e double Modulus of elasticity of the tube wall. h double Thickness of the tube wall. gamma double (optional) Newmark parameter \\gamma \\gamma . Only required when the Newmark-beta time discretization is used. l double Length of the tube. m int Number of cells for discretization. The values are calculated in the cell centers. nu double Poisson's ratio. preference double (optional) Default: 0 . Reference pressure. rhof double Density of the fluid. rhos double Density of the tube wall. time_disretization string (optional) Default: backward Euler . Specifies the time discretiation: either Newmark or backward Euler . Not case sensitive. References [1] Degroote J., Annerel S. and Vierendeels J., \"Stability analysis of Gauss-Seidel iterations in a partitioned simulation of fluid-structure interaction\", Computers & Structures, vol. 88, no. 5-6, pp. 263, 2010. [2] Degroote J., Bruggeman P., Haelterman R., Vierendeels J., \"Stability of a coupling technique for partitioned solvers in FSI applications\", Computers & Structures, vol. 86, no. 23\u201324, pp. 2224\u20132234, 2008. [3] Vierendeels J., Dumont K., Dick E., Verdonck P., \"Analysis and stabilization of fluid-structure interaction algorithm for rigid-body motion\", American Institute of Aeronautics and Astronautics Journal\", vol. 43, no. 12, pp. 2549\u20132557, 2005.","title":"Python"},{"location":"python.html#python","text":"This is the documentation for all Python solver wrappers. Currently only solvers exist for the one-dimensional (1D) calculation of a straight flexible tube.","title":"Python"},{"location":"python.html#tube","text":"There are three tube solvers for a straight tube with circular cross-section. The axial direction is along the z-axis. All of them are 1D solvers. This means the tube is divided in m intervals in the axial z-direction and only variations in that direction are taken into account. In other words, all variables are uniform over a cross-section. They are calculated in the center of each of the m cells. There is one flow solver SolverWrapperTubeFlow and two structure solvers, one with inertia SolverWrapperTubeStructure and one without SolverWrapperTubeRingmodel . These solvers are very simple and provide insight in the physics, especially in the stability of fluid-structure interaction simulation. Nonetheless, they are not meant to provide an accurate representation of reality. Especially the pressure stabilization term in the flow solver smooths the pressure distribution.","title":"Tube"},{"location":"python.html#settings","text":"The following parameters, listed in alphabetical order, need to be provided in the JSON parameter file as settings of the solver wrapper. parameter type description delta_t double Fixed time step size. This parameter is usually specified in a higher component. input_file string Name of the input file, which must be present in the folder given in working_directory . The file contains all parameters required for the solver, in JSON-format. interface_input list List of dictionaries; each dictionary requires two keys: model_part and variables . The former contains the name of the ModelPart as a string. The value of the latter is a list of variables. Even if there is only one variable, a list is required. For the Python solver wrappers these variables are fixed: ['displacement'] for a flow solver and ['pressure','traction'] for a structure solver. interface_output list Analogous to interface_input . However, the variables are different: ['pressure','traction'] for a flow solver and ['displacement'] for a structure solver. unsteady bool (optional) Default: true . Indicates if case is steady or unsteady. save_restart int (optional) Default: 0. Determines the time step interval upon which a pickle file case_timestep<time step>.pickle is written, to be used for restart purposes. A minus sign indicates only the file from the last interval is retained. time_step_start int (optional) Default: 0. Time step number to (re)start a transient FSI calculation. If 0 is given, the simulation starts from scratch. Otherwise, the code looks for the pickle file case_timestep<timestep_start>.pickle to start from the corresponding time step. For a steady simulation, the value should be 0 . working_directory string Absolute path to the working directory or relative path with respect to the current directory. delta_t is a necessary parameter, while timestep_start and save_restart are optional, but all are usually defined in a higher component. However, they can also be given directly as parameter of the solver wrapper (e.g. for standalone testing). If they are defined both in higher component and in the solver wrapper, then the former value is used and a warning is printed. Because these solvers are simple it is possible to omit the use of interpolation between two solver wrappers. In that case , the names of the ModelParts of both flow and structure solver need to be the same.","title":"Settings"},{"location":"python.html#tube-flow-solver","text":"This flow solver calculates the flow inside a 1D straight and flexible tube. The type for this solver wrapper is solver_wrappers.python.tube_flow_solver . The required input is the radial displacement of the tube wall. The other components of displacement are ingnored. The resulting output is the pressure on the tube wall. Although a required variable in interface_output , traction is always returned as being zero. From the radial displacements the area of each cross-section is calculated. The flow is governed by the continuity and momentum equation $$ \\frac{\\partial a}{\\partial t}+\\frac{\\partial av}{\\partial z}=0 $$ $$ \\frac{\\partial av}{\\partial t}+\\frac{\\partial av^2}{\\partial z}+\\frac{1}{\\rho_f}\\left(\\frac{\\partial ap}{\\partial z}-p\\frac{\\partial a}{\\partial z}\\right)=0 $$ with a=\\pi r^2 a=\\pi r^2 the cross-sectional area of the tube and r r the inner radius. Furthermore, t t is the time, v v the velocity along the axis of the tube, p p the pressure and \\rho_f \\rho_f the density of the fluid. At the start and at the end of the tube the boundary conditions have to be applied. Discretizing these equations results in a system of linear algebraic equations which can be solved for the pressure and velocity by performing Newton-Raphson iterations. Inside the solver the kinematic pressure is used, which is the pressure divided by the density of the fluid. The boundary condtions are implemented by four additional equations: at the in- and outlet for both pressure and velocity. At the inlet, the pressure, velocity or total pressure can be specified. At the outlet, the pressure can be set to a fixed value or a non-reflecting boundary conditions. These settings are specified in the input_file in the working directory . For more information about the implementation this solver refer to [ 1 ].","title":"Tube flow solver"},{"location":"python.html#solver-parameters","text":"The following parameters, listed in alphabetical order, need to be specified in a file with name input_file . This file should be located in the working_directory . Care should be taken that the values of d , e , h , l and rhof match the corresponding values of the structural solver. parameter type description axial_offset double (optional) Default: 0 . Distance over which tube is displaced axially in the coordinate system. d double Nominal diameter of the tube. e double Modulus of elasticity of the tube wall. h double Thickness of the tube wall. inlet_boundary dict Dictionary containing all information with respect to the inlet boundary condition. l double Length of the tube. m int Number of cells for discretization. The values are calculated in the cell centers. newtonmax double Maximum number of Newton-Raphson iterations for the flow solver calculation. newtontol double Relative tolerance for the Newton-Raphson iterations for the flow solver calculation. outlet_boundary dict Dictionary containing all information with respect to the outlet boundary condition. preference double (optional) Default: 0 . Reference pressure and initial pressure. u0 double (optional) Default: ureference . Initial velocity throughout the tube. ureference double Reference velocity used for determination of pressure stabilization term. rhof double Density of the fluid.","title":"Solver parameters"},{"location":"python.html#inlet-boundary","text":"This section describes all parameters that need to be specified in the dictionary inlet_boundary , listed in alphabetical order. parameter type description amplitude double Amplitude of the inlet boundary condition. period double Period of the inlet boundary condition. Period of oscillation for a periodic boundary condition, duration for a non-periodic boundary condition. Not used for a fixed value boundary condition (type 4 ). reference double (optional) Reference value of inlet boundary condition. If not provided, the value of this parameter is the corresponding reference value provided above, i.e. ureference , preference or preference + rhof * ureference ^2 / 2. type int Type of inlet boundary condition. If 1 , a sine wave is used with amplitude, reference and period as specified. If 2 , a pulse is used with amplitude as specified and a duration equal to the parameter period. After the pulse the variable is equal to the reference value. If 3 , a quadratic sine wave is used with amplitude, reference and period as specified. If 4 , a fixed value equal to the sum of the reference value and the amplitude. Used for steady cases. If other, a steady increase of the value at the inlet with slope of amplitude divided by period is used. variable string Variable upon which the inlet boundary condition is defined, either 'pressure' , 'velocity' or 'total pressure' .","title":"Inlet Boundary"},{"location":"python.html#outlet-boundary","text":"This section describes all parameters that need to be specified in the dictionary outlet_boundary , listed in alphabetical order. parameter type description type int Type of outlet boundary condition. If 1 , a non-reflecting boundary condition is applied. This type cannot be used for a steady calculation. If other, a fixed value equal to the reference pressure is applied.","title":"Outlet Boundary"},{"location":"python.html#tube-ringmodel-solver","text":"This structure solver calculates the deformation of the wall of a straight and flexible tube. The type for this solver wrapper is solver_wrappers.python.ring_model_solver . The tube is regarded as made up of independent rings and no inertia is taken into account. Therefore, there is no dependence on previous time steps and the parameters delta_t and timestep_start are not used. The required input is the pressure on the tube wall. Traction is not taken into account, even though it is a required variable in interface_input . The resulting output is the radial displacement. For the other components of displacement, zero is returned. This solver is not suited to calculate the propagation of a pressure pulse. The behaviour of the elastic tube wall is described by a Hookean relation, which results in the following equation $$ a=a_0\\left(\\frac{p_0-2c^2_{MK}}{p_0-2c^2_{MK}}\\right)^2 $$ with a=\\pi r^2 a=\\pi r^2 the cross-sectional area of the tube and r r the inner radius. Furthermore, p p the pressure, p_0 p_0 the reference pressure, \\rho_f \\rho_f the density of the fluid and c^2_{MK} c^2_{MK} the Moens-Korteweg wave speed given by $$ c^2_{MK}=\\sqrt{\\frac{Eh}{2\\rho_f r_0}} $$ Here, E E is the modulus of elasticity, h h the thickness of the tube wall and r_0 r_0 the reference radius. No boundary conditions are required. Inside the solver the kinematic pressure is used, which is the pressure divided by the density of the fluid. More information about the implementation of this solver can be found in [ 2 ].","title":"Tube Ringmodel solver"},{"location":"python.html#solver-parameters_1","text":"The following parameters, listed in alphabetical order, need to be specified in a file with name input_file . This file should be located in the working_directory . Care should be taken that the values of d , e , h , l and rhof match the corresponding values of the flow solver. parameter type description axial_offset double (optional) Defalult: 0 . Distance over which tube is displaced axially in the coordinate system. d double Nominal diameter of the tube. e double Modulus of elasticity of the tube wall. h double Thickness of tube wall. l double Length of the tube. m int Number of cells for discretization. The values are calculated in the cell centers. preference double (optional) Default: 0 . Reference pressure. rhof double Density of the fluid.","title":"Solver parameters"},{"location":"python.html#tube-structure-solver","text":"This structure solver calculates the deformation of the wall of a straight and flexible tube. The type for this solver wrapper is solver_wrappers.python.tube_structure_solver . In this model inertia is taken into account, but still only radial displacement is considered. The required input is the pressure on the tube wall. Traction is not taken into account, even though it is a required variable in interface_input . The resulting output is the radial displacement. For the other components of displacement, zero is returned. The deformation of the tube in the radial direction is determined by $$ \\rho_s h\\frac{\\partial^2 r}{\\partial t^2}+b_1\\frac{\\partial^4 r}{\\partial z^4}-b_2\\frac{\\partial^2 r}{\\partial z^2}+b_3(r-r_o)=p-p_o $$ with \\rho_s \\rho_s the solid density and h h the thickness of the tube wall. Further, r r is the inner radius, p p pressure and t t time. The variables r_0 r_0 and p_0 p_0 are a reference radius and pressure, respectively. The parameters b_1 b_1 and b_2 b_2 ( b_1, b_2 \\ge 0 b_1, b_2 \\ge 0 ) account for the inner action of the bending and the axial tension in the wall, while the parameter b_3 b_3 accounts for the circumferential stress in the tube wall. For a thin-walled tube that is clamped in the axial direction, they are defined as $$ b_1=\\frac{hE}{1-\\nu^2}\\frac{h^2}{12} \\textrm{, } b_2=\\frac{hE}{1-\\nu^2}\\frac{h^2}{12}\\frac{2\\nu}{r_o^2} \\textrm{ and } b_3=\\frac{hE}{1-\\nu^2}\\frac{1}{r_o^2}+\\frac{hE}{1-\\nu^2}\\frac{h^2}{12}\\frac{1}{r_o^4} $$ with E E the Young's modulus and \\nu \\nu Poisson's coefficient. The second term of b_3 b_3 is considered small compared to the first one because h\\ll r_o h\\ll r_o and is thus neglected. Discretizing these equations results in a system of linear algebraic equations with a Jacobian that does not depend on the pressure. The system can be solved for the radius in one step. The tube is considered clamped at both ends. This boundary condition is imposed by adding four equations: two at the inlet and two at the outlet. For more information about the implementation of this solver refer to [ 1 ]. In this work the Newmark-beta time discretization is used. Here, however, backward Euler time discretization is used as well. For the Newmark-beta time discretization, two Newmark parameters \\beta \\beta and \\gamma \\gamma are required, which result in an unconditionally stable integration scheme if $$ \\gamma\\geq\\frac{1}{2} \\textrm{ and } \\beta\\geq\\frac{1}{4}\\left(\\frac{1}{2}+\\gamma\\right)^2. $$ Typical values are \\gamma \\gamma equal to 1/2 and \\beta \\beta equal to 1/4. A different time discretization for flow and structure can lead to difficulties for strongly coupled problems, especially looking at the resulting pressure distributions. As most flow solvers are discretized using the backward Euler method, it is advised to chose the same method for the structure solver (the time discretization of SolverWrapperTubeFlowSolver is also backward Euler). This avoids the occurrence of spurious oscillations of the pressure in time [ 3 ].","title":"Tube structure solver"},{"location":"python.html#solver-parameters_2","text":"The following parameters, listed in alphabetical order, need to be specified in a file with name input_file .This file should be located in the working_directory . Care should be taken that the values of d , e , h , l and rhof match the corresponding values of the flow solver. parameter type description axial_offset double (optional) Default: 0 . Distance over which tube is displaced axially in the coordinate system. beta double (optional) Newmark parameter \\beta \\beta . Only required when the Newmark-beta time discretization is used. d double Nominal diameter of the tube. e double Modulus of elasticity of the tube wall. h double Thickness of the tube wall. gamma double (optional) Newmark parameter \\gamma \\gamma . Only required when the Newmark-beta time discretization is used. l double Length of the tube. m int Number of cells for discretization. The values are calculated in the cell centers. nu double Poisson's ratio. preference double (optional) Default: 0 . Reference pressure. rhof double Density of the fluid. rhos double Density of the tube wall. time_disretization string (optional) Default: backward Euler . Specifies the time discretiation: either Newmark or backward Euler . Not case sensitive.","title":"Solver parameters"},{"location":"python.html#references","text":"[1] Degroote J., Annerel S. and Vierendeels J., \"Stability analysis of Gauss-Seidel iterations in a partitioned simulation of fluid-structure interaction\", Computers & Structures, vol. 88, no. 5-6, pp. 263, 2010. [2] Degroote J., Bruggeman P., Haelterman R., Vierendeels J., \"Stability of a coupling technique for partitioned solvers in FSI applications\", Computers & Structures, vol. 86, no. 23\u201324, pp. 2224\u20132234, 2008. [3] Vierendeels J., Dumont K., Dick E., Verdonck P., \"Analysis and stabilization of fluid-structure interaction algorithm for rigid-body motion\", American Institute of Aeronautics and Astronautics Journal\", vol. 43, no. 12, pp. 2549\u20132557, 2005.","title":"References"},{"location":"solver_wrappers.html","text":"Solver wrappers The goal of solver wrappers is to provide communication with the solvers. This means that a solver wrapper must implement a way to communicate input to the solver (at the fluid-structure interface), run the solver with the provided input and obtain the solution from the solver (at the fluid-structure interface). Important : To avoid conflicts, each solver is run in its own environment. These environments are established on runtime, but the actions required to do so can differ between systems. Therefore it is necessary to first check (and if needed adapt) the file coconut/solver_modules.py after installing or updating CoCoNuT, as described in the front documentation page . As each solver is different, the solver wrappers are highly customized too. Nevertheless, they all inherit from the Component class and must all implement the following methods: initialize , initialize_solution_step , solve_solution_step , finalize_solution_step , finalize , get_interface_input and get_interface_output . Upon instantiation of the solver wrapper object, the solver wrapper has to create a Model containing one or more ModelParts which correspond to (a part of) the fluid-structure interface. The interface coordinates at time step 0 should be stored in the ModelPart , even for a simulation that is restarted from a later time step, in order to have consistent mapping over restarts. The solve_solution_step method is called in each coupling iteration by the coupled solver, which provides input data stored in an Interface object. The solver wrapper extracts the data and supplies it to the actual solver, starts the calculation and reads the output data when the solver has finished. The solver wrapper then returns this data to the coupled solver as an Interface object. Available solver wrappers There are currently two solver wrappers for computational fluid dynamics (CFD) packages: ANSYS Fluent (2019R1, 2019R2, 2019R3, 2020R1) OpenFOAM (4.1) There are currently also two solver wrappers for computational structural mechanics (CSM) packages : Abaqus (6.14) Kratos Multiphysics (6.0) CoCoNuT also implements several 1D Python-based solver wrappers to provide a fast and easy way to test new algorithms and implementations. These are: Tube flow solver Tube structure solver Tube ringmodel solver","title":"General"},{"location":"solver_wrappers.html#solver-wrappers","text":"The goal of solver wrappers is to provide communication with the solvers. This means that a solver wrapper must implement a way to communicate input to the solver (at the fluid-structure interface), run the solver with the provided input and obtain the solution from the solver (at the fluid-structure interface). Important : To avoid conflicts, each solver is run in its own environment. These environments are established on runtime, but the actions required to do so can differ between systems. Therefore it is necessary to first check (and if needed adapt) the file coconut/solver_modules.py after installing or updating CoCoNuT, as described in the front documentation page . As each solver is different, the solver wrappers are highly customized too. Nevertheless, they all inherit from the Component class and must all implement the following methods: initialize , initialize_solution_step , solve_solution_step , finalize_solution_step , finalize , get_interface_input and get_interface_output . Upon instantiation of the solver wrapper object, the solver wrapper has to create a Model containing one or more ModelParts which correspond to (a part of) the fluid-structure interface. The interface coordinates at time step 0 should be stored in the ModelPart , even for a simulation that is restarted from a later time step, in order to have consistent mapping over restarts. The solve_solution_step method is called in each coupling iteration by the coupled solver, which provides input data stored in an Interface object. The solver wrapper extracts the data and supplies it to the actual solver, starts the calculation and reads the output data when the solver has finished. The solver wrapper then returns this data to the coupled solver as an Interface object.","title":"Solver wrappers"},{"location":"solver_wrappers.html#available-solver-wrappers","text":"There are currently two solver wrappers for computational fluid dynamics (CFD) packages: ANSYS Fluent (2019R1, 2019R2, 2019R3, 2020R1) OpenFOAM (4.1) There are currently also two solver wrappers for computational structural mechanics (CSM) packages : Abaqus (6.14) Kratos Multiphysics (6.0) CoCoNuT also implements several 1D Python-based solver wrappers to provide a fast and easy way to test new algorithms and implementations. These are: Tube flow solver Tube structure solver Tube ringmodel solver","title":"Available solver wrappers"},{"location":"test_single_solver.html","text":"Example case to test individual solvers This example shows how the separate solvers or their cases in the respective working directories can be tested individually using test_single_solver as coupling component. For more information refer to coupled_solvers . Coupling algorithm The type is set to coupled_solvers.test_single_solver and an additional required dictionary test_settings is added. All other parameters in the JSON file, including the settings dictionary, can be set to the values that will be used in the actual coupled simulation. The settings dictionary is used to look up delta_t , timestep_start , save_results and name if not provided in test_settings . The other dictionaries are not used: no predictor , convergence_criterion or mapper are used. Solvers If you run this case as is, the Fluent case and solver will be tested, as the solver_index is set to 0 in test_settings . In that case the Abaqus settings won't be used. The Abaqus case can easily be tested by changing this value to 1, then the Fluent settings will not be used. The index refers to the index of the respective solver in the solver_wrappers list in the JSON file. Dummy solver Even though the presence of dummy_solver.py with a test class is not strictly required, it can be very valuable because it allows to have a non-zero input. The file included in this case provides an example. It contains, among others, SimpleTest , TransientTest and InterpolatedData to illustrate how variables can be defined based on undeformed coordinates ( x , y , z ) and time step ( n ). Note that the number of classes defined is not restricted. Also note that the __init__() method can be used to avoid repeating the same calculations multiple times. The name of the class that one wants to use should be specified in the JSON file. In this example the TransientTest is used. Each class contains function definitions with a pre-formatted name calculate_<variable>(x,y,z,n) , with <variable> being the variable(s) required by the tested solver, e.g. displacement , pressure or traction . How these variables are defined inside these methods, is up to the user. However, the methods need to return the right format: a 3-element list or numpy array for vector variables and a 1-element list or numpy array for scalar variables.","title":"Test single solver"},{"location":"test_single_solver.html#example-case-to-test-individual-solvers","text":"This example shows how the separate solvers or their cases in the respective working directories can be tested individually using test_single_solver as coupling component. For more information refer to coupled_solvers .","title":"Example case to test individual solvers"},{"location":"test_single_solver.html#coupling-algorithm","text":"The type is set to coupled_solvers.test_single_solver and an additional required dictionary test_settings is added. All other parameters in the JSON file, including the settings dictionary, can be set to the values that will be used in the actual coupled simulation. The settings dictionary is used to look up delta_t , timestep_start , save_results and name if not provided in test_settings . The other dictionaries are not used: no predictor , convergence_criterion or mapper are used.","title":"Coupling algorithm"},{"location":"test_single_solver.html#solvers","text":"If you run this case as is, the Fluent case and solver will be tested, as the solver_index is set to 0 in test_settings . In that case the Abaqus settings won't be used. The Abaqus case can easily be tested by changing this value to 1, then the Fluent settings will not be used. The index refers to the index of the respective solver in the solver_wrappers list in the JSON file.","title":"Solvers"},{"location":"test_single_solver.html#dummy-solver","text":"Even though the presence of dummy_solver.py with a test class is not strictly required, it can be very valuable because it allows to have a non-zero input. The file included in this case provides an example. It contains, among others, SimpleTest , TransientTest and InterpolatedData to illustrate how variables can be defined based on undeformed coordinates ( x , y , z ) and time step ( n ). Note that the number of classes defined is not restricted. Also note that the __init__() method can be used to avoid repeating the same calculations multiple times. The name of the class that one wants to use should be specified in the JSON file. In this example the TransientTest is used. Each class contains function definitions with a pre-formatted name calculate_<variable>(x,y,z,n) , with <variable> being the variable(s) required by the tested solver, e.g. displacement , pressure or traction . How these variables are defined inside these methods, is up to the user. However, the methods need to return the right format: a 3-element list or numpy array for vector variables and a 1-element list or numpy array for scalar variables.","title":"Dummy solver"},{"location":"tests.html","text":"Tests Idea Unit tests are particularly important to developers to debug their code separately from other coupling components. These unit tests also offer an opportunity to quickly check whether or not the installation of the package was successful, as mentioned on the start page . The remainder of this documentation page focuses on running these tests. The first section explains the procedure to run (almost) all tests at once, which is useful for the post-installation test. The second section contains information on how to include the unit test of a solver wrapper in the testing framework. Finally, it is explained how to run a single test file, test class or test method. The latter is useful in the development of a new solver wrappers to quickly test a single aspect of the wrapper without having to test all aspects together, which can be time consuming. Running unit tests Running unit tests The unit tests in CoCoNuT uses the unittest module available in Python. To run the default collection of tests which evaluates in a matter of seconds, navigate to the coconut/tests/ directory and type following command in the terminal: python run_test.py This command will run all tests excluding the solver wrapper tests that are not pure Python. These tests are excluded because they each take several minutes to complete. The above command is equivalent to python run_test.py -fast It is equally possible to run all test by using the keyword -all as follows python run_test.py -all Besides these two predefined keywords, it is also possible to use (a set of) arbitrary keywords. For example python run_test.py fluent abaqus will run all tests that have the fluent or abaqus in its path: e.g. coconut.tests.solver_wrappers.fluent.test_v2019R1.test_move_nodes . Besides the method of running tests explained above, it is also possible to use commands of the form python -m unittest -bv Here, the keyword discover is assumed silently and all unit tests in modules named test*.py will be looked for. It will recursively find all the test files with this pattern for all the folders containing an __init__.py _ file. The -b keyword suppresses any output generated by the part of the code that is being tested, unless an error occurs or a test fails. Finally, the -v keyword enables a higher verbosity, as such the user can see what test methods have been run. Further documentation on the Python unit test framework can be found on the Python documentation website . Running a specific unit test separately The Python unit test framework allows for running the test separately as well. This is particularly useful for the unit tests of the solver wrappers, as they generally take a bit longer to run. There are two possibilities: running a test on the level of a file, or on the level of the class or even a method. While in many cases it is not required, it is sometimes needed to start the test from the coconut/tests/ directory! If not, errors will occur due to erroneous paths, especially in the tests of a solver wrapper. Let us consider the Abaqus unit test as an example. It is located in coconut/tests/solver_wrappers/abaqus/test_v614.py . In this file there are two test classes: TestSolverWrapperAbaqus614Tube2D and TestSolverWrapperAbaqus614Tube3D , which inherit from the former. Within these test classes, four test methods are run: test_repeat_iteration , test_restart , test_partitioning and test_shear . The other two methods, setUpClass and setUp , are run just before each test class and test method, respectively. If one wants to test this entire file, type following command in the terminal: python -m unittest -bv solver_wrappers/abaqus/test_v614.py This will run both test classes and all four test methods for each test class. The -b and -v keywords have the same meaning as above. If one wants to test for example only the 2D test class, type the following command in the terminal: python -m unittest -bv solver_wrappers.abaqus.test_v614.TestSolverWrapperAbaqus614Tube2D Note the . instead of the / to separate the folders since now classes are considered rather than files. This command will cause Python to run all four test methods from the 2D test class. Finally, it is also possible to run a single test method as well. Consider one wants to test only the correct partitioning of the Abaqus solver over multiple cores in the 3D test class, type following command in the terminal: python -m unittest -bv solver_wrappers.abaqus.test_v614.TestSolverWrapperAbaqus614Tube3D.test_partitioning Here, only the test method test_partitioning is run in the TestSolverWrapperAbaqus614Tube3D class. What if solver software is not available If a solver wrapper test is run, but the software is not available, the test will automatically be skipped and the non-availability wil be given as the reason. The availability of software is checked using the solver_modules.py file.","title":"Tests"},{"location":"tests.html#tests","text":"","title":"Tests"},{"location":"tests.html#idea","text":"Unit tests are particularly important to developers to debug their code separately from other coupling components. These unit tests also offer an opportunity to quickly check whether or not the installation of the package was successful, as mentioned on the start page . The remainder of this documentation page focuses on running these tests. The first section explains the procedure to run (almost) all tests at once, which is useful for the post-installation test. The second section contains information on how to include the unit test of a solver wrapper in the testing framework. Finally, it is explained how to run a single test file, test class or test method. The latter is useful in the development of a new solver wrappers to quickly test a single aspect of the wrapper without having to test all aspects together, which can be time consuming.","title":"Idea"},{"location":"tests.html#running-unit-tests","text":"","title":"Running unit tests"},{"location":"tests.html#running-unit-tests_1","text":"The unit tests in CoCoNuT uses the unittest module available in Python. To run the default collection of tests which evaluates in a matter of seconds, navigate to the coconut/tests/ directory and type following command in the terminal: python run_test.py This command will run all tests excluding the solver wrapper tests that are not pure Python. These tests are excluded because they each take several minutes to complete. The above command is equivalent to python run_test.py -fast It is equally possible to run all test by using the keyword -all as follows python run_test.py -all Besides these two predefined keywords, it is also possible to use (a set of) arbitrary keywords. For example python run_test.py fluent abaqus will run all tests that have the fluent or abaqus in its path: e.g. coconut.tests.solver_wrappers.fluent.test_v2019R1.test_move_nodes . Besides the method of running tests explained above, it is also possible to use commands of the form python -m unittest -bv Here, the keyword discover is assumed silently and all unit tests in modules named test*.py will be looked for. It will recursively find all the test files with this pattern for all the folders containing an __init__.py _ file. The -b keyword suppresses any output generated by the part of the code that is being tested, unless an error occurs or a test fails. Finally, the -v keyword enables a higher verbosity, as such the user can see what test methods have been run. Further documentation on the Python unit test framework can be found on the Python documentation website .","title":"Running unit tests"},{"location":"tests.html#running-a-specific-unit-test-separately","text":"The Python unit test framework allows for running the test separately as well. This is particularly useful for the unit tests of the solver wrappers, as they generally take a bit longer to run. There are two possibilities: running a test on the level of a file, or on the level of the class or even a method. While in many cases it is not required, it is sometimes needed to start the test from the coconut/tests/ directory! If not, errors will occur due to erroneous paths, especially in the tests of a solver wrapper. Let us consider the Abaqus unit test as an example. It is located in coconut/tests/solver_wrappers/abaqus/test_v614.py . In this file there are two test classes: TestSolverWrapperAbaqus614Tube2D and TestSolverWrapperAbaqus614Tube3D , which inherit from the former. Within these test classes, four test methods are run: test_repeat_iteration , test_restart , test_partitioning and test_shear . The other two methods, setUpClass and setUp , are run just before each test class and test method, respectively. If one wants to test this entire file, type following command in the terminal: python -m unittest -bv solver_wrappers/abaqus/test_v614.py This will run both test classes and all four test methods for each test class. The -b and -v keywords have the same meaning as above. If one wants to test for example only the 2D test class, type the following command in the terminal: python -m unittest -bv solver_wrappers.abaqus.test_v614.TestSolverWrapperAbaqus614Tube2D Note the . instead of the / to separate the folders since now classes are considered rather than files. This command will cause Python to run all four test methods from the 2D test class. Finally, it is also possible to run a single test method as well. Consider one wants to test only the correct partitioning of the Abaqus solver over multiple cores in the 3D test class, type following command in the terminal: python -m unittest -bv solver_wrappers.abaqus.test_v614.TestSolverWrapperAbaqus614Tube3D.test_partitioning Here, only the test method test_partitioning is run in the TestSolverWrapperAbaqus614Tube3D class.","title":"Running a specific unit test separately"},{"location":"tests.html#what-if-solver-software-is-not-available","text":"If a solver wrapper test is run, but the software is not available, the test will automatically be skipped and the non-availability wil be given as the reason. The availability of software is checked using the solver_modules.py file.","title":"What if solver software is not available"},{"location":"tube_fluent2d_abaqus2d.html","text":"Tube case with Fluent2D and Abaqus2D This example calculates the flow inside and the deformation and stresses of a straight flexible tube, where a pressure pulse is applied at the inlet. This done by using Fluent and Abaqus, both on an axisymmetric case. Coupling algorithm The coupling technique used is the interface quasi-Newton algorithm with an approximation for the inverse of the Jacobian from a least-squares model (IQNI-LS). Predictor The initial guess in every time step is done using the linear predictor. Convergence criterion Two convergence criteria have been specified: The number of iterations in every time step is larger than 10. The residual norm on the displacement is a factor 10^{-4} 10^{-4} lower than the initial value. When either criterion is satisfied the simulation stops. Solvers The flow solver is Fluent, used to solve an axisymmetric representation of the tube, with 100 cells on the fluid-structure interface. When setting up the case, the mesh is build based on the file mesh.jou using Gambit. The displacements are applied in the nodes, of which there are 101. In contrast, the loads (pressure and traction) are calculated in the cell centers, of which there are 100. The axial direction is along the x-axis, the radial direction along the y-axis. The setup script runs Fluent with the case.jou journal file to setup the case parameters, starting from the mesh file mesh_tube2d.msh . This case is written to the case_tube2d.cas file, which serves as input for CoCoNuT. Additionally, a folder create_mesh is provided containing a script to create the mesh in Gambit using a journal file. The mesh can be created by running the script create_mesh.sh , given that Gambit v2.4.6 is available. The structure solver is Abaqus, used to solve an axisymmetric representation of the tube, with 50 elements on the fluid-structure interface. The Abaqus case is built when setting up the case starting from the file mesh_tube2d.inp containing nodes and elements. This is done by running Abaqus with the make_inp.py Python script to set all parameters, such as surface definitions, material parameters, boundary conditions and time step information. The result of the setup is a completed input file case_tube2d.inp . The Abaqus element type used is CAX8RH. These are continuum elements for axisymmetric calculations, for stress and displacement without twist. They are: 8-node biquadratic, reduced integration, hybrid with linear pressure. See the Abaqus documentation for more information. The loads are applied on the faces in three points per element, which means on 150 load points in total. The displacement is calculated in the nodes. There are 101 nodes on the fluid-structure interface. The axial direction is along the y-axis, the radial direction along the x-axis. The difference in reference frames and number of cells on the fluid-structure interface requires the use of mappers. In the structure solver wrapper, a permutation mapper is introduced to match the coordinate frames, flipping the x- and y-axis of the input. Thereafter, a linear interpolation mapper is used to interpolate in the x- and y-direction from the 100 cell centers of Fluent to the 150 load points in Abaqus. For the output the same is done in the opposite order: first interpolating and then flipping the axes.","title":"Fluent 2D - Abaqus 2D"},{"location":"tube_fluent2d_abaqus2d.html#tube-case-with-fluent2d-and-abaqus2d","text":"This example calculates the flow inside and the deformation and stresses of a straight flexible tube, where a pressure pulse is applied at the inlet. This done by using Fluent and Abaqus, both on an axisymmetric case.","title":"Tube case with Fluent2D and Abaqus2D"},{"location":"tube_fluent2d_abaqus2d.html#coupling-algorithm","text":"The coupling technique used is the interface quasi-Newton algorithm with an approximation for the inverse of the Jacobian from a least-squares model (IQNI-LS).","title":"Coupling algorithm"},{"location":"tube_fluent2d_abaqus2d.html#predictor","text":"The initial guess in every time step is done using the linear predictor.","title":"Predictor"},{"location":"tube_fluent2d_abaqus2d.html#convergence-criterion","text":"Two convergence criteria have been specified: The number of iterations in every time step is larger than 10. The residual norm on the displacement is a factor 10^{-4} 10^{-4} lower than the initial value. When either criterion is satisfied the simulation stops.","title":"Convergence criterion"},{"location":"tube_fluent2d_abaqus2d.html#solvers","text":"The flow solver is Fluent, used to solve an axisymmetric representation of the tube, with 100 cells on the fluid-structure interface. When setting up the case, the mesh is build based on the file mesh.jou using Gambit. The displacements are applied in the nodes, of which there are 101. In contrast, the loads (pressure and traction) are calculated in the cell centers, of which there are 100. The axial direction is along the x-axis, the radial direction along the y-axis. The setup script runs Fluent with the case.jou journal file to setup the case parameters, starting from the mesh file mesh_tube2d.msh . This case is written to the case_tube2d.cas file, which serves as input for CoCoNuT. Additionally, a folder create_mesh is provided containing a script to create the mesh in Gambit using a journal file. The mesh can be created by running the script create_mesh.sh , given that Gambit v2.4.6 is available. The structure solver is Abaqus, used to solve an axisymmetric representation of the tube, with 50 elements on the fluid-structure interface. The Abaqus case is built when setting up the case starting from the file mesh_tube2d.inp containing nodes and elements. This is done by running Abaqus with the make_inp.py Python script to set all parameters, such as surface definitions, material parameters, boundary conditions and time step information. The result of the setup is a completed input file case_tube2d.inp . The Abaqus element type used is CAX8RH. These are continuum elements for axisymmetric calculations, for stress and displacement without twist. They are: 8-node biquadratic, reduced integration, hybrid with linear pressure. See the Abaqus documentation for more information. The loads are applied on the faces in three points per element, which means on 150 load points in total. The displacement is calculated in the nodes. There are 101 nodes on the fluid-structure interface. The axial direction is along the y-axis, the radial direction along the x-axis. The difference in reference frames and number of cells on the fluid-structure interface requires the use of mappers. In the structure solver wrapper, a permutation mapper is introduced to match the coordinate frames, flipping the x- and y-axis of the input. Thereafter, a linear interpolation mapper is used to interpolate in the x- and y-direction from the 100 cell centers of Fluent to the 150 load points in Abaqus. For the output the same is done in the opposite order: first interpolating and then flipping the axes.","title":"Solvers"},{"location":"tube_fluent2d_abaqus2d_steady.html","text":"Tube case with Fluent2D and Abaqus2D - Steady This example calculates the flow inside and the deformation and stresses of a straight flexible tube, when a steady pressure difference is applied over the tube. This done by using Fluent and Abaqus, both on an axisymmetric case. The test example is similar in setup to tube_fluent2d_abaqus2d . The only difference is that a steady problem is simulated. Here the most important differences and peculiarities of a steady case are highlighted. General settings Although the calculation is steady, a delta_t is still required. Its value is arbitrary and usually 1.0 is used. timestep_start is required as well and is normally equal to 0. Coupling algorithm The coupling technique used is the interface quasi-Newton algorithm with an approximation for the inverse of the Jacobian from a least-squares model (IQNI-LS). The parameter q is not used no as there is only one time step. Note that in a steady calculation, the models ls (IQN-ILS) and mv (IQN-MVJ) are identical. Predictor A predictor is still required, but not used as only one time step is calculated. Solvers Of course the supplied case files in both Fluent and Abaqus also need to be steady. In Abaqus this can be done using a Static step, typically with subcycling enabled and and a linearly ramped load. The parameters subcycling and ramp are set to True in the json-file. As such Abaqus performs subiterations in each coupling iterations in which the load is increased linearly over the step. The parameters min_inc , initial_inc , max_num_inc and max_inc are used to determine its behaviour. The ramping does not occur in Abaqus itself as, amplitude references are ignored for nonuniform loads given by user subroutine DLOAD in an Abaqus/Standard analysis. Instead, the ramping is implemented in the DLOAD subroutine itself. For the first iteration of the first time step an initial load is required which is set to zero in the Abaqus wrapper.","title":"Fluent 2D - Abaqus 2D - Steady"},{"location":"tube_fluent2d_abaqus2d_steady.html#tube-case-with-fluent2d-and-abaqus2d-steady","text":"This example calculates the flow inside and the deformation and stresses of a straight flexible tube, when a steady pressure difference is applied over the tube. This done by using Fluent and Abaqus, both on an axisymmetric case. The test example is similar in setup to tube_fluent2d_abaqus2d . The only difference is that a steady problem is simulated. Here the most important differences and peculiarities of a steady case are highlighted.","title":"Tube case with Fluent2D and Abaqus2D - Steady"},{"location":"tube_fluent2d_abaqus2d_steady.html#general-settings","text":"Although the calculation is steady, a delta_t is still required. Its value is arbitrary and usually 1.0 is used. timestep_start is required as well and is normally equal to 0.","title":"General settings"},{"location":"tube_fluent2d_abaqus2d_steady.html#coupling-algorithm","text":"The coupling technique used is the interface quasi-Newton algorithm with an approximation for the inverse of the Jacobian from a least-squares model (IQNI-LS). The parameter q is not used no as there is only one time step. Note that in a steady calculation, the models ls (IQN-ILS) and mv (IQN-MVJ) are identical.","title":"Coupling algorithm"},{"location":"tube_fluent2d_abaqus2d_steady.html#predictor","text":"A predictor is still required, but not used as only one time step is calculated.","title":"Predictor"},{"location":"tube_fluent2d_abaqus2d_steady.html#solvers","text":"Of course the supplied case files in both Fluent and Abaqus also need to be steady. In Abaqus this can be done using a Static step, typically with subcycling enabled and and a linearly ramped load. The parameters subcycling and ramp are set to True in the json-file. As such Abaqus performs subiterations in each coupling iterations in which the load is increased linearly over the step. The parameters min_inc , initial_inc , max_num_inc and max_inc are used to determine its behaviour. The ramping does not occur in Abaqus itself as, amplitude references are ignored for nonuniform loads given by user subroutine DLOAD in an Abaqus/Standard analysis. Instead, the ramping is implemented in the DLOAD subroutine itself. For the first iteration of the first time step an initial load is required which is set to zero in the Abaqus wrapper.","title":"Solvers"},{"location":"tube_fluent2d_tube_structure.html","text":"Tube case with Fluent2D and TubeStructure This example calculates the flow inside and the deformation and stresses of a straight flexible tube, where a pressure pulse is applied at the inlet. This done by using Fluent (axisymmetric) and the Python solver TubeStructure. Coupling algorithm The coupling technique used is the interface quasi-Newton algorithm with an approximation for the inverse of the Jacobian from a least-squares model (IQNI-LS). Predictor The initial guess in every time step is done using the linear predictor. Convergence criterion Two convergence criteria have been specified: The number of iterations in every time step is larger than 15. The residual norm on the displacement is a factor 10^{-6} 10^{-6} lower than the initial value. When either criterion is satisfied the simulation stops. Solvers The flow solver is Fluent, used to solve an axisymmetric representation of the tube, with 100 cells on the fluid-structure interface. When setting up the case, the mesh is build based on the file mesh.jou using Gambit. The displacements are applied in the nodes, of which there are 101. In contrast, the loads (pressure and traction) are calculated in the cell centers, of which there are 100. The axial direction is along the x-axis, the radial direction along the y-axis. The setup script runs Fluent with the case.jou journal file to setup the case parameters, starting from the mesh file mesh_tube2d.msh . This case is written to the case_tube2d.cas file, which serves as input for CoCoNuT. Additionally, a folder create_mesh is provided containing a script to create the mesh in Gambit using a journal file. The mesh can be created by running the script create_mesh.sh , given that Gambit v2.4.6 is available. The structure solver is the Python solver TubeStructure, which implements a 1D model of the tube wall, with 100 elements on the fluid-structure interface. The parameters for this model are specified in the setup folder by the file solver_parameters.json . The loads, in fact only pressure for this 1D case, are applied on the cell centers. The displacements are calculated in the cell centers as well. Only the radial displacement is different from zero. The axial direction is along the z-axis, the radial direction along the y-axis. The difference in reference frames and number of cells on the fluid-structure interface requires the use of mappers. In the structure solver wrapper, a permutation mapper is introduced to match the coordinate frames, flipping the x- and z-axis of the input. Thereafter, a linear interpolation mapper is used to interpolate in the y- and z-direction from the 100 cell centers of Fluent to the 100 cell centers of TubeStructure. For the output the same is done in the opposite order: first interpolating and then flipping the axes.","title":"Fluent 2D - Python TubeStructure"},{"location":"tube_fluent2d_tube_structure.html#tube-case-with-fluent2d-and-tubestructure","text":"This example calculates the flow inside and the deformation and stresses of a straight flexible tube, where a pressure pulse is applied at the inlet. This done by using Fluent (axisymmetric) and the Python solver TubeStructure.","title":"Tube case with Fluent2D and TubeStructure"},{"location":"tube_fluent2d_tube_structure.html#coupling-algorithm","text":"The coupling technique used is the interface quasi-Newton algorithm with an approximation for the inverse of the Jacobian from a least-squares model (IQNI-LS).","title":"Coupling algorithm"},{"location":"tube_fluent2d_tube_structure.html#predictor","text":"The initial guess in every time step is done using the linear predictor.","title":"Predictor"},{"location":"tube_fluent2d_tube_structure.html#convergence-criterion","text":"Two convergence criteria have been specified: The number of iterations in every time step is larger than 15. The residual norm on the displacement is a factor 10^{-6} 10^{-6} lower than the initial value. When either criterion is satisfied the simulation stops.","title":"Convergence criterion"},{"location":"tube_fluent2d_tube_structure.html#solvers","text":"The flow solver is Fluent, used to solve an axisymmetric representation of the tube, with 100 cells on the fluid-structure interface. When setting up the case, the mesh is build based on the file mesh.jou using Gambit. The displacements are applied in the nodes, of which there are 101. In contrast, the loads (pressure and traction) are calculated in the cell centers, of which there are 100. The axial direction is along the x-axis, the radial direction along the y-axis. The setup script runs Fluent with the case.jou journal file to setup the case parameters, starting from the mesh file mesh_tube2d.msh . This case is written to the case_tube2d.cas file, which serves as input for CoCoNuT. Additionally, a folder create_mesh is provided containing a script to create the mesh in Gambit using a journal file. The mesh can be created by running the script create_mesh.sh , given that Gambit v2.4.6 is available. The structure solver is the Python solver TubeStructure, which implements a 1D model of the tube wall, with 100 elements on the fluid-structure interface. The parameters for this model are specified in the setup folder by the file solver_parameters.json . The loads, in fact only pressure for this 1D case, are applied on the cell centers. The displacements are calculated in the cell centers as well. Only the radial displacement is different from zero. The axial direction is along the z-axis, the radial direction along the y-axis. The difference in reference frames and number of cells on the fluid-structure interface requires the use of mappers. In the structure solver wrapper, a permutation mapper is introduced to match the coordinate frames, flipping the x- and z-axis of the input. Thereafter, a linear interpolation mapper is used to interpolate in the y- and z-direction from the 100 cell centers of Fluent to the 100 cell centers of TubeStructure. For the output the same is done in the opposite order: first interpolating and then flipping the axes.","title":"Solvers"},{"location":"tube_fluent3d_abaqus2d.html","text":"Tube case with Fluent3D and Abaqus2D This example calculates the flow inside and the deformation and stresses of a straight flexible tube, where a pressure pulse is applied at the inlet. This done by using Fluent (3D case) and Abaqus (axisymmetric case). Coupling algorithm The coupling technique used is the interface quasi-Newton algorithm with an approximation for the inverse of the Jacobian from a least-squares model (IQNI-LS). Predictor The initial guess in every time step is done using the linear predictor. Convergence criterion Two convergence criteria have been specified: The number of iterations in every time step is larger than 20. The residual norm on the displacement is a factor 10^{-3} 10^{-3} lower than the initial value. When either criterion is satisfied the simulation stops. Solvers The flow solver is Fluent, used to solve a fully 3D tube, with 48 cells on the fluid-structure interface in the length-wise direction and 8 in the circumferential direction. When setting up the case, the mesh is build based on the file mesh.jou using Gambit. The displacements are applied in the nodes. In contrast, the loads (pressure and traction) are calculated in the cell centers. The axial direction is along the x-axis. The setup script runs Fluent with the case.jou journal file to setup the case parameters, starting from the mesh file mesh_tube3d.msh . This case is written to the case_tube3d.cas file, which serves as input for CoCoNuT. Additionally, a folder create_mesh is provided containing a script to create the mesh in Gambit using a journal file. The mesh can be created by running the script create_mesh.sh , given that Gambit v2.4.6 is available. The structure solver is Abaqus, used to solve an axisymmetric representation of the tube, with 50 elements on the fluid-structure interface. The Abaqus case is built when setting up the case starting from the file mesh_tube2d.inp containing nodes and elements. This is done by running Abaqus with the make_inp.py Python script to set all parameters, such as surface definitions, material parameters, boundary conditions and time step information. The result of the setup is a completed input file case_tube2d.inp . The Abaqus element type used is CAX8RH. These are continuum elements for axisymmetric calculations, for stress and displacement without twist. They are: 8-node biquadratic, reduced integration, hybrid with linear pressure. See the Abaqus documentation for more information. The loads are applied on the faces in three points per element, which means on 150 load points in total. The displacement is calculated in the nodes. There are 101 nodes on the fluid-structure interface. The axial direction is along the y-axis, the radial direction along the x-axis. The difference in reference frames and number of cells on the fluid-structure interface, but also the difference in dimensions require the use of mappers, In the structure solver wrapper, a permutation mapper is introduced to match the coordinate frames, flipping the x- and y-axis of the input. Thereafter, a radial basis mapper is used to interpolate in the x-, y- and z-direction from the loads coming from Fluent to a temporary 3D interface corresponding to Abaqus. Finally a mapper is added to go from 3D to 2D. For the output the same is done in the opposite order: first going from 2D to 3D, then interpolating and finally flipping the axes.","title":"Fluent 3D - Abaqus 2D"},{"location":"tube_fluent3d_abaqus2d.html#tube-case-with-fluent3d-and-abaqus2d","text":"This example calculates the flow inside and the deformation and stresses of a straight flexible tube, where a pressure pulse is applied at the inlet. This done by using Fluent (3D case) and Abaqus (axisymmetric case).","title":"Tube case with Fluent3D and Abaqus2D"},{"location":"tube_fluent3d_abaqus2d.html#coupling-algorithm","text":"The coupling technique used is the interface quasi-Newton algorithm with an approximation for the inverse of the Jacobian from a least-squares model (IQNI-LS).","title":"Coupling algorithm"},{"location":"tube_fluent3d_abaqus2d.html#predictor","text":"The initial guess in every time step is done using the linear predictor.","title":"Predictor"},{"location":"tube_fluent3d_abaqus2d.html#convergence-criterion","text":"Two convergence criteria have been specified: The number of iterations in every time step is larger than 20. The residual norm on the displacement is a factor 10^{-3} 10^{-3} lower than the initial value. When either criterion is satisfied the simulation stops.","title":"Convergence criterion"},{"location":"tube_fluent3d_abaqus2d.html#solvers","text":"The flow solver is Fluent, used to solve a fully 3D tube, with 48 cells on the fluid-structure interface in the length-wise direction and 8 in the circumferential direction. When setting up the case, the mesh is build based on the file mesh.jou using Gambit. The displacements are applied in the nodes. In contrast, the loads (pressure and traction) are calculated in the cell centers. The axial direction is along the x-axis. The setup script runs Fluent with the case.jou journal file to setup the case parameters, starting from the mesh file mesh_tube3d.msh . This case is written to the case_tube3d.cas file, which serves as input for CoCoNuT. Additionally, a folder create_mesh is provided containing a script to create the mesh in Gambit using a journal file. The mesh can be created by running the script create_mesh.sh , given that Gambit v2.4.6 is available. The structure solver is Abaqus, used to solve an axisymmetric representation of the tube, with 50 elements on the fluid-structure interface. The Abaqus case is built when setting up the case starting from the file mesh_tube2d.inp containing nodes and elements. This is done by running Abaqus with the make_inp.py Python script to set all parameters, such as surface definitions, material parameters, boundary conditions and time step information. The result of the setup is a completed input file case_tube2d.inp . The Abaqus element type used is CAX8RH. These are continuum elements for axisymmetric calculations, for stress and displacement without twist. They are: 8-node biquadratic, reduced integration, hybrid with linear pressure. See the Abaqus documentation for more information. The loads are applied on the faces in three points per element, which means on 150 load points in total. The displacement is calculated in the nodes. There are 101 nodes on the fluid-structure interface. The axial direction is along the y-axis, the radial direction along the x-axis. The difference in reference frames and number of cells on the fluid-structure interface, but also the difference in dimensions require the use of mappers, In the structure solver wrapper, a permutation mapper is introduced to match the coordinate frames, flipping the x- and y-axis of the input. Thereafter, a radial basis mapper is used to interpolate in the x-, y- and z-direction from the loads coming from Fluent to a temporary 3D interface corresponding to Abaqus. Finally a mapper is added to go from 3D to 2D. For the output the same is done in the opposite order: first going from 2D to 3D, then interpolating and finally flipping the axes.","title":"Solvers"},{"location":"tube_fluent3d_abaqus3d.html","text":"Tube case with Fluent3D and Abaqus3D This example calculates the flow inside and the deformation and stresses of a straight flexible tube, where a pressure pulse is applied at the inlet. This done by using Fluent and Abaqus, both with a fully 3D case. Coupling algorithm The coupling technique used is the interface quasi-Newton algorithm with an approximation for the inverse of the Jacobian from a least-squares model (IQNI-LS). Predictor The initial guess in every time step is done using the linear predictor. Convergence criterion Two convergence criteria have been specified: The number of iterations in every time step is larger than 20. The residual norm on the displacement is a factor 10^{-3} 10^{-3} lower than the initial value. When either criterion is satisfied the simulation stops. Solvers The flow solver is Fluent, used to solve a fully 3D tube, with 48 cells on the fluid-structure interface in the length-wise direction and 8 in the circumferential direction. When setting up the case, the mesh is build based on the file mesh.jou using Gambit. The displacements are applied in the nodes. In contrast, the loads (pressure and traction) are calculated in the cell centers. The axial direction is along the x-axis. The setup script runs Fluent with the case.jou journal file to setup the case parameters, starting from the mesh file mesh_tube3d.msh . This case is written to the case_tube3d.cas file, which serves as input for CoCoNuT. Additionally, a folder create_mesh is provided containing a script to create the mesh in Gambit using a journal file. The mesh can be created by running the script create_mesh.sh , given that Gambit v2.4.6 is available. The structure solver is Abaqus, used to solve a fully 3D tube, with 12 elements on the fluid-structure interface in the length-wise direction and 8 in the circumferential direction. The Abaqus case is built when setting up the case starting from the file mesh_tube3d.inp containing nodes and elements. This is done by running Abaqus with the make_inp.py Python script to set all parameters, such as surface definitions, material parameters, boundary conditions and time step information. The result of the setup is a completed input file case_tube3d.inp . The Abaqus element type used is S8R. These are 8-node shell elements. The R refers to reduced integration. See the Abaqus documentation for more information. The loads are applied on the faces in 9 points per element, which means on 864 load points in total. The displacement is calculated in the nodes. There are 304 nodes on the fluid-structure interface. The axial direction is along the x-axis. The coordinate frames of both solvers are the same so there is no need for a permutation mapper. In contrast, the difference of the points where loads and displacements are applied or calculated, require the use of interpolation mappers. Therefore, a radial basis mapper is introduced in the structure solver to interpolate in the x-, y- and z-direction.","title":"Fluent 3D - Abaqus 3D"},{"location":"tube_fluent3d_abaqus3d.html#tube-case-with-fluent3d-and-abaqus3d","text":"This example calculates the flow inside and the deformation and stresses of a straight flexible tube, where a pressure pulse is applied at the inlet. This done by using Fluent and Abaqus, both with a fully 3D case.","title":"Tube case with Fluent3D and Abaqus3D"},{"location":"tube_fluent3d_abaqus3d.html#coupling-algorithm","text":"The coupling technique used is the interface quasi-Newton algorithm with an approximation for the inverse of the Jacobian from a least-squares model (IQNI-LS).","title":"Coupling algorithm"},{"location":"tube_fluent3d_abaqus3d.html#predictor","text":"The initial guess in every time step is done using the linear predictor.","title":"Predictor"},{"location":"tube_fluent3d_abaqus3d.html#convergence-criterion","text":"Two convergence criteria have been specified: The number of iterations in every time step is larger than 20. The residual norm on the displacement is a factor 10^{-3} 10^{-3} lower than the initial value. When either criterion is satisfied the simulation stops.","title":"Convergence criterion"},{"location":"tube_fluent3d_abaqus3d.html#solvers","text":"The flow solver is Fluent, used to solve a fully 3D tube, with 48 cells on the fluid-structure interface in the length-wise direction and 8 in the circumferential direction. When setting up the case, the mesh is build based on the file mesh.jou using Gambit. The displacements are applied in the nodes. In contrast, the loads (pressure and traction) are calculated in the cell centers. The axial direction is along the x-axis. The setup script runs Fluent with the case.jou journal file to setup the case parameters, starting from the mesh file mesh_tube3d.msh . This case is written to the case_tube3d.cas file, which serves as input for CoCoNuT. Additionally, a folder create_mesh is provided containing a script to create the mesh in Gambit using a journal file. The mesh can be created by running the script create_mesh.sh , given that Gambit v2.4.6 is available. The structure solver is Abaqus, used to solve a fully 3D tube, with 12 elements on the fluid-structure interface in the length-wise direction and 8 in the circumferential direction. The Abaqus case is built when setting up the case starting from the file mesh_tube3d.inp containing nodes and elements. This is done by running Abaqus with the make_inp.py Python script to set all parameters, such as surface definitions, material parameters, boundary conditions and time step information. The result of the setup is a completed input file case_tube3d.inp . The Abaqus element type used is S8R. These are 8-node shell elements. The R refers to reduced integration. See the Abaqus documentation for more information. The loads are applied on the faces in 9 points per element, which means on 864 load points in total. The displacement is calculated in the nodes. There are 304 nodes on the fluid-structure interface. The axial direction is along the x-axis. The coordinate frames of both solvers are the same so there is no need for a permutation mapper. In contrast, the difference of the points where loads and displacements are applied or calculated, require the use of interpolation mappers. Therefore, a radial basis mapper is introduced in the structure solver to interpolate in the x-, y- and z-direction.","title":"Solvers"},{"location":"tube_fluent3d_kratos_structure3d.html","text":"Tube case with Fluent3D and KratosStructure3D This example calculates the flow inside and the deformation and stresses of a straight flexible tube, where a pressure pulse is applied at the inlet. This done by using Fluent and StructuralMechanicsApplication of Kratos, both with a fully 3D case. Coupling algorithm The coupling technique used is the interface quasi-Newton algorithm with an approximation for the inverse of the Jacobian from a least-squares model (IQNI-LS). Predictor The initial guess in every time step is done using the linear predictor. Convergence criterion Two convergence criteria have been specified: The number of iterations in every time step is larger than 20. The residual norm on the displacement is a factor 10^{-3} 10^{-3} lower than the initial value. When either criterion is satisfied the simulation stops. Solvers The flow solver is Fluent, used to solve a fully 3D tube, with 48 cells on the fluid-structure interface in the length-wise direction and 8 in the circumferential direction. When setting up the case, the mesh is build based on the file mesh.jou using Gambit. The displacements are applied in the nodes. In contrast, the loads (pressure and traction) are calculated in the cell centers. The axial direction is along the x-axis. The setup script runs Fluent with the case.jou journal file to setup the case parameters, starting from the mesh file mesh_tube3d.msh . This case is written to the case_tube3d.cas file, which serves as input for CoCoNuT. Additionally, a folder create_mesh is provided containing a script to create the mesh in Gambit using a journal file. The mesh can be created by running the script create_mesh.sh , given that Gambit v2.4.6 is available. The structure solver is Kratos, used to solve a fully 3D tube, with 24 elements on the fluid-structure interface in the length-wise direction and 8 in the circumferential direction. The Kratos element type used is ShellThickElementCorotational3D4N. These are 4-node shell elements. The displacement and loads are calculated/applied on the nodes. There are 200 nodes on the fluid-structure interface. The axial direction is along the x-axis. The parameter file ProjectParameters.json is passed to CoCoNuT. The coordinate frames of both solvers are the same so there is no need for a permutation mapper. On the other hand, difference in the discretization between the fluid and the structure mesh requires the use of interpolation mappers. Therefore, a radial basis mapper is used to interpolate in the x-, y- and z-direction.","title":"Fluent 3D - Kratos Structure 3D"},{"location":"tube_fluent3d_kratos_structure3d.html#tube-case-with-fluent3d-and-kratosstructure3d","text":"This example calculates the flow inside and the deformation and stresses of a straight flexible tube, where a pressure pulse is applied at the inlet. This done by using Fluent and StructuralMechanicsApplication of Kratos, both with a fully 3D case.","title":"Tube case with Fluent3D and KratosStructure3D"},{"location":"tube_fluent3d_kratos_structure3d.html#coupling-algorithm","text":"The coupling technique used is the interface quasi-Newton algorithm with an approximation for the inverse of the Jacobian from a least-squares model (IQNI-LS).","title":"Coupling algorithm"},{"location":"tube_fluent3d_kratos_structure3d.html#predictor","text":"The initial guess in every time step is done using the linear predictor.","title":"Predictor"},{"location":"tube_fluent3d_kratos_structure3d.html#convergence-criterion","text":"Two convergence criteria have been specified: The number of iterations in every time step is larger than 20. The residual norm on the displacement is a factor 10^{-3} 10^{-3} lower than the initial value. When either criterion is satisfied the simulation stops.","title":"Convergence criterion"},{"location":"tube_fluent3d_kratos_structure3d.html#solvers","text":"The flow solver is Fluent, used to solve a fully 3D tube, with 48 cells on the fluid-structure interface in the length-wise direction and 8 in the circumferential direction. When setting up the case, the mesh is build based on the file mesh.jou using Gambit. The displacements are applied in the nodes. In contrast, the loads (pressure and traction) are calculated in the cell centers. The axial direction is along the x-axis. The setup script runs Fluent with the case.jou journal file to setup the case parameters, starting from the mesh file mesh_tube3d.msh . This case is written to the case_tube3d.cas file, which serves as input for CoCoNuT. Additionally, a folder create_mesh is provided containing a script to create the mesh in Gambit using a journal file. The mesh can be created by running the script create_mesh.sh , given that Gambit v2.4.6 is available. The structure solver is Kratos, used to solve a fully 3D tube, with 24 elements on the fluid-structure interface in the length-wise direction and 8 in the circumferential direction. The Kratos element type used is ShellThickElementCorotational3D4N. These are 4-node shell elements. The displacement and loads are calculated/applied on the nodes. There are 200 nodes on the fluid-structure interface. The axial direction is along the x-axis. The parameter file ProjectParameters.json is passed to CoCoNuT. The coordinate frames of both solvers are the same so there is no need for a permutation mapper. On the other hand, difference in the discretization between the fluid and the structure mesh requires the use of interpolation mappers. Therefore, a radial basis mapper is used to interpolate in the x-, y- and z-direction.","title":"Solvers"},{"location":"tube_openfoam3d_abaqus3d.html","text":"Tube case with OpenFOAM3D and Abaqus3D This example calculates the flow inside and the deformation and stresses of a straight flexible tube, where a pressure pulse is applied at the inlet. This done by using OpenFOAM and Abaqus, both with a fully 3D case. Coupling algorithm The coupling technique used is the interface quasi-Newton algorithm with an approximation for the inverse of the Jacobian from a least-squares model (IQNI-LS). Predictor The initial guess in every time step is done using the linear predictor. Convergence criterion Two convergence criteria have been specified: The number of iterations in every time step is larger than 20. The residual norm on the displacement is a factor 10^{-3} 10^{-3} lower than the initial value. When either criterion is satisfied the simulation stops. Solvers The flow solver is OpenFoam, used to solve a fully 3D tube, with 48 cells on the fluid-structure interface in the length-wise direction and 8 in the circumferential direction. When setting up the case, the mesh is build based on the file blockMeshDict . The displacements are applied in the nodes. In contrast, the loads (pressure and traction) are calculated in the cell centers. The axial direction is along the x-axis. When setting up the case using the setup.sh script, the solver coconut_pimpleFoam is compiled automatically. The structure solver is Abaqus, used to solve a fully 3D tube, with 12 elements on the fluid-structure interface in the length-wise direction and 8 in the circumferential direction. The Abaqus case is built when setting up the case starting from the file mesh_tube3d.inp containing nodes and elements. This is done by running Abaqus with the make_inp.py Python script to set all parameters, such as surface definitions, material parameters, boundary conditions and time step information. The result of the setup is a completed input file case_tube3d.inp . The Abaqus element type used is S8R. These are 8-node shell elements. The R refers to reduced integration. See the Abaqus documentation for more information. The loads are applied on the faces in 9 points per element, which means on 864 load points in total. The displacement is calculated in the nodes. There are 304 nodes on the fluid-structure interface. The axial direction is along the x-axis. The coordinate frames of both solvers are the same so there is no need for a permutation mapper. In contrast, the difference of the points where loads and displacements are applied or calculated, require the use of interpolation mappers. Therefore, a radial basis mapper is introduced in the structure solver to interpolate in the x-, y- and z-direction.","title":"OpenFOAM 3D - Abaqus 3D"},{"location":"tube_openfoam3d_abaqus3d.html#tube-case-with-openfoam3d-and-abaqus3d","text":"This example calculates the flow inside and the deformation and stresses of a straight flexible tube, where a pressure pulse is applied at the inlet. This done by using OpenFOAM and Abaqus, both with a fully 3D case.","title":"Tube case with OpenFOAM3D and Abaqus3D"},{"location":"tube_openfoam3d_abaqus3d.html#coupling-algorithm","text":"The coupling technique used is the interface quasi-Newton algorithm with an approximation for the inverse of the Jacobian from a least-squares model (IQNI-LS).","title":"Coupling algorithm"},{"location":"tube_openfoam3d_abaqus3d.html#predictor","text":"The initial guess in every time step is done using the linear predictor.","title":"Predictor"},{"location":"tube_openfoam3d_abaqus3d.html#convergence-criterion","text":"Two convergence criteria have been specified: The number of iterations in every time step is larger than 20. The residual norm on the displacement is a factor 10^{-3} 10^{-3} lower than the initial value. When either criterion is satisfied the simulation stops.","title":"Convergence criterion"},{"location":"tube_openfoam3d_abaqus3d.html#solvers","text":"The flow solver is OpenFoam, used to solve a fully 3D tube, with 48 cells on the fluid-structure interface in the length-wise direction and 8 in the circumferential direction. When setting up the case, the mesh is build based on the file blockMeshDict . The displacements are applied in the nodes. In contrast, the loads (pressure and traction) are calculated in the cell centers. The axial direction is along the x-axis. When setting up the case using the setup.sh script, the solver coconut_pimpleFoam is compiled automatically. The structure solver is Abaqus, used to solve a fully 3D tube, with 12 elements on the fluid-structure interface in the length-wise direction and 8 in the circumferential direction. The Abaqus case is built when setting up the case starting from the file mesh_tube3d.inp containing nodes and elements. This is done by running Abaqus with the make_inp.py Python script to set all parameters, such as surface definitions, material parameters, boundary conditions and time step information. The result of the setup is a completed input file case_tube3d.inp . The Abaqus element type used is S8R. These are 8-node shell elements. The R refers to reduced integration. See the Abaqus documentation for more information. The loads are applied on the faces in 9 points per element, which means on 864 load points in total. The displacement is calculated in the nodes. There are 304 nodes on the fluid-structure interface. The axial direction is along the x-axis. The coordinate frames of both solvers are the same so there is no need for a permutation mapper. In contrast, the difference of the points where loads and displacements are applied or calculated, require the use of interpolation mappers. Therefore, a radial basis mapper is introduced in the structure solver to interpolate in the x-, y- and z-direction.","title":"Solvers"},{"location":"tube_openfoam3d_kratos_structure3d.html","text":"Tube case with OpenFOAM3D and KratosStructure3D This example calculates the flow inside and the deformation and stresses of a straight flexible tube, where a pressure pulse is applied at the inlet. This done by using OpenFOAM and StructuralMechanicsApplication of Kratos, both with a fully 3D case. Coupling algorithm The coupling technique used is the interface quasi-Newton algorithm with an approximation for the inverse of the Jacobian from a least-squares model (IQNI-LS). Predictor The initial guess in every time step is done using the linear predictor. Convergence criterion Two convergence criteria have been specified: The number of iterations in every time step is larger than 20. The residual norm on the displacement is a factor 10^{-3} 10^{-3} lower than the initial value. When either criterion is satisfied the simulation stops. Solvers The flow solver is OpenFoam, used to solve a fully 3D tube, with 48 cells on the fluid-structure interface in the length-wise direction and 8 in the circumferential direction. When setting up the case, the mesh is build based on the file blockMeshDict . The displacements are applied in the nodes. In contrast, the loads (pressure and traction) are calculated in the cell centers. The axial direction is along the x-axis. When setting up the case using the setup.sh script, the solver coconut_pimpleFoam is compiled automatically. The structure solver is Kratos, used to solve a fully 3D tube, with 24 elements on the fluid-structure interface in the length-wise direction and 8 in the circumferential direction. The Kratos element type used is ShellThickElementCorotational3D4N. These are 4-node shell elements. The displacement and loads are calculated/applied on the nodes. There are 200 nodes on the fluid-structure interface. The axial direction is along the x-axis. The parameter file ProjectParameters.json is passed to CoCoNuT. The coordinate frames of both solvers are the same so there is no need for a permutation mapper. On the other hand, difference in the discretization between the fluid and the structure mesh requires the use of interpolation mappers. Therefore, a radial basis mapper is used to interpolate in the x-, y- and z-direction.","title":"OpenFOAM 3D - Kratos Structure 3D"},{"location":"tube_openfoam3d_kratos_structure3d.html#tube-case-with-openfoam3d-and-kratosstructure3d","text":"This example calculates the flow inside and the deformation and stresses of a straight flexible tube, where a pressure pulse is applied at the inlet. This done by using OpenFOAM and StructuralMechanicsApplication of Kratos, both with a fully 3D case.","title":"Tube case with OpenFOAM3D and KratosStructure3D"},{"location":"tube_openfoam3d_kratos_structure3d.html#coupling-algorithm","text":"The coupling technique used is the interface quasi-Newton algorithm with an approximation for the inverse of the Jacobian from a least-squares model (IQNI-LS).","title":"Coupling algorithm"},{"location":"tube_openfoam3d_kratos_structure3d.html#predictor","text":"The initial guess in every time step is done using the linear predictor.","title":"Predictor"},{"location":"tube_openfoam3d_kratos_structure3d.html#convergence-criterion","text":"Two convergence criteria have been specified: The number of iterations in every time step is larger than 20. The residual norm on the displacement is a factor 10^{-3} 10^{-3} lower than the initial value. When either criterion is satisfied the simulation stops.","title":"Convergence criterion"},{"location":"tube_openfoam3d_kratos_structure3d.html#solvers","text":"The flow solver is OpenFoam, used to solve a fully 3D tube, with 48 cells on the fluid-structure interface in the length-wise direction and 8 in the circumferential direction. When setting up the case, the mesh is build based on the file blockMeshDict . The displacements are applied in the nodes. In contrast, the loads (pressure and traction) are calculated in the cell centers. The axial direction is along the x-axis. When setting up the case using the setup.sh script, the solver coconut_pimpleFoam is compiled automatically. The structure solver is Kratos, used to solve a fully 3D tube, with 24 elements on the fluid-structure interface in the length-wise direction and 8 in the circumferential direction. The Kratos element type used is ShellThickElementCorotational3D4N. These are 4-node shell elements. The displacement and loads are calculated/applied on the nodes. There are 200 nodes on the fluid-structure interface. The axial direction is along the x-axis. The parameter file ProjectParameters.json is passed to CoCoNuT. The coordinate frames of both solvers are the same so there is no need for a permutation mapper. On the other hand, difference in the discretization between the fluid and the structure mesh requires the use of interpolation mappers. Therefore, a radial basis mapper is used to interpolate in the x-, y- and z-direction.","title":"Solvers"},{"location":"tube_tube_flow_abaqus2d.html","text":"Tube case with TubeFlow and Abaqus2D This example calculates the flow inside and the deformation and stresses of a straight flexible tube, where a pressure pulse is applied at the inlet. This done by using Python solver TubeFlow and Abaqus (axisymmetric). Coupling algorithm The coupling technique used is the interface quasi-Newton algorithm with an approximation for the inverse of the Jacobian from a least-squares model (IQNI-LS). Predictor The initial guess in every time step is done using the linear predictor. Convergence criterion Two convergence criteria have been specified: The number of iterations in every time step is larger than 15. The residual norm on the displacement is a factor 10^{-6} 10^{-6} lower than the initial value. When either criterion is satisfied the simulation stops. Solvers The flow solver is the Python solver TubeFlow, which implements a 1D model of the flow inside the tube, with 100 cells on the fluid-structure interface. The parameters for this model are specified in the setup folder by the file solver_parameters_pressure.json . The (radial) displacements are applied on the cell centers. The loads, in fact only pressure for this 1D case, are calculated in the cell centers as well. The axial direction is along the z-axis, the radial direction along the y-axis. The structure solver is Abaqus, used to solve an axisymmetric representation of the tube, with 50 elements on the fluid-structure interface. The Abaqus case is built when setting up the case starting from the file mesh_tube2d.inp containing nodes and elements. This is done by running Abaqus with the make_inp.py Python script to set all parameters, such as surface definitions, material parameters, boundary conditions and time step information. The result of the setup is a completed input file case_tube2d.inp .The Abaqus element type used is CAX8RH. These are continuum elements for axisymmetric calculations, for stress and displacement without twist. They are: 8-node biquadratic, reduced integration, hybrid with linear pressure. See the Abaqus documentation for more information. The loads are applied on the faces in three points per element, which means on 150 load points in total. The displacement is calculated in the nodes. There are 101 nodes on the fluid-structure interface. The axial direction is along the y-axis, the radial direction along the x-axis. The difference in reference frames and number of cells on the fluid-structure interface requires the use of mappers. In the structure solver wrapper, a permutation mapper is introduced to match the coordinate frames. The new x-axis corresponds to y-axis of the incoming loads the new y-axis corresponds to the z-axis and the new z-axis to the x-axis. Thereafter, a linear interpolation mapper is used to interpolate in the x- and y-direction from the 100 cell centers of TubeFlow to the 150 load points in Abaqus. For the output the same is done in the opposite order: first interpolating and then swapping the axes. So the new x-axis is the z-axis of the displacements calculated by Abaqus, the new y-axis corresponds to the x-axis and the new z-axis to the y-axis.","title":"Python TubeFlow - Abaqus 2D"},{"location":"tube_tube_flow_abaqus2d.html#tube-case-with-tubeflow-and-abaqus2d","text":"This example calculates the flow inside and the deformation and stresses of a straight flexible tube, where a pressure pulse is applied at the inlet. This done by using Python solver TubeFlow and Abaqus (axisymmetric).","title":"Tube case with TubeFlow and Abaqus2D"},{"location":"tube_tube_flow_abaqus2d.html#coupling-algorithm","text":"The coupling technique used is the interface quasi-Newton algorithm with an approximation for the inverse of the Jacobian from a least-squares model (IQNI-LS).","title":"Coupling algorithm"},{"location":"tube_tube_flow_abaqus2d.html#predictor","text":"The initial guess in every time step is done using the linear predictor.","title":"Predictor"},{"location":"tube_tube_flow_abaqus2d.html#convergence-criterion","text":"Two convergence criteria have been specified: The number of iterations in every time step is larger than 15. The residual norm on the displacement is a factor 10^{-6} 10^{-6} lower than the initial value. When either criterion is satisfied the simulation stops.","title":"Convergence criterion"},{"location":"tube_tube_flow_abaqus2d.html#solvers","text":"The flow solver is the Python solver TubeFlow, which implements a 1D model of the flow inside the tube, with 100 cells on the fluid-structure interface. The parameters for this model are specified in the setup folder by the file solver_parameters_pressure.json . The (radial) displacements are applied on the cell centers. The loads, in fact only pressure for this 1D case, are calculated in the cell centers as well. The axial direction is along the z-axis, the radial direction along the y-axis. The structure solver is Abaqus, used to solve an axisymmetric representation of the tube, with 50 elements on the fluid-structure interface. The Abaqus case is built when setting up the case starting from the file mesh_tube2d.inp containing nodes and elements. This is done by running Abaqus with the make_inp.py Python script to set all parameters, such as surface definitions, material parameters, boundary conditions and time step information. The result of the setup is a completed input file case_tube2d.inp .The Abaqus element type used is CAX8RH. These are continuum elements for axisymmetric calculations, for stress and displacement without twist. They are: 8-node biquadratic, reduced integration, hybrid with linear pressure. See the Abaqus documentation for more information. The loads are applied on the faces in three points per element, which means on 150 load points in total. The displacement is calculated in the nodes. There are 101 nodes on the fluid-structure interface. The axial direction is along the y-axis, the radial direction along the x-axis. The difference in reference frames and number of cells on the fluid-structure interface requires the use of mappers. In the structure solver wrapper, a permutation mapper is introduced to match the coordinate frames. The new x-axis corresponds to y-axis of the incoming loads the new y-axis corresponds to the z-axis and the new z-axis to the x-axis. Thereafter, a linear interpolation mapper is used to interpolate in the x- and y-direction from the 100 cell centers of TubeFlow to the 150 load points in Abaqus. For the output the same is done in the opposite order: first interpolating and then swapping the axes. So the new x-axis is the z-axis of the displacements calculated by Abaqus, the new y-axis corresponds to the x-axis and the new z-axis to the y-axis.","title":"Solvers"},{"location":"tube_tube_flow_tube_ringmodel.html","text":"Tube case with TubeFlow and TubeRingmodel This example calculates the flow inside and the deformation and stresses of a straight flexible tube, where a sinusoidal velocity is specified at the inlet. This done by using Python solvers TubeFlow and TubeRingmodel. Coupling algorithm The coupling technique used is the interface quasi-Newton algorithm with an approximation for the inverse of the Jacobian from a least-squares model (IQNI-LS). Predictor The initial guess in every time step is done using the linear predictor. Convergence criterion Two convergence criteria have been specified: The number of iterations in every time step is larger than 15. The residual norm on the displacement is a factor 10^{-6} 10^{-6} lower than the initial value. When either criterion is satisfied the simulation stops. Solvers The flow solver is the Python solver TubeFlow, which implements a 1D model of the flow inside the tube, with 100 cells on the fluid-structure interface. The parameters for this model are specified in the setup folder by the file solver_parameters_velocity.json . The (radial) displacements are applied on the cell centers. The loads, in fact only pressure for this 1D case, are calculated in the cell centers as well. The axial direction is along the z-axis, the radial direction along the y-axis. The structure solver is the Python solver TubeRingmodel, which implements a 1D model of the tube wall, with 100 elements on the fluid-structure interface. It differs from the Python solver TubeStructure as the no inertia is considered. The tube is regarded as consisting out of 100 independent rings. The parameters for this model are specified in the setup folder by the file solver_parameters.json . The loads, in fact only pressure for this 1D case, are applied on the cell centers. The displacements are calculated in the cell centers as well. Only the radial displacement is different from zero. The axial direction is along the z-axis, the radial direction along the y-axis. The coordinate frames of both solvers are the same so there is no need for a permutation mapper. However, the discretization of both solvers differ. To account for the difference of the points where loads and displacements are applied or calculated, the use of interpolation mappers is required. Therefore, a linear interpolation mapper is introduced in the structure solver to interpolate in the x-direction. Additionally a parameter file parameters_conformal.json is also provided. This parameter file performs no interpolation. It should be verified that the number of cells m is the same in both solvers before using it and is merely provided as a theoretical example as it will have close to no practical use. To run the example case with parameters_conformal.json as parameter file, the variable parameter_file_name should be adapted in the run_simulation.py script after setting up the case.","title":"Python TubeFlow - Python TubeRingmodel"},{"location":"tube_tube_flow_tube_ringmodel.html#tube-case-with-tubeflow-and-tuberingmodel","text":"This example calculates the flow inside and the deformation and stresses of a straight flexible tube, where a sinusoidal velocity is specified at the inlet. This done by using Python solvers TubeFlow and TubeRingmodel.","title":"Tube case with TubeFlow and TubeRingmodel"},{"location":"tube_tube_flow_tube_ringmodel.html#coupling-algorithm","text":"The coupling technique used is the interface quasi-Newton algorithm with an approximation for the inverse of the Jacobian from a least-squares model (IQNI-LS).","title":"Coupling algorithm"},{"location":"tube_tube_flow_tube_ringmodel.html#predictor","text":"The initial guess in every time step is done using the linear predictor.","title":"Predictor"},{"location":"tube_tube_flow_tube_ringmodel.html#convergence-criterion","text":"Two convergence criteria have been specified: The number of iterations in every time step is larger than 15. The residual norm on the displacement is a factor 10^{-6} 10^{-6} lower than the initial value. When either criterion is satisfied the simulation stops.","title":"Convergence criterion"},{"location":"tube_tube_flow_tube_ringmodel.html#solvers","text":"The flow solver is the Python solver TubeFlow, which implements a 1D model of the flow inside the tube, with 100 cells on the fluid-structure interface. The parameters for this model are specified in the setup folder by the file solver_parameters_velocity.json . The (radial) displacements are applied on the cell centers. The loads, in fact only pressure for this 1D case, are calculated in the cell centers as well. The axial direction is along the z-axis, the radial direction along the y-axis. The structure solver is the Python solver TubeRingmodel, which implements a 1D model of the tube wall, with 100 elements on the fluid-structure interface. It differs from the Python solver TubeStructure as the no inertia is considered. The tube is regarded as consisting out of 100 independent rings. The parameters for this model are specified in the setup folder by the file solver_parameters.json . The loads, in fact only pressure for this 1D case, are applied on the cell centers. The displacements are calculated in the cell centers as well. Only the radial displacement is different from zero. The axial direction is along the z-axis, the radial direction along the y-axis. The coordinate frames of both solvers are the same so there is no need for a permutation mapper. However, the discretization of both solvers differ. To account for the difference of the points where loads and displacements are applied or calculated, the use of interpolation mappers is required. Therefore, a linear interpolation mapper is introduced in the structure solver to interpolate in the x-direction. Additionally a parameter file parameters_conformal.json is also provided. This parameter file performs no interpolation. It should be verified that the number of cells m is the same in both solvers before using it and is merely provided as a theoretical example as it will have close to no practical use. To run the example case with parameters_conformal.json as parameter file, the variable parameter_file_name should be adapted in the run_simulation.py script after setting up the case.","title":"Solvers"},{"location":"tube_tube_flow_tube_structure.html","text":"Tube case with TubeFlow and TubeStructure This example calculates the flow inside and the deformation and stresses of a straight flexible tube, where a pressure pulse is applied at the inlet. This done by using Python solvers TubeFlow and TubeStructure. Coupling algorithm The coupling technique used is the interface quasi-Newton algorithm with an approximation for the inverse of the Jacobian from a least-squares model (IQNI-LS). Predictor The initial guess in every time step is done using the linear predictor. Convergence criterion Two convergence criteria have been specified: The number of iterations in every time step is larger than 15. The residual norm on the displacement is a factor 10^{-6} 10^{-6} lower than the initial value. When either criterion is satisfied the simulation stops. Solvers The flow solver is the Python solver TubeFlow, which implements a 1D model of the flow inside the tube, with 100 cells on the fluid-structure interface. The parameters for this model are specified in the setup folder by the file solver_parameters_pressure.json . The (radial) displacements are applied on the cell centers. The loads, in fact only pressure for this 1D case, are calculated in the cell centers as well. The axial direction is along the z-axis, the radial direction along the y-axis. The structure solver is the Python solver TubeStructure, which implements a 1D model of the tube wall, with 100 elements on the fluid-structure interface. The parameters for this model are specified in the setup folder by the file solver_parameters.json . The loads, in fact only pressure for this 1D case, are applied on the cell centers. The displacements are calculated in the cell centers as well. Only the radial displacement is different from zero. The axial direction is along the z-axis, the radial direction along the y-axis. The coordinate frames of both solvers are the same so there is no need for a permutation mapper. Moreover, as both solvers have 100 cells on the fluid-structure interface, no interpolation is required. Nonetheless, a linear interpolation mapper for the structure solver to interpolate in the x-direction is included in the parameter file. As such, the number of cells m can be varied independently in both solvers.","title":"Python TubeFlow - Python TubeStructre"},{"location":"tube_tube_flow_tube_structure.html#tube-case-with-tubeflow-and-tubestructure","text":"This example calculates the flow inside and the deformation and stresses of a straight flexible tube, where a pressure pulse is applied at the inlet. This done by using Python solvers TubeFlow and TubeStructure.","title":"Tube case with TubeFlow and TubeStructure"},{"location":"tube_tube_flow_tube_structure.html#coupling-algorithm","text":"The coupling technique used is the interface quasi-Newton algorithm with an approximation for the inverse of the Jacobian from a least-squares model (IQNI-LS).","title":"Coupling algorithm"},{"location":"tube_tube_flow_tube_structure.html#predictor","text":"The initial guess in every time step is done using the linear predictor.","title":"Predictor"},{"location":"tube_tube_flow_tube_structure.html#convergence-criterion","text":"Two convergence criteria have been specified: The number of iterations in every time step is larger than 15. The residual norm on the displacement is a factor 10^{-6} 10^{-6} lower than the initial value. When either criterion is satisfied the simulation stops.","title":"Convergence criterion"},{"location":"tube_tube_flow_tube_structure.html#solvers","text":"The flow solver is the Python solver TubeFlow, which implements a 1D model of the flow inside the tube, with 100 cells on the fluid-structure interface. The parameters for this model are specified in the setup folder by the file solver_parameters_pressure.json . The (radial) displacements are applied on the cell centers. The loads, in fact only pressure for this 1D case, are calculated in the cell centers as well. The axial direction is along the z-axis, the radial direction along the y-axis. The structure solver is the Python solver TubeStructure, which implements a 1D model of the tube wall, with 100 elements on the fluid-structure interface. The parameters for this model are specified in the setup folder by the file solver_parameters.json . The loads, in fact only pressure for this 1D case, are applied on the cell centers. The displacements are calculated in the cell centers as well. Only the radial displacement is different from zero. The axial direction is along the z-axis, the radial direction along the y-axis. The coordinate frames of both solvers are the same so there is no need for a permutation mapper. Moreover, as both solvers have 100 cells on the fluid-structure interface, no interpolation is required. Nonetheless, a linear interpolation mapper for the structure solver to interpolate in the x-direction is included in the parameter file. As such, the number of cells m can be varied independently in both solvers.","title":"Solvers"},{"location":"turek_fluent2d_abaqus2d.html","text":"Turek benchmark with Fluent2D and Abaqus2D This example calculates the well-known Turek benchmark, which consist laminar incompressible flow around a flexible flag attached to a rigid cylinder in a 2D channel. The material parameters and boundary conditions correspond to the FSI2 setup, as detailed by Turek and Hron [ 1 ]. The challenging aspect of this benchmark lies in the large self-indcuced oscillation of the flag. The used solvers are Fluent and Abaqus. A script evaluate_benchmark.py is provided to compare the results with the benchmark results in [ 1 ]. Furthermore, the script animate_beam.py can be used to visualize the interface data throughout the calculation. Due to the time required for the oscillations to enter a periodic regime, this test case takes a long time to run. The figure below shows the resulting velocity contour plot (with Fluent). In the FSI2 setup a parabolic velocity profile is subscribed at the inlet with an average velocity of 1 m/s, ramped up slowly in time. The fluid paramters are: density: 1000 kg/m\u00b3 dynamic viscosity: 1 Pa \\cdot \\cdot s The flag is consist of a linear elastic material with the follwing properties: density: 10 ^4 ^4 kg/m\u00b3 modulus of elasticity: 1.4 10 ^6 ^6 Pa poisson's ratio: 0.4 The total simulated time is 35 s in time steps of 0.002 s. Coupling algorithm The coupling technique used is the interface quasi-Newton algorithm with an approximation for the inverse of the Jacobian from a least-squares model (IQNI-LS). The reuse parameter q is set to 10, which means that data from the last ten time steps will be used to stabilize and accelerate the convergence. Predictor The initial guess in every time step is done using the quadratic predictor. Convergence criterion Two convergence criteria have been specified: The number of iterations in every time step is larger than 15. The residual norm on the displacement is a factor 10^{-3} 10^{-3} lower than the initial value. When either criterion is satisfied the simulation stops. Solvers Fluent is used as flow solver. The provided mesh is triangular. When the gate bends remeshing is performed to perserve its quality. A script to regenerate it using Gambit is included. This script allows to change the resolution and geometrical parameters. The structure solver is Abaqus. The Abaqus case is built when setting up the case starting from the file mesh_turek.inp containing nodes and elements. This is done by running Abaqus with the make_inp.py Python script to set all parameters, such as surface definitions, material parameters, boundary conditions and time step information. The result of the setup is a completed input file case_turek.inp . The Abaqus element type used is CPE8R. To exchange information between the solvers on the fluid-structure interface, the use of mappers is required. In the structure solver wrapper, a linear interpolation mapper is used to interpolate in the x- and y-direction from and to the coupled solver. References [1] Turek S., Hron J., \"Proposal for Numerical Benchmarking of Fluid-Structure Interaction between an Elastic Object and Laminar Incompressible Flow\", Bungartz HJ., Sch\u00e4fer M. (eds) Fluid-Structure Interaction. Lecture Notes in Computational Science and Engineering, vol. 53. Springer, Berlin, Heidelberg, 2006.","title":"Fluent 2D - Abaqus 2D"},{"location":"turek_fluent2d_abaqus2d.html#turek-benchmark-with-fluent2d-and-abaqus2d","text":"This example calculates the well-known Turek benchmark, which consist laminar incompressible flow around a flexible flag attached to a rigid cylinder in a 2D channel. The material parameters and boundary conditions correspond to the FSI2 setup, as detailed by Turek and Hron [ 1 ]. The challenging aspect of this benchmark lies in the large self-indcuced oscillation of the flag. The used solvers are Fluent and Abaqus. A script evaluate_benchmark.py is provided to compare the results with the benchmark results in [ 1 ]. Furthermore, the script animate_beam.py can be used to visualize the interface data throughout the calculation. Due to the time required for the oscillations to enter a periodic regime, this test case takes a long time to run. The figure below shows the resulting velocity contour plot (with Fluent). In the FSI2 setup a parabolic velocity profile is subscribed at the inlet with an average velocity of 1 m/s, ramped up slowly in time. The fluid paramters are: density: 1000 kg/m\u00b3 dynamic viscosity: 1 Pa \\cdot \\cdot s The flag is consist of a linear elastic material with the follwing properties: density: 10 ^4 ^4 kg/m\u00b3 modulus of elasticity: 1.4 10 ^6 ^6 Pa poisson's ratio: 0.4 The total simulated time is 35 s in time steps of 0.002 s.","title":"Turek benchmark with Fluent2D and Abaqus2D"},{"location":"turek_fluent2d_abaqus2d.html#coupling-algorithm","text":"The coupling technique used is the interface quasi-Newton algorithm with an approximation for the inverse of the Jacobian from a least-squares model (IQNI-LS). The reuse parameter q is set to 10, which means that data from the last ten time steps will be used to stabilize and accelerate the convergence.","title":"Coupling algorithm"},{"location":"turek_fluent2d_abaqus2d.html#predictor","text":"The initial guess in every time step is done using the quadratic predictor.","title":"Predictor"},{"location":"turek_fluent2d_abaqus2d.html#convergence-criterion","text":"Two convergence criteria have been specified: The number of iterations in every time step is larger than 15. The residual norm on the displacement is a factor 10^{-3} 10^{-3} lower than the initial value. When either criterion is satisfied the simulation stops.","title":"Convergence criterion"},{"location":"turek_fluent2d_abaqus2d.html#solvers","text":"Fluent is used as flow solver. The provided mesh is triangular. When the gate bends remeshing is performed to perserve its quality. A script to regenerate it using Gambit is included. This script allows to change the resolution and geometrical parameters. The structure solver is Abaqus. The Abaqus case is built when setting up the case starting from the file mesh_turek.inp containing nodes and elements. This is done by running Abaqus with the make_inp.py Python script to set all parameters, such as surface definitions, material parameters, boundary conditions and time step information. The result of the setup is a completed input file case_turek.inp . The Abaqus element type used is CPE8R. To exchange information between the solvers on the fluid-structure interface, the use of mappers is required. In the structure solver wrapper, a linear interpolation mapper is used to interpolate in the x- and y-direction from and to the coupled solver.","title":"Solvers"},{"location":"turek_fluent2d_abaqus2d.html#references","text":"[1] Turek S., Hron J., \"Proposal for Numerical Benchmarking of Fluid-Structure Interaction between an Elastic Object and Laminar Incompressible Flow\", Bungartz HJ., Sch\u00e4fer M. (eds) Fluid-Structure Interaction. Lecture Notes in Computational Science and Engineering, vol. 53. Springer, Berlin, Heidelberg, 2006.","title":"References"},{"location":"turek_fluent2d_abaqus2d_steady.html","text":"Turek benchmark with Fluent2D and Abaqus2D - Steady This example calculates the well-known Turek benchmark, which consist laminar incompressible flow around a flexible flag attached to a rigid cylinder in a 2D channel. The material parameters and boundary conditions correspond to the FSI1 setup, as detailed by Turek and Hron [ 1 ]. This is a steady simulation. The used solvers are Fluent and Abaqus. A script evaluate_benchmark.py is provided to compare the results with the benchmark results in [ 1 ]. The figure below shows the resulting velocity contour plot (with Fluent). In the FSI1 setup a parabolic velocity profile is subscribed at the inlet with an average velocity of 0.2 m/s. The flow is intialized with a velocity in the x-direction equal to 0.2 m/s. The fluid paramters are: density: 1000 kg/m\u00b3 dynamic viscosity: 1 Pa \\cdot \\cdot s The flag is consist of a linear elastic material with the follwing properties: density: 1000 kg/m\u00b3 modulus of elasticity: 1.4 10 ^6 ^6 Pa poisson's ratio: 0.4 General setting Although the calculation is steady, a delta_t is still required. Its value is arbitrary and 0 is used. timestep_start is required as well and is set to 0. The number_of_timesteps is set to 1. Coupling algorithm The coupling technique used is the interface quasi-Newton algorithm with an approximation for the inverse of the Jacobian from a least-squares model (IQNI-LS). Note that the reuse parameter q is not used as only one time step is calculated. Predictor A predictor is still required, but not used as only one time step is calculated. Convergence criterion Two convergence criteria have been specified: The number of iterations in every time step is larger than 15. The residual norm on the displacement is a factor 10^{-3} 10^{-3} lower than the initial value. When either criterion is satisfied the simulation stops. Solvers Fluent is used as flow solver. The provided mesh is triangular. A script to regenerate it using Gambit is included. This script allows to change the resolution and geometrical parameters. The structure solver is Abaqus. The Abaqus case is built when setting up the case starting from the file mesh_turek.inp containing nodes and elements. This is done by running Abaqus with the make_inp.py Python script to set all parameters, such as surface definitions, material parameters, boundary conditions and time step information. The result of the setup is a completed input file case_turek.inp . The Abaqus element type used is CPE8R. To exchange information between the solvers on the fluid-structure interface, the use of mappers is required. In the structure solver wrapper, a linear interpolation mapper is used to interpolate in the x- and y-direction from and to the coupled solver. References [1] Turek S., Hron J., \"Proposal for Numerical Benchmarking of Fluid-Structure Interaction between an Elastic Object and Laminar Incompressible Flow\", Bungartz HJ., Sch\u00e4fer M. (eds) Fluid-Structure Interaction. Lecture Notes in Computational Science and Engineering, vol. 53. Springer, Berlin, Heidelberg, 2006.","title":"Fluent 2D - Abaqus 2D - Steady"},{"location":"turek_fluent2d_abaqus2d_steady.html#turek-benchmark-with-fluent2d-and-abaqus2d-steady","text":"This example calculates the well-known Turek benchmark, which consist laminar incompressible flow around a flexible flag attached to a rigid cylinder in a 2D channel. The material parameters and boundary conditions correspond to the FSI1 setup, as detailed by Turek and Hron [ 1 ]. This is a steady simulation. The used solvers are Fluent and Abaqus. A script evaluate_benchmark.py is provided to compare the results with the benchmark results in [ 1 ]. The figure below shows the resulting velocity contour plot (with Fluent). In the FSI1 setup a parabolic velocity profile is subscribed at the inlet with an average velocity of 0.2 m/s. The flow is intialized with a velocity in the x-direction equal to 0.2 m/s. The fluid paramters are: density: 1000 kg/m\u00b3 dynamic viscosity: 1 Pa \\cdot \\cdot s The flag is consist of a linear elastic material with the follwing properties: density: 1000 kg/m\u00b3 modulus of elasticity: 1.4 10 ^6 ^6 Pa poisson's ratio: 0.4","title":"Turek benchmark with Fluent2D and Abaqus2D - Steady"},{"location":"turek_fluent2d_abaqus2d_steady.html#general-setting","text":"Although the calculation is steady, a delta_t is still required. Its value is arbitrary and 0 is used. timestep_start is required as well and is set to 0. The number_of_timesteps is set to 1.","title":"General setting"},{"location":"turek_fluent2d_abaqus2d_steady.html#coupling-algorithm","text":"The coupling technique used is the interface quasi-Newton algorithm with an approximation for the inverse of the Jacobian from a least-squares model (IQNI-LS). Note that the reuse parameter q is not used as only one time step is calculated.","title":"Coupling algorithm"},{"location":"turek_fluent2d_abaqus2d_steady.html#predictor","text":"A predictor is still required, but not used as only one time step is calculated.","title":"Predictor"},{"location":"turek_fluent2d_abaqus2d_steady.html#convergence-criterion","text":"Two convergence criteria have been specified: The number of iterations in every time step is larger than 15. The residual norm on the displacement is a factor 10^{-3} 10^{-3} lower than the initial value. When either criterion is satisfied the simulation stops.","title":"Convergence criterion"},{"location":"turek_fluent2d_abaqus2d_steady.html#solvers","text":"Fluent is used as flow solver. The provided mesh is triangular. A script to regenerate it using Gambit is included. This script allows to change the resolution and geometrical parameters. The structure solver is Abaqus. The Abaqus case is built when setting up the case starting from the file mesh_turek.inp containing nodes and elements. This is done by running Abaqus with the make_inp.py Python script to set all parameters, such as surface definitions, material parameters, boundary conditions and time step information. The result of the setup is a completed input file case_turek.inp . The Abaqus element type used is CPE8R. To exchange information between the solvers on the fluid-structure interface, the use of mappers is required. In the structure solver wrapper, a linear interpolation mapper is used to interpolate in the x- and y-direction from and to the coupled solver.","title":"Solvers"},{"location":"turek_fluent2d_abaqus2d_steady.html#references","text":"[1] Turek S., Hron J., \"Proposal for Numerical Benchmarking of Fluid-Structure Interaction between an Elastic Object and Laminar Incompressible Flow\", Bungartz HJ., Sch\u00e4fer M. (eds) Fluid-Structure Interaction. Lecture Notes in Computational Science and Engineering, vol. 53. Springer, Berlin, Heidelberg, 2006.","title":"References"}]}