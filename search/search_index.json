{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"CoCoNuT - Coupling Code for Numerical Tools CoCoNuT is a light-weight Python package for efficient partitioned multi-physics simulations, with a focus on fluid-structure interaction. Thanks to its fully modular approach, the package is versatile and easy to extend. It is available under the GPL-3.0 license. Introduction The Coupling Code for Numerical Tools \u2014 CoCoNuT in short\u2014follows a partitioned approach to solve multi-physics problem: existing single-physics solvers are coupled through a Python interface. This has the advantage that dedicated, highly-optimized single-physics solvers can be used. To use the code with a new solver (open source or commercial), a so-called solver-wrapper is written to take care of the communication with CoCoNuT. All other CoCoNuT components, such as mapping for non-conformal meshes, are solver-independent and are easily swapped thanks to CoCoNuT's modular architecture. CoCoNuT is under active development by the Fluid Mechanics research team at Ghent University. Our specialization is partitioned fluid-structure interaction. We develop high-performance quasi-Newton algorithms to accelerate convergence of the coupled problem, and apply these techniques to diverse fluid-structure interaction applications such as wind turbines, tube bundles and flexible aircraft. The full documentation of the CoCoNuT package can be found at the documentation website . Installation These instructions describe the setup of CoCoNuT on Linux. The package has not been tested on Windows or macOS, so compatibility is not guaranteed, although we do not expect major issues. Requirements Python 3.6+ NumPy and SciPy packages (we recommend Anaconda 2019.03+) Installation CoCoNuT does not need to be compiled, hence installation is straightforward. The source code can be downloaded as a zip file, or cloned directly from GitHub. For users that have no experience with Git or GitHub, we recommend the first option. The second option makes it easier to update the software and contribute to the code. Option 1: download zip Download the source code from GitHub . Unzip to a folder coconut . If the folder is unzipped in Windows, some of the file permissions may change and some tests or examples may not run out of the box. Option 2: clone source Choose or create a directory to install CoCoNuT. Move to this directory. Clone the GitHub repository with SSH or HTTPS by executing one of the following commands. With SSH: git clone git@github.com:pyfsi/coconut.git With HTTPS: git clone https://github.com/pyfsi/coconut.git After the code has been downloaded or cloned, the coconut package must be added to the user's Python path. For example, with a folder structure like /some/absolute/path/ coconut/ coupling_components/ data_structure/ ... README.md coconut can be added to your Python path by executing the following line: export PYTHONPATH = /some/absolute/path: $PYTHONPATH This line can also be added to your .bashrc file. Quick test We recommend to run the unit tests at the end of the installation, to make sure that everything works. Ensure that coconut is included in your Python path. Move to the coconut/tests directory. Run the unit tests by executing the following line: python -m unittest -b Getting started Once the CoCoNuT package has been successfully installed, it is time to run a first coupled simulation. For this purpose, we give a step-by-step guide of an example case included in the source code. In this example the fluid-structure interaction (FSI) problem of a pressure wave propagating through an elastic tube in incompressible flow is calculated (see here and here ). For both the flow and structure solver, we use 1D Python-solvers that are included in CoCoNuT. This has the advantage that no external single-physics solvers must be installed for this example. Furthermore, the 1D solvers are very fast, so that a full transient FSI calculation can be done in this example. Another example in the source code solves the same case in 3D using ANSYS Fluent and Abaqus for respectively the flow and structure calculations. We start by creating an environment variable COCO in which we can store the path to the folder in which CoCoNuT is installed. We will use this variable to avoid any confusion about relative or absolute paths in this tutorial. Using the example installation location from above: COCO = /some/absolute/path We can now navigate to the folder of the example we will simulate. cd $COCO /coconut/examples/tube_tube_flow_tube_structure/ This folder contains all the files required to set up and run the FSI simulation in CoCoNuT. The files run_simulation.py and project_paramaters_mapped.json will be used to run the actual FSI simulation, but we will come back to those later. First we must set up both single-physics solvers separately, starting with the flow solver. This setup is typically done outside of CoCoNuT by the user, as it is solver-specific. In this case we provide a bash script setup_tube_flow.sh that uses the files in the folder setup_tube_flow to generate the case. When the script is run with ./setup_tube_flow.sh a new folder CFD appears. This folder contains all files required to start a simulation of the flow in the tube. Analogously, we run ./setup_tube_structure.sh to generate the CSM folder, which contains all files required to start a simulation of the tube structure. We can now start the FSI simulation in CoCoNuT by running the Python file run_simulation.py with the settings file project_paramaters_mapped.json as argument: python run_simulation.py project_parameters_mapped.json The simulation should start, first printing the CoCoNuT ASCII-banner, then some information about the settings of the FSI simulation and finally the residuals of the coupling iterations per time step. Let us now take a closer look at the two files that are used to run CoCoNuT. The Python file run_simulation.py typically does not have to be adapted by the user. Its task is to read in the settings file project_paramaters_mapped.json and launch a simulation using those settings. The file project_paramaters_mapped.json is a collection of settings that is written in JSON format . JSON is a language-independent text format that is easy to read and write, and is used for data-exchange. It consists mainly of key-value pairs, and can hence be easily converted to a (nested) Python dictionary. While the keys are always strings, the values can be strings, numbers, arrays, booleans or nested JSON objects (nested dictionaries). Before you read on, it can be useful to familiarize yourself with the JSON syntax. In what follows, we will use Python terminology (dictionary, list, boolean, etc...) to refer to the structure and the values in the JSON file. The JSON file is built up in a hierarchical way that represents the objects created in the CoCoNuT simulation. At the highest level, the dictionary contains two keys: settings and coupled_solver . The value given to the settings key is a nested dictionary, which contains a single key-value pair that sets the number of timesteps to be simulated. The value given to the coupled_solver key is a special dictionary, because it has the type key. CoCoNuT will generate an object of the specified type, namely coupled_solvers.iqni . This refers to the class defined in the file $COCO/coconut/coupling_components/coupled_solvers/iqni.py : the CoupledSolverIQNI class. Note that the value in type always refers to a file located in $COCO/coconut/coupling_components . The dictionary under settings is used to initialize an instance of this class. In this case the initial time timestep_start , the time step delta_t and some other parameters must be given. The coupled solver is the main class that determines how the two single-physics solvers are coupled. The dictionary that is given to the coupled_solver key contains next to type and settings three other key-value pairs. These will generate other objects: the fact that they are given in the coupled_solver dictionary means that these objects will be created by the coupled solver object. predictor will generate an object of the PredictorLinear class found in the file $COCO/coconut/coupling_components/predictors/linear.py . This class requires no additional settings for its initialization. The predictor object is used to extrapolate the solution to the next time step. convergence_criterion will generate an object of the ConvergenceCriterionOr class found in the file $COCO/coconut/coupling_components/convergence_criteria/or.py , using the given settings for its initialization. The convergence criterion is used to determine when CoCoNuT should move to the next time step. In this case the or criterion is used, which signals convergence when one or both underlying criteria are satisfied. These underlying criteria are instances of the ConvergenceCriterionIterationLimit and ConvergenceCriterionRelativeNorm classes defined in respectively $COCO/coconut/coupling_components/convergence_criteria/iteration_limit.py and $COCO/coconut/coupling_components/convergence_criteria/relative_norm.py . This means that CoCoNuT will move to the next time step after 15 iterations or when the 2-norm of the residual has decreased six orders of magnitude. solver_wrappers is a list of two solver-wrapper objects, which will communicate with the two single-physics solvers, in this case the 1D flow solver and the 1D structure solver. The first dictionary in the list will generate an instance of the SolverWrapperTubeFlow class found in $COCO/coconut/coupling_components/solver_wrappers/python/tube_flow_solver.py . An important setting to generate this object is the working_directory , which refers to the folder CFD that we created with the case files of the flow solver. All files written by the flow solver will also appear in this folder. We would now expect the second dictionary to generate a solver-wrapper to communicate with the structure solver, i.e. an instance of the SolverWrapperTubeStructure class found in $COCO/coconut/coupling_components/solver_wrappers/python/tube_structure_solver.py . This is not the case however: the flow and structure solvers typically use a different geometrical discretization (computational grid or mesh), hence they cannot readily be coupled in CoCoNuT. To overcome this issue, we put a layer of mapping around one of the solver-wrappers. This is done with the SolverWrapperMapped class found in $COCO/coconut/coupling_components/solver_wrappers/mapped.py . The mapped solver-wrapper interpolates all data flowing between CoCoNuT and the real solver-wrapper. The mapped solver-wrapper itself contains three objects: the actual solver-wrapper ( SolverWrapperTubeStructure class), and mappers for respectively the input and the output of the solver-wrapper (both MapperInterface class). The concept of the mapped solver-wrapper illustrates the modularity of CoCoNuT. As far as the coupled solver is concerned, the mapped solver-wrapper acts exactly as a real solver-wrapper. The real solver-wrapper does not know about the mapping at all: it acts as if it directly communicates with the coupled solver. Furthermore, the interpolation method can be easily changed by swapping the mappers in the mapped solver-wrapper: the current linear interpolation scheme can easily be replaced by e.g. a radial-basis scheme by changing mappers.linear to mappers.radial_basis . Now try to change some of the settings in the JSON file, such as the mappers, the time step or the maximum number of coupling iterations, and rerun the coupled simulation. TODO: add visualization using the post_processing files? Overview of the code The CoCoNuT package consists of 5 main folders: coupling_components , data_structure , docs , examples and tests . To give a general understanding of how the code is structured, we give a brief description of the purpose of each folder. The documentation website mirrors this folder structure. coupling_components This folder contains the basic building blocks of CoCoNuT, which can be used to set up a coupled simulation. This includes among others the solver-wrappers, to communicate with single-physics solvers, and the mappers, which provide interpolation between non-conforming meshes present in the different single-physics solvers. data_structure This folder contains the data structure that is used internally in CoCoNuT to store and pass around information obtained from the single-physics solvers. The data structure relies on NumPy arrays for efficient storage and manipulation of data. docs This folder serves to automatically generate the documentation website, based on the MarkDown documentation files that are present throughout the code. examples This folder contains examples of several fluid-structure interaction cases, which can serve as starting point for settings up the user's own simulation. They also provide insight into the capabilities of CoCoNuT. tests This folder contains the unit tests. These are created for each piece of code that is added to CoCoNuT and are run regularly, to avoid bugs.","title":"CoCoNuT - Coupling Code for Numerical Tools"},{"location":"#coconut-coupling-code-for-numerical-tools","text":"CoCoNuT is a light-weight Python package for efficient partitioned multi-physics simulations, with a focus on fluid-structure interaction. Thanks to its fully modular approach, the package is versatile and easy to extend. It is available under the GPL-3.0 license.","title":"CoCoNuT - Coupling Code for Numerical Tools"},{"location":"#introduction","text":"The Coupling Code for Numerical Tools \u2014 CoCoNuT in short\u2014follows a partitioned approach to solve multi-physics problem: existing single-physics solvers are coupled through a Python interface. This has the advantage that dedicated, highly-optimized single-physics solvers can be used. To use the code with a new solver (open source or commercial), a so-called solver-wrapper is written to take care of the communication with CoCoNuT. All other CoCoNuT components, such as mapping for non-conformal meshes, are solver-independent and are easily swapped thanks to CoCoNuT's modular architecture. CoCoNuT is under active development by the Fluid Mechanics research team at Ghent University. Our specialization is partitioned fluid-structure interaction. We develop high-performance quasi-Newton algorithms to accelerate convergence of the coupled problem, and apply these techniques to diverse fluid-structure interaction applications such as wind turbines, tube bundles and flexible aircraft. The full documentation of the CoCoNuT package can be found at the documentation website .","title":"Introduction"},{"location":"#installation","text":"These instructions describe the setup of CoCoNuT on Linux. The package has not been tested on Windows or macOS, so compatibility is not guaranteed, although we do not expect major issues.","title":"Installation"},{"location":"#requirements","text":"Python 3.6+ NumPy and SciPy packages (we recommend Anaconda 2019.03+)","title":"Requirements"},{"location":"#installation_1","text":"CoCoNuT does not need to be compiled, hence installation is straightforward. The source code can be downloaded as a zip file, or cloned directly from GitHub. For users that have no experience with Git or GitHub, we recommend the first option. The second option makes it easier to update the software and contribute to the code. Option 1: download zip Download the source code from GitHub . Unzip to a folder coconut . If the folder is unzipped in Windows, some of the file permissions may change and some tests or examples may not run out of the box. Option 2: clone source Choose or create a directory to install CoCoNuT. Move to this directory. Clone the GitHub repository with SSH or HTTPS by executing one of the following commands. With SSH: git clone git@github.com:pyfsi/coconut.git With HTTPS: git clone https://github.com/pyfsi/coconut.git After the code has been downloaded or cloned, the coconut package must be added to the user's Python path. For example, with a folder structure like /some/absolute/path/ coconut/ coupling_components/ data_structure/ ... README.md coconut can be added to your Python path by executing the following line: export PYTHONPATH = /some/absolute/path: $PYTHONPATH This line can also be added to your .bashrc file.","title":"Installation"},{"location":"#quick-test","text":"We recommend to run the unit tests at the end of the installation, to make sure that everything works. Ensure that coconut is included in your Python path. Move to the coconut/tests directory. Run the unit tests by executing the following line: python -m unittest -b","title":"Quick test"},{"location":"#getting-started","text":"Once the CoCoNuT package has been successfully installed, it is time to run a first coupled simulation. For this purpose, we give a step-by-step guide of an example case included in the source code. In this example the fluid-structure interaction (FSI) problem of a pressure wave propagating through an elastic tube in incompressible flow is calculated (see here and here ). For both the flow and structure solver, we use 1D Python-solvers that are included in CoCoNuT. This has the advantage that no external single-physics solvers must be installed for this example. Furthermore, the 1D solvers are very fast, so that a full transient FSI calculation can be done in this example. Another example in the source code solves the same case in 3D using ANSYS Fluent and Abaqus for respectively the flow and structure calculations. We start by creating an environment variable COCO in which we can store the path to the folder in which CoCoNuT is installed. We will use this variable to avoid any confusion about relative or absolute paths in this tutorial. Using the example installation location from above: COCO = /some/absolute/path We can now navigate to the folder of the example we will simulate. cd $COCO /coconut/examples/tube_tube_flow_tube_structure/ This folder contains all the files required to set up and run the FSI simulation in CoCoNuT. The files run_simulation.py and project_paramaters_mapped.json will be used to run the actual FSI simulation, but we will come back to those later. First we must set up both single-physics solvers separately, starting with the flow solver. This setup is typically done outside of CoCoNuT by the user, as it is solver-specific. In this case we provide a bash script setup_tube_flow.sh that uses the files in the folder setup_tube_flow to generate the case. When the script is run with ./setup_tube_flow.sh a new folder CFD appears. This folder contains all files required to start a simulation of the flow in the tube. Analogously, we run ./setup_tube_structure.sh to generate the CSM folder, which contains all files required to start a simulation of the tube structure. We can now start the FSI simulation in CoCoNuT by running the Python file run_simulation.py with the settings file project_paramaters_mapped.json as argument: python run_simulation.py project_parameters_mapped.json The simulation should start, first printing the CoCoNuT ASCII-banner, then some information about the settings of the FSI simulation and finally the residuals of the coupling iterations per time step. Let us now take a closer look at the two files that are used to run CoCoNuT. The Python file run_simulation.py typically does not have to be adapted by the user. Its task is to read in the settings file project_paramaters_mapped.json and launch a simulation using those settings. The file project_paramaters_mapped.json is a collection of settings that is written in JSON format . JSON is a language-independent text format that is easy to read and write, and is used for data-exchange. It consists mainly of key-value pairs, and can hence be easily converted to a (nested) Python dictionary. While the keys are always strings, the values can be strings, numbers, arrays, booleans or nested JSON objects (nested dictionaries). Before you read on, it can be useful to familiarize yourself with the JSON syntax. In what follows, we will use Python terminology (dictionary, list, boolean, etc...) to refer to the structure and the values in the JSON file. The JSON file is built up in a hierarchical way that represents the objects created in the CoCoNuT simulation. At the highest level, the dictionary contains two keys: settings and coupled_solver . The value given to the settings key is a nested dictionary, which contains a single key-value pair that sets the number of timesteps to be simulated. The value given to the coupled_solver key is a special dictionary, because it has the type key. CoCoNuT will generate an object of the specified type, namely coupled_solvers.iqni . This refers to the class defined in the file $COCO/coconut/coupling_components/coupled_solvers/iqni.py : the CoupledSolverIQNI class. Note that the value in type always refers to a file located in $COCO/coconut/coupling_components . The dictionary under settings is used to initialize an instance of this class. In this case the initial time timestep_start , the time step delta_t and some other parameters must be given. The coupled solver is the main class that determines how the two single-physics solvers are coupled. The dictionary that is given to the coupled_solver key contains next to type and settings three other key-value pairs. These will generate other objects: the fact that they are given in the coupled_solver dictionary means that these objects will be created by the coupled solver object. predictor will generate an object of the PredictorLinear class found in the file $COCO/coconut/coupling_components/predictors/linear.py . This class requires no additional settings for its initialization. The predictor object is used to extrapolate the solution to the next time step. convergence_criterion will generate an object of the ConvergenceCriterionOr class found in the file $COCO/coconut/coupling_components/convergence_criteria/or.py , using the given settings for its initialization. The convergence criterion is used to determine when CoCoNuT should move to the next time step. In this case the or criterion is used, which signals convergence when one or both underlying criteria are satisfied. These underlying criteria are instances of the ConvergenceCriterionIterationLimit and ConvergenceCriterionRelativeNorm classes defined in respectively $COCO/coconut/coupling_components/convergence_criteria/iteration_limit.py and $COCO/coconut/coupling_components/convergence_criteria/relative_norm.py . This means that CoCoNuT will move to the next time step after 15 iterations or when the 2-norm of the residual has decreased six orders of magnitude. solver_wrappers is a list of two solver-wrapper objects, which will communicate with the two single-physics solvers, in this case the 1D flow solver and the 1D structure solver. The first dictionary in the list will generate an instance of the SolverWrapperTubeFlow class found in $COCO/coconut/coupling_components/solver_wrappers/python/tube_flow_solver.py . An important setting to generate this object is the working_directory , which refers to the folder CFD that we created with the case files of the flow solver. All files written by the flow solver will also appear in this folder. We would now expect the second dictionary to generate a solver-wrapper to communicate with the structure solver, i.e. an instance of the SolverWrapperTubeStructure class found in $COCO/coconut/coupling_components/solver_wrappers/python/tube_structure_solver.py . This is not the case however: the flow and structure solvers typically use a different geometrical discretization (computational grid or mesh), hence they cannot readily be coupled in CoCoNuT. To overcome this issue, we put a layer of mapping around one of the solver-wrappers. This is done with the SolverWrapperMapped class found in $COCO/coconut/coupling_components/solver_wrappers/mapped.py . The mapped solver-wrapper interpolates all data flowing between CoCoNuT and the real solver-wrapper. The mapped solver-wrapper itself contains three objects: the actual solver-wrapper ( SolverWrapperTubeStructure class), and mappers for respectively the input and the output of the solver-wrapper (both MapperInterface class). The concept of the mapped solver-wrapper illustrates the modularity of CoCoNuT. As far as the coupled solver is concerned, the mapped solver-wrapper acts exactly as a real solver-wrapper. The real solver-wrapper does not know about the mapping at all: it acts as if it directly communicates with the coupled solver. Furthermore, the interpolation method can be easily changed by swapping the mappers in the mapped solver-wrapper: the current linear interpolation scheme can easily be replaced by e.g. a radial-basis scheme by changing mappers.linear to mappers.radial_basis . Now try to change some of the settings in the JSON file, such as the mappers, the time step or the maximum number of coupling iterations, and rerun the coupled simulation. TODO: add visualization using the post_processing files?","title":"Getting started"},{"location":"#overview-of-the-code","text":"The CoCoNuT package consists of 5 main folders: coupling_components , data_structure , docs , examples and tests . To give a general understanding of how the code is structured, we give a brief description of the purpose of each folder. The documentation website mirrors this folder structure.","title":"Overview of the code"},{"location":"#coupling_components","text":"This folder contains the basic building blocks of CoCoNuT, which can be used to set up a coupled simulation. This includes among others the solver-wrappers, to communicate with single-physics solvers, and the mappers, which provide interpolation between non-conforming meshes present in the different single-physics solvers.","title":"coupling_components"},{"location":"#data_structure","text":"This folder contains the data structure that is used internally in CoCoNuT to store and pass around information obtained from the single-physics solvers. The data structure relies on NumPy arrays for efficient storage and manipulation of data.","title":"data_structure"},{"location":"#docs","text":"This folder serves to automatically generate the documentation website, based on the MarkDown documentation files that are present throughout the code.","title":"docs"},{"location":"#examples","text":"This folder contains examples of several fluid-structure interaction cases, which can serve as starting point for settings up the user's own simulation. They also provide insight into the capabilities of CoCoNuT.","title":"examples"},{"location":"#tests","text":"This folder contains the unit tests. These are created for each piece of code that is added to CoCoNuT and are run regularly, to avoid bugs.","title":"tests"},{"location":"abaqus/","text":"SolverWrapperAbaqus This is the documentation for all Abaqus SolverWrappers. Currently only FSI simulations are supported, no other multiphysics problems. Subcycling within the structural solver is possible. Terminology Main directory : Directory where the Python code will be executed Source directory (for wrapper): .../coconut/coupling_components/solver_wrappers/abaqus/ Extra directory : Subdirectory of the source directory with some files to assist with the setup Working directory : Subdirectory of the main directory where Abaqus will be running Geometrical nodes : Nodes in Abaqus related to the geometry of the elements. At these nodes the displacement data is exported. Loadpoints : Every element has load points. This is where the loads (input to Abaqus) are applied. Environment A working directory for Abaqus needs to be created within the main directory. Its relative path to the main directory should be specified in the .json file. In the CoCoNuT examples this folder is typically called \" CSM \", but any name is allowed. Abaqus needs a host-file called AbaqusHosts.txt file in the working directory . This host-file lists the machines on which Abaqus is allowed to run. One line per requested core, but excessive lines cause no harm. The extra directory contains an Example_makeHostFile.sh which was used the generate a host file for the local system. The Abaqus license server needs to be specified in the parametrized file abaqus_v6.env which is present in the source directory . For use at Ghent University no changes are required. The Abaqus software should be available as wel as compilers to compile the user-subroutines (FORTRAN) and post-processing code (C++). Some compilers also require a license. The extra directory contains a file abaqus_setup which can be sourced in the terminal that will be used to run the simulation. This script loads the Abaqus module as well as the compilers (Ghent University system). Parameters This section describes the Parameters in the JSON file, listed in alphabetical order. A distinction is made between mandatory and optional parameters. Mandatory parameter type description arraysize integer Size specification for array in FORTRAN part of the code. Should be large enough and depends on the number of load points in the structural model. cores integer Number of cores to be used by Abaqus. delta_t float Size of the time step in Abaqus (Should be synchronized with the flow solver). This parameter is usually specified in a higher Component . dimensions integer Dimensionality of the problem (2 or 3). interface_input dict Should contain surfaces keys. Keys are names of ModelParts for Abaqus load points. Each name (key) must be the contain an entry from surfaceIDs . The list that follows specifies the historical variables that should be included in this ModelPart (note the comma). Example: \u2003\"NODESETA_load_points\": [\"PRESSURE\", \"TRACTION\"], \u2003\"NODESETB_load_points\": [\"PRESSURE\", \"TRACTION\"] interface_output dict Similar to interface_input but for Abaqus geometrical nodes. input_file string Name of the input file provided by the user. Example: \u201cBase.inp\u201d mp_mode string Determines how Abaqus is executed in parallel. Should be \u201cTHREADS\u201d as \u201cMPI\u201d is currently not implemented. save_iterations integer Determines what files are kept by Abaqus. All files are saved, but files not corresponding to the save_iterations are removed at the end of a time step. Important for restart options (also in correspondence with the save interval of the flow solver). surfaceIDs list of strings Comma-separated list with the names of the node sets associated with the geometrical nodes on the interface surfaces. Example: [\u201cNODESETA\u201d, \u201cNODESETB\u201d] Important notes: \u2003\u2022 The sequence of these surfaces has to correspond with the integer specified in the corresponding load-surface (see the Input file section). \u2003\u2022 The names of these surfaces should be all UPPERCASE as Abaqus recasts these when opening the .inp file. surfaces integer Number of surfaces on the FSI interface. Should correspond with the number of elements in surfaceIDs . timestep_start integer Time step to start from. Data should be available at this time step. For a new simulation this value will typically be 0. This parameter should be synchronized with the flow solver. This parameter is usually specified in a higher Component . working_directory string Relative path to the directory in which Abaqus will be executed and where all structural information will be stored. Should be created before execution and contain an AbaqusHosts.txt file. timestep_start and delta_t are necessary parameters, but are usually defined in a higher Component . However, they can also be given directly as parameter of the solver wrapper (e.g. for standalone testing). If they are defined both in higher object and in the solver wrapper, then the former value is used and a warning is printed. If different parameters are used with different Abaqus versions, this should be specified both in this section and in the version specific documentation section. Optional parameter type description initialInc float Required when subcycling is enabled. Contains the size of the first substep attempted Abaqus. maxInc float Required when subcycling is enabled. Contains the maximal size allowed for a substep. maxNumInc integer Required when subcycling is enabled. Contains the maximum number of increments that Abaqus is allowed to perform for one time step. minInc float Required when subcycling is enabled. Contains the minimal size allowed for a substep. ramp bool Only used when subcycling is enabled in Abaqus. false : Load is considered to be constant throughout the time step. true : Load is applied in a ramped fashion throughout the time step. subcycling bool false : [Default] Abaqus solves the requested time step using one increment. true : Abaqus is allowed to solve the time step using multiple increments, often required when contact is involved. Input file The Abaqus solver wrapper is configured to start from an input file which contains all necessary information for the calculation. This file should be located in the main directory . Its name should be specified in the .json file via the parameter input_file . For the remainder of this section this file will be referred to as \u201cbase-file\u201d Creation of the base-file is not considered a part of the solver wrapper functionality as it is case-specific. However, in order for the solver wrapper to work, the base-file has to comply with certain general conditions. This section aims at informing the user about the requirements for the base-file. General The base-file needs to be of the \u201c.inp\u201d type, this is an \u201cinput file for Abaqus\u201d. \u201c.inp-files\u201d are created via Abaqus by, after configuration, creating a \u201cjob\u201d and requesting a \u201cwrite input\u201d for that job. These files can be opened in Abaqus by using \u201cfile > import > model\u201d. The base-file has to contain all necessary information about the structural model, which includes: Geometry Mesh Material properties Boundary conditions Surfaces where external loads need to be applied Node sets where displacement data will be extracted Additional loads not dependent on the flow solver Abaqus models contain parts and those parts are used to create assemblies. The base-file should contain one assembly, which will then be used by the coupling. The assembly, thus, determines the position and orientation that will be used by the coupling software. Setup for Abaqus input (loads) Per surface in the fluid-structure interface (where loads and displacements need to be exchanged) a \u201csurface\u201d should be created in the assembly . These surfaces can for example be created from geometry or by creating a \u201cnode set\u201d containing all the nodes on the surface and then calling the SurfaceFromNodeSet method which can be found in the makeSurface.py file in the Extra directory . The name of the surface has to be MOVINGSURFACE followed by an integer . The integer of the surface has to correspond with the index of that specific surface in the surfaceIDs parameter (index starts from 0). For example MOVINGSURFACE0 is associated with the first item in surfaceIDs and MOVINGSURFACE1 would be associated with the second item in surfaceIDs . An example on the use of SurfaceFromNodeSet (via the Python console in Abaqus or a python script for Abaqus): from makeSurface import * my_model = mdb . models [ 'Model-1' ] my_assembly = my_model . rootAssembly my_instance = my_assembly . instances [ 'PART-1-1' ] movingSurface0 = SurfaceFromNodeSet ( my_model , my_instance , 'NAME_OF_THE_NODESET' , 'MOVINGSURFACE0' ) On these surfaces a pressure load and a traction load need to be specified with a user-defined distribution. Loads are assigned to a \u201cstep\u201d. A step is a part of the simulation to which an analysis type, algorithm settings and incrementation settings are assigned that do not change for the duration of the step. In a typical CoCoNuT case only a single step is defined. After creation of the step the loads can be assigned. This can be done via the GUI or using python commands available in Abaqus similar to the following: from step import * step1 = my_model . ImplicitDynamicsStep ( name = 'Step-1' , previous = 'Initial' , timePeriod = 1 , nlgeom = ON , maxNumInc = 1 , haftol = 1 , initialInc = 1 , minInc = 1 , maxInc = 1 , amplitude = RAMP , noStop = OFF , nohaf = ON , initialConditions = OFF , timeIncrementationMethod = FIXED , application = QUASI_STATIC ) step1 . Restart ( frequency = 99999 , overlay = ON ) my_model . Pressure ( name = 'DistributedPressure' , createStepName = 'Step-1' , distributionType = USER_DEFINED , field = '' , magnitude = 1 , region = movingSurface0 ) my_model . SurfaceTraction ( name = 'DistributedShear' , createStepName = 'Step-1' , region = movingSurface0 , magnitude = 1 , traction = GENERAL , directionVector = (( 0 , 0 , 0 ), ( 1 , 0 , 0 )), distributionType = USER_DEFINED ) The second command enables writing of restart files by Abaqus, which is required for running unsteady cases. This can be done from the GUI when the \"step\" module is active, by selecting \"Output\" in the top menu and subsequently \"Restart Requests\". Frequency should be put on 99999 , overlay activated (this saves data since only the last increment is kept) and interval on 1 (also see this Abaqus documentation page ). Note that the step type \"ImplicitDynamicStep\" is an example, it depends on the analysis procedure chosen to run the Abaqus part of the FSI simulation. For a steady simulation this could for example be \"StaticStep\": step1 = my_model . StaticStep ( name = 'Step-1' , previous = 'Initial' , timePeriod = 1.0 , initialInc = 1 , minInc = 1e-4 , maxNumInc = 10 , nlgeom = ON , amplitude = RAMP ) Currently, the Abaqus wrapper automatically checks if the increments comply with the delta_t and subcycling settings and adjusts them accordingly or raises an error, but only for a dynamic step or a static step with subcycling . Attention: Replacing the incrementation settings is done by looking up some keywords in the base file ( *Step , *Dynamic , application ). This procedure fails when these keywords are not found. When using the GUI to create the base file (.inp) and using the default settings for the step, often the keyword application is not written. It is hence advised not to use the default settings but use an application (quasi-static works for most cases and also moderate dissipation is allowed). If sub-cycling is not enabled, the maximal number of increments should be 1 ( inc=1 ), otherwise an error is raised. This behavior may be changed in future versions of the code. The lines in the input file should look similar to this: *Step, name=Step-1, nlgeom=YES, inc=1 *Dynamic,application=QUASI-STATIC,direct,nohaf,initial=NO 0.0001,0.0001, The time step (0.0001) will in this case be replaced by settings found in the json-file. More information can be found in this Abaqus documentation page . Setup for Abaqus output (displacements) After creation of the step Abaqus needs to be instructed about what to output at the end of a calculation. A fieldOutput has to be generated covering all locations involved in the fluid-structure interface. To do so it is best to create node sets in the assembly containing all structural nodes of the surfaces (if this had not been done before) and to create a fieldOutput per surface containing at least the coordinates and the displacements. In the previous section an example was given of how a surface can be created from a node set, but the other way around is also possible, creating a node set from a surface (presuming that this surface was already created): my_model = mdb . models [ 'Model-1' ] my_assembly = my_model . rootAssembly movingSurface0 = my_assembly . surfaces [ \"MOVINGSURFACE0\" ] outputSet = my_assembly . Set ( name = 'NAME_OF_THE_NODESET' , nodes = movingSurface0 . nodes ) my_model . FieldOutputRequest ( createStepName = 'Step-1' , frequency = LAST_INCREMENT , name = 'F-Output-1' , region = my_assembly . sets [ 'NAME_OF_THE_NODE_SET' ], variables = ( 'COORD' , 'U' )) Furthermore, it is interesting (for post-processing and debugging) to preserve the default Abaqus output and therefore also configure a fieldOutput and historyOutput with PRESELECTED variables. This can be done via the GUI or using python lines similar to the following: my_model . FieldOutputRequest ( createStepName = 'Step-1' , frequency = LAST_INCREMENT , name = 'F-Output-2' , variables = PRESELECT ) my_model . HistoryOutputRequest ( createStepName = 'Step-1' , frequency = LAST_INCREMENT , name = 'H-Output-1' , variables = PRESELECT ) ModelParts The created \"surfaces\" and \"node sets\" for load input and displacement output respectively, correspond to ModelParts in the CoCoNuT code, a representation of the data used for the coupling. It is strongly advised to sub-divide to fluid-structure interaction interface intelligently, depending on the geometry. As a rule of thumb it can be said that a surfaces at two sides of a sharp corner should be assigned to a different ModelPart. As the interpolation is based on shortest distance, issues can arise at sharp corners. Those are avoided by having different ModelParts at each side of the corner. Another reason to do this is because the code cannot handle elements with two or more faces being part of the same ModelPart. This situation would occur if the surface contains corners. An example is an airfoil where the suction side and pressure side belong to the same ModelPart: elements at the trailing edge will have (a) face(s) at both the pressure side and suction side. Even when the code would allow this, interpolation mistakes become likely, as a Node on the suction side could have a nearest neighbour on the pressure side, causing that the wrong data is used for interpolation.","title":"SolverWrapperAbaqus"},{"location":"abaqus/#solverwrapperabaqus","text":"This is the documentation for all Abaqus SolverWrappers. Currently only FSI simulations are supported, no other multiphysics problems. Subcycling within the structural solver is possible.","title":"SolverWrapperAbaqus"},{"location":"abaqus/#terminology","text":"Main directory : Directory where the Python code will be executed Source directory (for wrapper): .../coconut/coupling_components/solver_wrappers/abaqus/ Extra directory : Subdirectory of the source directory with some files to assist with the setup Working directory : Subdirectory of the main directory where Abaqus will be running Geometrical nodes : Nodes in Abaqus related to the geometry of the elements. At these nodes the displacement data is exported. Loadpoints : Every element has load points. This is where the loads (input to Abaqus) are applied.","title":"Terminology"},{"location":"abaqus/#environment","text":"A working directory for Abaqus needs to be created within the main directory. Its relative path to the main directory should be specified in the .json file. In the CoCoNuT examples this folder is typically called \" CSM \", but any name is allowed. Abaqus needs a host-file called AbaqusHosts.txt file in the working directory . This host-file lists the machines on which Abaqus is allowed to run. One line per requested core, but excessive lines cause no harm. The extra directory contains an Example_makeHostFile.sh which was used the generate a host file for the local system. The Abaqus license server needs to be specified in the parametrized file abaqus_v6.env which is present in the source directory . For use at Ghent University no changes are required. The Abaqus software should be available as wel as compilers to compile the user-subroutines (FORTRAN) and post-processing code (C++). Some compilers also require a license. The extra directory contains a file abaqus_setup which can be sourced in the terminal that will be used to run the simulation. This script loads the Abaqus module as well as the compilers (Ghent University system).","title":"Environment"},{"location":"abaqus/#parameters","text":"This section describes the Parameters in the JSON file, listed in alphabetical order. A distinction is made between mandatory and optional parameters.","title":"Parameters"},{"location":"abaqus/#mandatory","text":"parameter type description arraysize integer Size specification for array in FORTRAN part of the code. Should be large enough and depends on the number of load points in the structural model. cores integer Number of cores to be used by Abaqus. delta_t float Size of the time step in Abaqus (Should be synchronized with the flow solver). This parameter is usually specified in a higher Component . dimensions integer Dimensionality of the problem (2 or 3). interface_input dict Should contain surfaces keys. Keys are names of ModelParts for Abaqus load points. Each name (key) must be the contain an entry from surfaceIDs . The list that follows specifies the historical variables that should be included in this ModelPart (note the comma). Example: \u2003\"NODESETA_load_points\": [\"PRESSURE\", \"TRACTION\"], \u2003\"NODESETB_load_points\": [\"PRESSURE\", \"TRACTION\"] interface_output dict Similar to interface_input but for Abaqus geometrical nodes. input_file string Name of the input file provided by the user. Example: \u201cBase.inp\u201d mp_mode string Determines how Abaqus is executed in parallel. Should be \u201cTHREADS\u201d as \u201cMPI\u201d is currently not implemented. save_iterations integer Determines what files are kept by Abaqus. All files are saved, but files not corresponding to the save_iterations are removed at the end of a time step. Important for restart options (also in correspondence with the save interval of the flow solver). surfaceIDs list of strings Comma-separated list with the names of the node sets associated with the geometrical nodes on the interface surfaces. Example: [\u201cNODESETA\u201d, \u201cNODESETB\u201d] Important notes: \u2003\u2022 The sequence of these surfaces has to correspond with the integer specified in the corresponding load-surface (see the Input file section). \u2003\u2022 The names of these surfaces should be all UPPERCASE as Abaqus recasts these when opening the .inp file. surfaces integer Number of surfaces on the FSI interface. Should correspond with the number of elements in surfaceIDs . timestep_start integer Time step to start from. Data should be available at this time step. For a new simulation this value will typically be 0. This parameter should be synchronized with the flow solver. This parameter is usually specified in a higher Component . working_directory string Relative path to the directory in which Abaqus will be executed and where all structural information will be stored. Should be created before execution and contain an AbaqusHosts.txt file. timestep_start and delta_t are necessary parameters, but are usually defined in a higher Component . However, they can also be given directly as parameter of the solver wrapper (e.g. for standalone testing). If they are defined both in higher object and in the solver wrapper, then the former value is used and a warning is printed. If different parameters are used with different Abaqus versions, this should be specified both in this section and in the version specific documentation section.","title":"Mandatory"},{"location":"abaqus/#optional","text":"parameter type description initialInc float Required when subcycling is enabled. Contains the size of the first substep attempted Abaqus. maxInc float Required when subcycling is enabled. Contains the maximal size allowed for a substep. maxNumInc integer Required when subcycling is enabled. Contains the maximum number of increments that Abaqus is allowed to perform for one time step. minInc float Required when subcycling is enabled. Contains the minimal size allowed for a substep. ramp bool Only used when subcycling is enabled in Abaqus. false : Load is considered to be constant throughout the time step. true : Load is applied in a ramped fashion throughout the time step. subcycling bool false : [Default] Abaqus solves the requested time step using one increment. true : Abaqus is allowed to solve the time step using multiple increments, often required when contact is involved.","title":"Optional"},{"location":"abaqus/#input-file","text":"The Abaqus solver wrapper is configured to start from an input file which contains all necessary information for the calculation. This file should be located in the main directory . Its name should be specified in the .json file via the parameter input_file . For the remainder of this section this file will be referred to as \u201cbase-file\u201d Creation of the base-file is not considered a part of the solver wrapper functionality as it is case-specific. However, in order for the solver wrapper to work, the base-file has to comply with certain general conditions. This section aims at informing the user about the requirements for the base-file.","title":"Input file"},{"location":"abaqus/#general","text":"The base-file needs to be of the \u201c.inp\u201d type, this is an \u201cinput file for Abaqus\u201d. \u201c.inp-files\u201d are created via Abaqus by, after configuration, creating a \u201cjob\u201d and requesting a \u201cwrite input\u201d for that job. These files can be opened in Abaqus by using \u201cfile > import > model\u201d. The base-file has to contain all necessary information about the structural model, which includes: Geometry Mesh Material properties Boundary conditions Surfaces where external loads need to be applied Node sets where displacement data will be extracted Additional loads not dependent on the flow solver Abaqus models contain parts and those parts are used to create assemblies. The base-file should contain one assembly, which will then be used by the coupling. The assembly, thus, determines the position and orientation that will be used by the coupling software.","title":"General"},{"location":"abaqus/#setup-for-abaqus-input-loads","text":"Per surface in the fluid-structure interface (where loads and displacements need to be exchanged) a \u201csurface\u201d should be created in the assembly . These surfaces can for example be created from geometry or by creating a \u201cnode set\u201d containing all the nodes on the surface and then calling the SurfaceFromNodeSet method which can be found in the makeSurface.py file in the Extra directory . The name of the surface has to be MOVINGSURFACE followed by an integer . The integer of the surface has to correspond with the index of that specific surface in the surfaceIDs parameter (index starts from 0). For example MOVINGSURFACE0 is associated with the first item in surfaceIDs and MOVINGSURFACE1 would be associated with the second item in surfaceIDs . An example on the use of SurfaceFromNodeSet (via the Python console in Abaqus or a python script for Abaqus): from makeSurface import * my_model = mdb . models [ 'Model-1' ] my_assembly = my_model . rootAssembly my_instance = my_assembly . instances [ 'PART-1-1' ] movingSurface0 = SurfaceFromNodeSet ( my_model , my_instance , 'NAME_OF_THE_NODESET' , 'MOVINGSURFACE0' ) On these surfaces a pressure load and a traction load need to be specified with a user-defined distribution. Loads are assigned to a \u201cstep\u201d. A step is a part of the simulation to which an analysis type, algorithm settings and incrementation settings are assigned that do not change for the duration of the step. In a typical CoCoNuT case only a single step is defined. After creation of the step the loads can be assigned. This can be done via the GUI or using python commands available in Abaqus similar to the following: from step import * step1 = my_model . ImplicitDynamicsStep ( name = 'Step-1' , previous = 'Initial' , timePeriod = 1 , nlgeom = ON , maxNumInc = 1 , haftol = 1 , initialInc = 1 , minInc = 1 , maxInc = 1 , amplitude = RAMP , noStop = OFF , nohaf = ON , initialConditions = OFF , timeIncrementationMethod = FIXED , application = QUASI_STATIC ) step1 . Restart ( frequency = 99999 , overlay = ON ) my_model . Pressure ( name = 'DistributedPressure' , createStepName = 'Step-1' , distributionType = USER_DEFINED , field = '' , magnitude = 1 , region = movingSurface0 ) my_model . SurfaceTraction ( name = 'DistributedShear' , createStepName = 'Step-1' , region = movingSurface0 , magnitude = 1 , traction = GENERAL , directionVector = (( 0 , 0 , 0 ), ( 1 , 0 , 0 )), distributionType = USER_DEFINED ) The second command enables writing of restart files by Abaqus, which is required for running unsteady cases. This can be done from the GUI when the \"step\" module is active, by selecting \"Output\" in the top menu and subsequently \"Restart Requests\". Frequency should be put on 99999 , overlay activated (this saves data since only the last increment is kept) and interval on 1 (also see this Abaqus documentation page ). Note that the step type \"ImplicitDynamicStep\" is an example, it depends on the analysis procedure chosen to run the Abaqus part of the FSI simulation. For a steady simulation this could for example be \"StaticStep\": step1 = my_model . StaticStep ( name = 'Step-1' , previous = 'Initial' , timePeriod = 1.0 , initialInc = 1 , minInc = 1e-4 , maxNumInc = 10 , nlgeom = ON , amplitude = RAMP ) Currently, the Abaqus wrapper automatically checks if the increments comply with the delta_t and subcycling settings and adjusts them accordingly or raises an error, but only for a dynamic step or a static step with subcycling . Attention: Replacing the incrementation settings is done by looking up some keywords in the base file ( *Step , *Dynamic , application ). This procedure fails when these keywords are not found. When using the GUI to create the base file (.inp) and using the default settings for the step, often the keyword application is not written. It is hence advised not to use the default settings but use an application (quasi-static works for most cases and also moderate dissipation is allowed). If sub-cycling is not enabled, the maximal number of increments should be 1 ( inc=1 ), otherwise an error is raised. This behavior may be changed in future versions of the code. The lines in the input file should look similar to this: *Step, name=Step-1, nlgeom=YES, inc=1 *Dynamic,application=QUASI-STATIC,direct,nohaf,initial=NO 0.0001,0.0001, The time step (0.0001) will in this case be replaced by settings found in the json-file. More information can be found in this Abaqus documentation page .","title":"Setup for Abaqus input (loads)"},{"location":"abaqus/#setup-for-abaqus-output-displacements","text":"After creation of the step Abaqus needs to be instructed about what to output at the end of a calculation. A fieldOutput has to be generated covering all locations involved in the fluid-structure interface. To do so it is best to create node sets in the assembly containing all structural nodes of the surfaces (if this had not been done before) and to create a fieldOutput per surface containing at least the coordinates and the displacements. In the previous section an example was given of how a surface can be created from a node set, but the other way around is also possible, creating a node set from a surface (presuming that this surface was already created): my_model = mdb . models [ 'Model-1' ] my_assembly = my_model . rootAssembly movingSurface0 = my_assembly . surfaces [ \"MOVINGSURFACE0\" ] outputSet = my_assembly . Set ( name = 'NAME_OF_THE_NODESET' , nodes = movingSurface0 . nodes ) my_model . FieldOutputRequest ( createStepName = 'Step-1' , frequency = LAST_INCREMENT , name = 'F-Output-1' , region = my_assembly . sets [ 'NAME_OF_THE_NODE_SET' ], variables = ( 'COORD' , 'U' )) Furthermore, it is interesting (for post-processing and debugging) to preserve the default Abaqus output and therefore also configure a fieldOutput and historyOutput with PRESELECTED variables. This can be done via the GUI or using python lines similar to the following: my_model . FieldOutputRequest ( createStepName = 'Step-1' , frequency = LAST_INCREMENT , name = 'F-Output-2' , variables = PRESELECT ) my_model . HistoryOutputRequest ( createStepName = 'Step-1' , frequency = LAST_INCREMENT , name = 'H-Output-1' , variables = PRESELECT )","title":"Setup for Abaqus output (displacements)"},{"location":"abaqus/#modelparts","text":"The created \"surfaces\" and \"node sets\" for load input and displacement output respectively, correspond to ModelParts in the CoCoNuT code, a representation of the data used for the coupling. It is strongly advised to sub-divide to fluid-structure interaction interface intelligently, depending on the geometry. As a rule of thumb it can be said that a surfaces at two sides of a sharp corner should be assigned to a different ModelPart. As the interpolation is based on shortest distance, issues can arise at sharp corners. Those are avoided by having different ModelParts at each side of the corner. Another reason to do this is because the code cannot handle elements with two or more faces being part of the same ModelPart. This situation would occur if the surface contains corners. An example is an airfoil where the suction side and pressure side belong to the same ModelPart: elements at the trailing edge will have (a) face(s) at both the pressure side and suction side. Even when the code would allow this, interpolation mistakes become likely, as a Node on the suction side could have a nearest neighbour on the pressure side, causing that the wrong data is used for interpolation.","title":"ModelParts"},{"location":"convergence_criteria/","text":"Convergence criteria Convergence criteria are an essential part of numerical tools. They should be chosen wisely in order to obtain a reasonably accurate solution without performing more iterations than needed. This documentation describes how the user can practically assemble a set of convergence criteria. Iteration limit The type convergence_criterion.iteration_limit is satisfied if the number of coupling iterations equals or is larger than a predefined maximum. Settings The settings dictionary contains one entry: parameter type description maximum int Maximum number of iterations. Absolute norm The type convergence_criterion.absolute_norm is satisfied if the p p -norm of the residual in the last coupling iteration is smaller than a predefined tolerance . The p p -norm of the residual r r is defined as \\Vert r \\Vert_p = \\left(\\sum_{i=1}^n \\vert r_{i}\\vert^p\\right)^{1/p} \\Vert r \\Vert_p = \\left(\\sum_{i=1}^n \\vert r_{i}\\vert^p\\right)^{1/p} Settings The settings are as follows: parameter type description tolerance double Limit value for convergence. order int Order p p of the norm. Relative norm This type ( convergence_criterion.relative_norm ) is completely analogous to the absolute norm. Instead of the norm of the last residual being smaller than a set tolerance , now the ratio norm of the residual of the last coupling iteration to the norm of the residual of the first coupling iteration is compared to a tolerance . Settings These are the same as for convergence_criterion.absolute_norm . Combining multiple convergence criteria In most cases, it is wise to combine two criteria: one to ensure a high enough accuracy and an iteration limit in order to break loops that are not converging fast enough. In that case, the criteria are combined via or or and statements. In that case, the type is set to convergence_criterion.or (alternatively, convergence_criterion.and ) and the settings contain a criteria_list that contains single criteria in the same way as described above. In the following example, the iteration_limit and relative_norm criteria are combined using an or statement. { \"type\" : \"convergence_criteria.or\" , \"settings\" : { \"criteria_list\" : [ { \"type\" : \"convergence_criteria.iteration_limit\" , \"settings\" : { \"maximum\" : 20 } }, { \"type\" : \"convergence_criteria.relative_norm\" , \"settings\" : { \"tolerance\" : 1e-3 , \"order\" : 2 } } ] } }","title":"Convergence criteria"},{"location":"convergence_criteria/#convergence-criteria","text":"Convergence criteria are an essential part of numerical tools. They should be chosen wisely in order to obtain a reasonably accurate solution without performing more iterations than needed. This documentation describes how the user can practically assemble a set of convergence criteria.","title":"Convergence criteria"},{"location":"convergence_criteria/#iteration-limit","text":"The type convergence_criterion.iteration_limit is satisfied if the number of coupling iterations equals or is larger than a predefined maximum.","title":"Iteration limit"},{"location":"convergence_criteria/#settings","text":"The settings dictionary contains one entry: parameter type description maximum int Maximum number of iterations.","title":"Settings"},{"location":"convergence_criteria/#absolute-norm","text":"The type convergence_criterion.absolute_norm is satisfied if the p p -norm of the residual in the last coupling iteration is smaller than a predefined tolerance . The p p -norm of the residual r r is defined as \\Vert r \\Vert_p = \\left(\\sum_{i=1}^n \\vert r_{i}\\vert^p\\right)^{1/p} \\Vert r \\Vert_p = \\left(\\sum_{i=1}^n \\vert r_{i}\\vert^p\\right)^{1/p}","title":"Absolute norm"},{"location":"convergence_criteria/#settings_1","text":"The settings are as follows: parameter type description tolerance double Limit value for convergence. order int Order p p of the norm.","title":"Settings"},{"location":"convergence_criteria/#relative-norm","text":"This type ( convergence_criterion.relative_norm ) is completely analogous to the absolute norm. Instead of the norm of the last residual being smaller than a set tolerance , now the ratio norm of the residual of the last coupling iteration to the norm of the residual of the first coupling iteration is compared to a tolerance .","title":"Relative norm"},{"location":"convergence_criteria/#settings_2","text":"These are the same as for convergence_criterion.absolute_norm .","title":"Settings"},{"location":"convergence_criteria/#combining-multiple-convergence-criteria","text":"In most cases, it is wise to combine two criteria: one to ensure a high enough accuracy and an iteration limit in order to break loops that are not converging fast enough. In that case, the criteria are combined via or or and statements. In that case, the type is set to convergence_criterion.or (alternatively, convergence_criterion.and ) and the settings contain a criteria_list that contains single criteria in the same way as described above. In the following example, the iteration_limit and relative_norm criteria are combined using an or statement. { \"type\" : \"convergence_criteria.or\" , \"settings\" : { \"criteria_list\" : [ { \"type\" : \"convergence_criteria.iteration_limit\" , \"settings\" : { \"maximum\" : 20 } }, { \"type\" : \"convergence_criteria.relative_norm\" , \"settings\" : { \"tolerance\" : 1e-3 , \"order\" : 2 } } ] } }","title":"Combining multiple convergence criteria"},{"location":"coupled_solvers/","text":"Coupled solvers This documentation describes the coupled solvers that are available. A coupled solver refers to a coupling algortihm used to couple the two solvers. Some coupled solvers implement one or more models. An odd one out is test_single_solver which allows to test only one solver by coupling it to a dummy solver. All coupled solvers inherit from gauss_seidel . In the parameter JSON file, the dictionary coupled_solver holds the type and the dictionary settings , but also the dictionary predictor , the dictionary convergence_criterion and the list solver_wrappers containing 2 dictionaries, one for each solver_wrapper . More information on these last three can be found in respectively predictors , convergence_criteria and the solver_wrappers documentation. GaussSeidel The type for this coupled_solver is coupled_solvers.gauss_seidel . Algorithm Gauss-Seidel iterations are the simplest way of coupling two solvers. In this coupling method fixed point iterations are performed as the output of one solver is given to the other one without adjustment. Basic schematic is given in the following figure. Here, \\mathcal{F} \\mathcal{F} is the first solver with input x x and output \\tilde{y} \\tilde{y} and \\mathcal{S} \\mathcal{S} is the second solver with input y y and output \\tilde{x} \\tilde{x} Gauss-Seidel iterations are very simple, but unstable for cases with high added mass. Settings The following parameters need to be included in the settings dictionary. Here they are listed in alphabetical order. parameter type description delta_t double Fixed time step size used in both solvers. For a steady simulation typically a value of 1 is taken. name string (optional) Name of the case used to store a pickle file with results. If not provided 'results' is used. save_results bool (optional) Default: false. If true a pickle file is stored containing some main results: the value of the displacement and load on the interface for every time step, interface objects used by the two solvers, the number of coupling iterations per time step, the total elapsed time for the calculation, the residual after every coupling iteration and the values of delta_t and timestep_start . This file is used by the postprocessing files included with the examples. time_step_start int Time step number to (re)start a transient FSI calculation. If 0 is given, the simulation starts from scratch. Otherwise, the code looks for the relevant files to start from the corresponding time step. Not every solver implements restart, see the solver documentation for more information. For a steady simulation this should be 0. timestep_start and delta_t are necessary parameters (also in a steady simulation), but can also defined in the solverwrapper directly (e.g. for standalone testing). If they are defined both here and in the solver wrapper, then the former value is used and a warning is printed. These parameters should also be specified for the coupled solvers inheriting from GaussSeidel . Relaxation This coupled_solver inherits from GaussSeidel . The type for this coupled_solver is coupled_solvers.relaxation . Algorithm Gauss-Seidel iterations are very simple, but are unstable for cases with high added mass. An approach to mitigate this is applying relaxation, also called simple mixing. In this coupling method the output of first solver is still given to the other one without adjustment, but the output of the second solver is relaxed as follows: $$ x^{k+1}=(1-\\omega)x^k+\\omega\\tilde{x}^k=x^k+\\omega r^k $$ with x^k x^k and \\tilde{x}^k \\tilde{x}^k , respectively the input for the first solver and the output of the second solver in iteration k k . The difference between both is called the residual r^k=\\tilde{x}^k-x^k r^k=\\tilde{x}^k-x^k . The mixing or relaxation factor is \\omega \\omega . A symbolic schematic is given in the following figure. Here, \\mathcal{F} \\mathcal{F} is the first solver with input x x and output \\tilde{y} \\tilde{y} and \\mathcal{S} \\mathcal{S} is the second solver with input y y and output \\tilde{x} \\tilde{x} A lower \\omega \\omega increases stability, but decreases convergence speed. This method is again quite simple, but still often unstable for cases with high added mass. Settings Besides the parameters required in GaussSeidel , the following parameters need to be included in the settings dictionary. They are listed in alphabetical order. parameter type description omega double Relaxation factor. Aitken This coupled_solver inherits from GaussSeidel . The type for this coupled_solver is coupled_solvers.aitken . Algorithm Gauss-Seidel iterations are very simple, but are unstable for cases with high added mass. An approach to mitigate this is applying relaxation. However, the choice of a relaxation factor can be difficult. In this coupling method a dynamic relaxation factor is used. The output of first solver is still given to the other one without adjustment, but the output of the second solver is relaxed as follows: $$ x^{k+1}=(1-\\omega^k)x^k+\\omega^k\\tilde{x}^k=x^k+\\omega^k r^k $$ with x^k x^k and \\tilde{x}^k \\tilde{x}^k , respectively the input for the first solver and the output of the second solver in iteration k k . The difference between both is called the residual r^k=\\tilde{x}^k-x^k r^k=\\tilde{x}^k-x^k . The mixing or relaxation factor is \\omega^k \\omega^k is dynamic in the sense that its value changes between iterations. A symbolic schematic is given in the following figure. Here, \\mathcal{F} \\mathcal{F} is the first solver with input x x and output \\tilde{y} \\tilde{y} and \\mathcal{S} \\mathcal{S} is the second solver with input y y and output \\tilde{x} \\tilde{x} The value of \\omega^k \\omega^k is determined by applying the secant method for scalars directly to vectors and projecting it on r^k-r^{k-1} r^k-r^{k-1} as follows $$ \\omega^k=-\\omega^{k-1}\\frac{(r^{k-1})^T(r^k-r^{k-1})}{(r^k-r^{k-1})^T(r^k-r^{k-1})}. $$ The first relaxation factor in a time step is equal to the last relaxation factor from the previous time step \\omega^n \\omega^n , but limited to \\omega^{max} \\omega^{max} . $$ \\omega^0=\\textrm{sign}(\\omega^n)\\min(|\\omega^n|,\\omega^{max}). $$ The relaxation factor in the first time step is equal to \\omega^{max} \\omega^{max} . This method improves convergence speed drastically compared to Gauss-Seidel iterations, but even faster convergence can be obtained using quasi-Newton methods which take into account sensitivities. Settings Besides the parameters required in GaussSeidel , the following parameters need to be included in the settings dictionary. They are listed in alphabetical order. parameter type description omega_max double Maximal relaxation factor. IQNI This coupled_solver inherits from GaussSeidel . The type for this coupled_solver is coupled_solvers.iqni . Algorithm The abbreviation IQNI refers to interface quasi-Newton with inverse Jacobian . In this type of coupling iteration, the combination of the two solvers is seen as one system. The input of the first solver in iteration k k is denoted by x^k x^k . The output of this solver is transferred unchanged to the second solver. The output of the second solver is denoted \\tilde{x}^k \\tilde{x}^k . The difference between input and output is called the residual r^k=\\tilde{x}^k-x^k r^k=\\tilde{x}^k-x^k . A residual operator \\mathcal{R}(x) \\mathcal{R}(x) is defined which return the residual r^k r^k as a function of x^k x^k . The goal is to find x x for which \\mathcal{R}(x)=0 \\mathcal{R}(x)=0 . This system of non-linear equations is solved using Newton-Raphson iterations as follows $$ x^{k+1}=x^k-\\mathcal{R}'^{-1}(x^k)r^k, $$ where \\mathcal{R}' \\mathcal{R}' is the Jacobian of \\mathcal{R} \\mathcal{R} . However, this Jacobian is not accessible and is therefore approximated. Note that the iteration update can also be written as $$ \\Delta x^k=\\mathcal{R}'^{-1}(x^k)\\Delta r^k; $$ where \\Delta x^k=x^{k+1}-x^k \\Delta x^k=x^{k+1}-x^k is the difference between the input of two subsequent iterations and \\Delta r^k=0-r^k=-r^k \\Delta r^k=0-r^k=-r^k is the difference between the desired and the current residual. Likewise, \\Delta\\tilde{x}^k=\\tilde{x}^{k+1}-\\tilde{x}^k \\Delta\\tilde{x}^k=\\tilde{x}^{k+1}-\\tilde{x}^k is the difference between the the output of two subsequent iterations. Instead of approximating \\mathcal{R}'^{-1} \\mathcal{R}'^{-1} directly, the inverse Jacobian of \\tilde{\\mathcal{R}} \\tilde{\\mathcal{R}} is approximated. This altered residual operator is defined as follows $$ r^{k+1}=\\tilde{\\mathcal{R}}(\\tilde{x}^{k+1})=\\mathcal{R}(\\tilde{x}^{k+1}-r^{k+1}). $$ The inverse of both Jacobians are linked by $$ \\tilde{\\mathcal{R}}'^{-1}=\\mathcal{R}'^{-1}+I, $$ where \\tilde{\\mathcal{R}}' \\tilde{\\mathcal{R}}' is the Jacobian of \\tilde{\\mathcal{R}} \\tilde{\\mathcal{R}} with respect to \\tilde{x} \\tilde{x} and I I is the identity matrix. For this Jacobian the following is valid $$ \\Delta \\tilde{x}^k=\\tilde{\\mathcal{R}}'^{-1}(x^k)\\Delta r^k. $$ This Jacobian is also not known, but is approximated using a model denoted by \\tilde{N}^k \\tilde{N}^k . The type of model and its settings are specified in the settings dictionary. This model returns an estimation of \\Delta\\tilde{x}^k \\Delta\\tilde{x}^k given \\Delta r^k=-r^k \\Delta r^k=-r^k $$ \\Delta\\tilde{x}^k=\\tilde{N}^k \\Delta r^k. $$ Finally resulting in the update formula $$ x^{k+1}=x^k+(\\tilde{N}^k-I)\\Delta r^k=x^k-\\tilde{N}^k r^k+r^k. $$ A symbolic schematic is given in the following figure. Here, \\mathcal{F} \\mathcal{F} is the first solver with input x x and output \\tilde{y} \\tilde{y} and \\mathcal{S} \\mathcal{S} is the second solver with input y y and output \\tilde{x} \\tilde{x} For more information refer to models . Settings Besides the parameters required in GaussSeidel , the following parameters need to be included in the settings dictionary. They are listed in alphabetical order. parameter type description model dict Model component. omega double Relaxation factor. IBQN This coupled_solver inherits from GaussSeidel . The type for this coupled_solver is coupled_solvers.ibqn . Algorithm The abbreviation IBQN refers to interface block quasi-Newton . In type of coupling iteration, the system $$ \\begin{cases} \\mathcal{F}(x)-y=0 \\newline \\mathcal{S}(y)-x=0 \\end{cases} $$ is solved in block form. Here, \\mathcal{F} \\mathcal{F} is the first solver with input x x and output \\tilde{y} \\tilde{y} and \\mathcal{S} \\mathcal{S} is the second solver with input y y and output \\tilde{x} \\tilde{x} In this iteration scheme, the output of each solver is altered before being transferred to the other one. Solving the system in block Newton-Raphson iterations results in $$ \\begin{bmatrix} \\mathcal{F}'(x) & -I \\newline -I & \\mathcal{S}'(y) \\end{bmatrix} \\begin{bmatrix} \\Delta x \\newline \\Delta y \\end{bmatrix} =- \\begin{bmatrix} \\mathcal{F}(x)-y \\newline \\mathcal{S}(y)-x \\end{bmatrix}, $$ where \\mathcal{F}' \\mathcal{F}' and \\mathcal{S}' \\mathcal{S}' denote the Jacobians of the first and second solver, respectively. These Jacobians are however not accessible and are approximated using a model as specified in the settings dictionary. To the fist and second solver correspond model_f , denoted here by M_f M_f , and model_s , denoted bye M_s M_s , respectively. For example, model_f returns an estimation of \\Delta\\tilde{y}^k=\\tilde{y}^{k+1}-\\tilde{y}^k \\Delta\\tilde{y}^k=\\tilde{y}^{k+1}-\\tilde{y}^k given \\Delta x^k=x^{k+1}-x^k \\Delta x^k=x^{k+1}-x^k $$ \\Delta\\tilde{y}^k=M_f^k \\Delta x^k. $$ Solving for x^{k+1}=x^k+\\Delta x^k x^{k+1}=x^k+\\Delta x^k requires solving the system $$ \\left(I-M_s^k M_f^k\\right)\\Delta x^k =\\tilde{x}^k-x^k+M_s^k(\\tilde{y}^k-y^k) $$ for \\Delta x^k \\Delta x^k . This done matrix-free using a GMRES method. Analogously, the input y^{k+1}=y^k+\\Delta y^k y^{k+1}=y^k+\\Delta y^k for the structural solver by solving $$ \\left(I-M_f^{k+1}M_s^k\\right)\\Delta y^k =\\tilde{y}^{k+1}-y^k+M_f^{k+1}(\\tilde{x}^k-x^{k+1}) $$ for \\Delta y^k \\Delta y^k . A symbolic schematic is given in the following figure. For more information refer to . Settings Besides the parameters required in GaussSeidel , the following parameters need to be included in the settings dictionary. They are listed in alphabetical order. parameter type description absolute_tolerance_gmres double Absolute tolerance used in the GMRES method. model_f dict Model component corresponding to the first solver wrapper. model_s dict Model component corresponding to the second solver wrapper. omega double Relaxation factor. relative_tolerance_gmres double Relative tolerance used in the GMRES method. Test single solver The solver test_single_solver can be used to test new cases and solver settings. The idea behind this component is to only test one of the two solvers, while the other one is replaced by a dummy. This test environment inherits from GaussSeidel . The type for this coupled_solver is coupled_solvers.test_single_solver . Dummy solver To test only one solver, a dummy solver must be used. Such a dummy solver is implemented by a test class in the file dummy_solver.py , which has to be on the same folder level as run_simulation.py . Upon run-time an instance of this class is made. The test class requires methods of the form calculate_<variable>(x,y,z,n) , with <variable> being the variable(s) required by the tested solver, e.g. displacement , pressure or traction . How these variables are defined inside these methods, is up to the user. However, the methods need to return the right format: a 3-element list or numpy array for vector variables and a 1-element list or numpy array for scalar variables. Some examples are given in the example test_single_solver The test class name is provided in the JSON settings as a string. If no test class is provided or the value None is used, zero input will be used. Settings The JSON settings for this test environment test_single_solver are different from the other coupled_solvers in the sense that they only require the type , which is coupled_solvers.test_single_solver , the dictionary test_settings and the list solver_wrappers containing at least one solver_wrapper . The possibilities for the test_settings dictionary are listed in alphabetical order below. parameter type description delta_t double (optional) Time step size to be used in the test. Is optional as long as this value is defined in the settings dictionary. If a different value is defined in both dictionaries, the one defined in test_settings is chosen. name string (optional) Name of the case used to store a pickle file with results. If not provided 'results' is used. The pickle file will have the name <name>_<test_solver_working_directory>.pickle . save_results bool (optional) Default: false. If true a pickle file is stored containing some main results as in gauss_seidel . solver_index int Has a value 0 or 1 and indicates the solver that one wants to test. 0 indicates the first solver_wrapper that appears in the JSON-file, 1 the second one. test_class string (optional) Refers to the class to use in the dummy_solver.py . If not provided or None , zero input will be used. timestep_start int (optional) Time step to start from. If not provided the value defined in the settings dictionary is used. If the settings dictionary is not present, zero is used. Other dictionaries, used for the actual calculation can be kept, but will not be used, with the possible exception of the settings dictionary. The settings dictionary is used to look up delta_t , timestep_start , save_results and name if not provided in test_settings . Note that test_settings has priority over the parameters defined in settings . This means a calculation can be tested, by only adding the test_settings dictionary and changing the coupled_solver type to coupled_solvers.test_single_solver and without altering anything else. An illustration can be found in the example test_single_solver . The working directory of the solver is copied to a new directory with the same name and a suffix _testX with X an integer starting from 0. As such, previous test solver working directories are not overwritten. The optional pickle file saving some results uses the name as specified by the JSON settings followed by an underscore and the solver test working directory. As such the pickle file always belongs to the corresponding test working directory. During run time, the norm of x x and y y are printed. A residual does not exist here. The arrays x x and y y do not have a physical meaning but are the in- and output of the solver: the output of a typical flow solver, for example, will contain pressure and traction components for all points. For the first solver in the solver_wrappers list, x x and y y are respectively in- and output, whereas for the second, y y is the input an x x the output. Nonetheless, these values can be useful to verify that the solver_wrapper runs. The test environment test_single_solver tests only the solver_wrapper itself, no mapping is included.","title":"Coupled solvers"},{"location":"coupled_solvers/#coupled-solvers","text":"This documentation describes the coupled solvers that are available. A coupled solver refers to a coupling algortihm used to couple the two solvers. Some coupled solvers implement one or more models. An odd one out is test_single_solver which allows to test only one solver by coupling it to a dummy solver. All coupled solvers inherit from gauss_seidel . In the parameter JSON file, the dictionary coupled_solver holds the type and the dictionary settings , but also the dictionary predictor , the dictionary convergence_criterion and the list solver_wrappers containing 2 dictionaries, one for each solver_wrapper . More information on these last three can be found in respectively predictors , convergence_criteria and the solver_wrappers documentation.","title":"Coupled solvers"},{"location":"coupled_solvers/#gaussseidel","text":"The type for this coupled_solver is coupled_solvers.gauss_seidel .","title":"GaussSeidel"},{"location":"coupled_solvers/#algorithm","text":"Gauss-Seidel iterations are the simplest way of coupling two solvers. In this coupling method fixed point iterations are performed as the output of one solver is given to the other one without adjustment. Basic schematic is given in the following figure. Here, \\mathcal{F} \\mathcal{F} is the first solver with input x x and output \\tilde{y} \\tilde{y} and \\mathcal{S} \\mathcal{S} is the second solver with input y y and output \\tilde{x} \\tilde{x} Gauss-Seidel iterations are very simple, but unstable for cases with high added mass.","title":"Algorithm"},{"location":"coupled_solvers/#settings","text":"The following parameters need to be included in the settings dictionary. Here they are listed in alphabetical order. parameter type description delta_t double Fixed time step size used in both solvers. For a steady simulation typically a value of 1 is taken. name string (optional) Name of the case used to store a pickle file with results. If not provided 'results' is used. save_results bool (optional) Default: false. If true a pickle file is stored containing some main results: the value of the displacement and load on the interface for every time step, interface objects used by the two solvers, the number of coupling iterations per time step, the total elapsed time for the calculation, the residual after every coupling iteration and the values of delta_t and timestep_start . This file is used by the postprocessing files included with the examples. time_step_start int Time step number to (re)start a transient FSI calculation. If 0 is given, the simulation starts from scratch. Otherwise, the code looks for the relevant files to start from the corresponding time step. Not every solver implements restart, see the solver documentation for more information. For a steady simulation this should be 0. timestep_start and delta_t are necessary parameters (also in a steady simulation), but can also defined in the solverwrapper directly (e.g. for standalone testing). If they are defined both here and in the solver wrapper, then the former value is used and a warning is printed. These parameters should also be specified for the coupled solvers inheriting from GaussSeidel .","title":"Settings"},{"location":"coupled_solvers/#relaxation","text":"This coupled_solver inherits from GaussSeidel . The type for this coupled_solver is coupled_solvers.relaxation .","title":"Relaxation"},{"location":"coupled_solvers/#algorithm_1","text":"Gauss-Seidel iterations are very simple, but are unstable for cases with high added mass. An approach to mitigate this is applying relaxation, also called simple mixing. In this coupling method the output of first solver is still given to the other one without adjustment, but the output of the second solver is relaxed as follows: $$ x^{k+1}=(1-\\omega)x^k+\\omega\\tilde{x}^k=x^k+\\omega r^k $$ with x^k x^k and \\tilde{x}^k \\tilde{x}^k , respectively the input for the first solver and the output of the second solver in iteration k k . The difference between both is called the residual r^k=\\tilde{x}^k-x^k r^k=\\tilde{x}^k-x^k . The mixing or relaxation factor is \\omega \\omega . A symbolic schematic is given in the following figure. Here, \\mathcal{F} \\mathcal{F} is the first solver with input x x and output \\tilde{y} \\tilde{y} and \\mathcal{S} \\mathcal{S} is the second solver with input y y and output \\tilde{x} \\tilde{x} A lower \\omega \\omega increases stability, but decreases convergence speed. This method is again quite simple, but still often unstable for cases with high added mass.","title":"Algorithm"},{"location":"coupled_solvers/#settings_1","text":"Besides the parameters required in GaussSeidel , the following parameters need to be included in the settings dictionary. They are listed in alphabetical order. parameter type description omega double Relaxation factor.","title":"Settings"},{"location":"coupled_solvers/#aitken","text":"This coupled_solver inherits from GaussSeidel . The type for this coupled_solver is coupled_solvers.aitken .","title":"Aitken"},{"location":"coupled_solvers/#algorithm_2","text":"Gauss-Seidel iterations are very simple, but are unstable for cases with high added mass. An approach to mitigate this is applying relaxation. However, the choice of a relaxation factor can be difficult. In this coupling method a dynamic relaxation factor is used. The output of first solver is still given to the other one without adjustment, but the output of the second solver is relaxed as follows: $$ x^{k+1}=(1-\\omega^k)x^k+\\omega^k\\tilde{x}^k=x^k+\\omega^k r^k $$ with x^k x^k and \\tilde{x}^k \\tilde{x}^k , respectively the input for the first solver and the output of the second solver in iteration k k . The difference between both is called the residual r^k=\\tilde{x}^k-x^k r^k=\\tilde{x}^k-x^k . The mixing or relaxation factor is \\omega^k \\omega^k is dynamic in the sense that its value changes between iterations. A symbolic schematic is given in the following figure. Here, \\mathcal{F} \\mathcal{F} is the first solver with input x x and output \\tilde{y} \\tilde{y} and \\mathcal{S} \\mathcal{S} is the second solver with input y y and output \\tilde{x} \\tilde{x} The value of \\omega^k \\omega^k is determined by applying the secant method for scalars directly to vectors and projecting it on r^k-r^{k-1} r^k-r^{k-1} as follows $$ \\omega^k=-\\omega^{k-1}\\frac{(r^{k-1})^T(r^k-r^{k-1})}{(r^k-r^{k-1})^T(r^k-r^{k-1})}. $$ The first relaxation factor in a time step is equal to the last relaxation factor from the previous time step \\omega^n \\omega^n , but limited to \\omega^{max} \\omega^{max} . $$ \\omega^0=\\textrm{sign}(\\omega^n)\\min(|\\omega^n|,\\omega^{max}). $$ The relaxation factor in the first time step is equal to \\omega^{max} \\omega^{max} . This method improves convergence speed drastically compared to Gauss-Seidel iterations, but even faster convergence can be obtained using quasi-Newton methods which take into account sensitivities.","title":"Algorithm"},{"location":"coupled_solvers/#settings_2","text":"Besides the parameters required in GaussSeidel , the following parameters need to be included in the settings dictionary. They are listed in alphabetical order. parameter type description omega_max double Maximal relaxation factor.","title":"Settings"},{"location":"coupled_solvers/#iqni","text":"This coupled_solver inherits from GaussSeidel . The type for this coupled_solver is coupled_solvers.iqni .","title":"IQNI"},{"location":"coupled_solvers/#algorithm_3","text":"The abbreviation IQNI refers to interface quasi-Newton with inverse Jacobian . In this type of coupling iteration, the combination of the two solvers is seen as one system. The input of the first solver in iteration k k is denoted by x^k x^k . The output of this solver is transferred unchanged to the second solver. The output of the second solver is denoted \\tilde{x}^k \\tilde{x}^k . The difference between input and output is called the residual r^k=\\tilde{x}^k-x^k r^k=\\tilde{x}^k-x^k . A residual operator \\mathcal{R}(x) \\mathcal{R}(x) is defined which return the residual r^k r^k as a function of x^k x^k . The goal is to find x x for which \\mathcal{R}(x)=0 \\mathcal{R}(x)=0 . This system of non-linear equations is solved using Newton-Raphson iterations as follows $$ x^{k+1}=x^k-\\mathcal{R}'^{-1}(x^k)r^k, $$ where \\mathcal{R}' \\mathcal{R}' is the Jacobian of \\mathcal{R} \\mathcal{R} . However, this Jacobian is not accessible and is therefore approximated. Note that the iteration update can also be written as $$ \\Delta x^k=\\mathcal{R}'^{-1}(x^k)\\Delta r^k; $$ where \\Delta x^k=x^{k+1}-x^k \\Delta x^k=x^{k+1}-x^k is the difference between the input of two subsequent iterations and \\Delta r^k=0-r^k=-r^k \\Delta r^k=0-r^k=-r^k is the difference between the desired and the current residual. Likewise, \\Delta\\tilde{x}^k=\\tilde{x}^{k+1}-\\tilde{x}^k \\Delta\\tilde{x}^k=\\tilde{x}^{k+1}-\\tilde{x}^k is the difference between the the output of two subsequent iterations. Instead of approximating \\mathcal{R}'^{-1} \\mathcal{R}'^{-1} directly, the inverse Jacobian of \\tilde{\\mathcal{R}} \\tilde{\\mathcal{R}} is approximated. This altered residual operator is defined as follows $$ r^{k+1}=\\tilde{\\mathcal{R}}(\\tilde{x}^{k+1})=\\mathcal{R}(\\tilde{x}^{k+1}-r^{k+1}). $$ The inverse of both Jacobians are linked by $$ \\tilde{\\mathcal{R}}'^{-1}=\\mathcal{R}'^{-1}+I, $$ where \\tilde{\\mathcal{R}}' \\tilde{\\mathcal{R}}' is the Jacobian of \\tilde{\\mathcal{R}} \\tilde{\\mathcal{R}} with respect to \\tilde{x} \\tilde{x} and I I is the identity matrix. For this Jacobian the following is valid $$ \\Delta \\tilde{x}^k=\\tilde{\\mathcal{R}}'^{-1}(x^k)\\Delta r^k. $$ This Jacobian is also not known, but is approximated using a model denoted by \\tilde{N}^k \\tilde{N}^k . The type of model and its settings are specified in the settings dictionary. This model returns an estimation of \\Delta\\tilde{x}^k \\Delta\\tilde{x}^k given \\Delta r^k=-r^k \\Delta r^k=-r^k $$ \\Delta\\tilde{x}^k=\\tilde{N}^k \\Delta r^k. $$ Finally resulting in the update formula $$ x^{k+1}=x^k+(\\tilde{N}^k-I)\\Delta r^k=x^k-\\tilde{N}^k r^k+r^k. $$ A symbolic schematic is given in the following figure. Here, \\mathcal{F} \\mathcal{F} is the first solver with input x x and output \\tilde{y} \\tilde{y} and \\mathcal{S} \\mathcal{S} is the second solver with input y y and output \\tilde{x} \\tilde{x} For more information refer to models .","title":"Algorithm"},{"location":"coupled_solvers/#settings_3","text":"Besides the parameters required in GaussSeidel , the following parameters need to be included in the settings dictionary. They are listed in alphabetical order. parameter type description model dict Model component. omega double Relaxation factor.","title":"Settings"},{"location":"coupled_solvers/#ibqn","text":"This coupled_solver inherits from GaussSeidel . The type for this coupled_solver is coupled_solvers.ibqn .","title":"IBQN"},{"location":"coupled_solvers/#algorithm_4","text":"The abbreviation IBQN refers to interface block quasi-Newton . In type of coupling iteration, the system $$ \\begin{cases} \\mathcal{F}(x)-y=0 \\newline \\mathcal{S}(y)-x=0 \\end{cases} $$ is solved in block form. Here, \\mathcal{F} \\mathcal{F} is the first solver with input x x and output \\tilde{y} \\tilde{y} and \\mathcal{S} \\mathcal{S} is the second solver with input y y and output \\tilde{x} \\tilde{x} In this iteration scheme, the output of each solver is altered before being transferred to the other one. Solving the system in block Newton-Raphson iterations results in $$ \\begin{bmatrix} \\mathcal{F}'(x) & -I \\newline -I & \\mathcal{S}'(y) \\end{bmatrix} \\begin{bmatrix} \\Delta x \\newline \\Delta y \\end{bmatrix} =- \\begin{bmatrix} \\mathcal{F}(x)-y \\newline \\mathcal{S}(y)-x \\end{bmatrix}, $$ where \\mathcal{F}' \\mathcal{F}' and \\mathcal{S}' \\mathcal{S}' denote the Jacobians of the first and second solver, respectively. These Jacobians are however not accessible and are approximated using a model as specified in the settings dictionary. To the fist and second solver correspond model_f , denoted here by M_f M_f , and model_s , denoted bye M_s M_s , respectively. For example, model_f returns an estimation of \\Delta\\tilde{y}^k=\\tilde{y}^{k+1}-\\tilde{y}^k \\Delta\\tilde{y}^k=\\tilde{y}^{k+1}-\\tilde{y}^k given \\Delta x^k=x^{k+1}-x^k \\Delta x^k=x^{k+1}-x^k $$ \\Delta\\tilde{y}^k=M_f^k \\Delta x^k. $$ Solving for x^{k+1}=x^k+\\Delta x^k x^{k+1}=x^k+\\Delta x^k requires solving the system $$ \\left(I-M_s^k M_f^k\\right)\\Delta x^k =\\tilde{x}^k-x^k+M_s^k(\\tilde{y}^k-y^k) $$ for \\Delta x^k \\Delta x^k . This done matrix-free using a GMRES method. Analogously, the input y^{k+1}=y^k+\\Delta y^k y^{k+1}=y^k+\\Delta y^k for the structural solver by solving $$ \\left(I-M_f^{k+1}M_s^k\\right)\\Delta y^k =\\tilde{y}^{k+1}-y^k+M_f^{k+1}(\\tilde{x}^k-x^{k+1}) $$ for \\Delta y^k \\Delta y^k . A symbolic schematic is given in the following figure. For more information refer to .","title":"Algorithm"},{"location":"coupled_solvers/#settings_4","text":"Besides the parameters required in GaussSeidel , the following parameters need to be included in the settings dictionary. They are listed in alphabetical order. parameter type description absolute_tolerance_gmres double Absolute tolerance used in the GMRES method. model_f dict Model component corresponding to the first solver wrapper. model_s dict Model component corresponding to the second solver wrapper. omega double Relaxation factor. relative_tolerance_gmres double Relative tolerance used in the GMRES method.","title":"Settings"},{"location":"coupled_solvers/#test-single-solver","text":"The solver test_single_solver can be used to test new cases and solver settings. The idea behind this component is to only test one of the two solvers, while the other one is replaced by a dummy. This test environment inherits from GaussSeidel . The type for this coupled_solver is coupled_solvers.test_single_solver .","title":"Test single solver"},{"location":"coupled_solvers/#dummy-solver","text":"To test only one solver, a dummy solver must be used. Such a dummy solver is implemented by a test class in the file dummy_solver.py , which has to be on the same folder level as run_simulation.py . Upon run-time an instance of this class is made. The test class requires methods of the form calculate_<variable>(x,y,z,n) , with <variable> being the variable(s) required by the tested solver, e.g. displacement , pressure or traction . How these variables are defined inside these methods, is up to the user. However, the methods need to return the right format: a 3-element list or numpy array for vector variables and a 1-element list or numpy array for scalar variables. Some examples are given in the example test_single_solver The test class name is provided in the JSON settings as a string. If no test class is provided or the value None is used, zero input will be used.","title":"Dummy solver"},{"location":"coupled_solvers/#settings_5","text":"The JSON settings for this test environment test_single_solver are different from the other coupled_solvers in the sense that they only require the type , which is coupled_solvers.test_single_solver , the dictionary test_settings and the list solver_wrappers containing at least one solver_wrapper . The possibilities for the test_settings dictionary are listed in alphabetical order below. parameter type description delta_t double (optional) Time step size to be used in the test. Is optional as long as this value is defined in the settings dictionary. If a different value is defined in both dictionaries, the one defined in test_settings is chosen. name string (optional) Name of the case used to store a pickle file with results. If not provided 'results' is used. The pickle file will have the name <name>_<test_solver_working_directory>.pickle . save_results bool (optional) Default: false. If true a pickle file is stored containing some main results as in gauss_seidel . solver_index int Has a value 0 or 1 and indicates the solver that one wants to test. 0 indicates the first solver_wrapper that appears in the JSON-file, 1 the second one. test_class string (optional) Refers to the class to use in the dummy_solver.py . If not provided or None , zero input will be used. timestep_start int (optional) Time step to start from. If not provided the value defined in the settings dictionary is used. If the settings dictionary is not present, zero is used. Other dictionaries, used for the actual calculation can be kept, but will not be used, with the possible exception of the settings dictionary. The settings dictionary is used to look up delta_t , timestep_start , save_results and name if not provided in test_settings . Note that test_settings has priority over the parameters defined in settings . This means a calculation can be tested, by only adding the test_settings dictionary and changing the coupled_solver type to coupled_solvers.test_single_solver and without altering anything else. An illustration can be found in the example test_single_solver . The working directory of the solver is copied to a new directory with the same name and a suffix _testX with X an integer starting from 0. As such, previous test solver working directories are not overwritten. The optional pickle file saving some results uses the name as specified by the JSON settings followed by an underscore and the solver test working directory. As such the pickle file always belongs to the corresponding test working directory. During run time, the norm of x x and y y are printed. A residual does not exist here. The arrays x x and y y do not have a physical meaning but are the in- and output of the solver: the output of a typical flow solver, for example, will contain pressure and traction components for all points. For the first solver in the solver_wrappers list, x x and y y are respectively in- and output, whereas for the second, y y is the input an x x the output. Nonetheless, these values can be useful to verify that the solver_wrapper runs. The test environment test_single_solver tests only the solver_wrapper itself, no mapping is included.","title":"Settings"},{"location":"coupling_components/","text":"Coupling components The coupling components are the basic building blocks of the CoCoNuT coupling tool. There are five types: convergence_criteria which determine when the calculation in a time step has converged coupled_solvers (completed by models ) which perform the actual coupling, implementing a coupling algorithm mappers which map from one interface discretization to another predictors which provide an initial guess at the start of a new time step solver_wrappers which provide communication which the actual solvers The idea behind these components is modularity. For example, changing a solver_wrapper or creating a new one can be done wihtout having to adapt any other components. This allows for high degree of flexibility, a short learning curve and a limited development effort. Moreover, components can be used multiple times without the need for copying code. Detailed information on these components can be found in the specific documentation. All these coupling components inherit from a same superclass called Component . In this class some methods are implemented, which control the flow within CoCoNuT. For every coupling component, there are Initialize and Finalize , which are called at the start and end of a calculation and there are InitializeSolutionStep and FinalizeSolutionStep , which are called at the start and end of each time step. If needed these methods are overwritten to perform a specific action. For example in the Finalize method of a solver_wrapper , the is implemented which will terminate the solver software. A schematic of the relation between the coupling components for a basic calculation is given in the following figure. These coupling components have to communicate with each other. This is done through the use of Interfaces , indicated with arrows on the figure. These objects contain discretized data on the interface and references to among others, the coordinates of the discretized interface. Start of the calculation The main coupling component in which all other coupling components are instantiated is the coupled_solver . The coupled_solver itself is created in the Analysis class, which is the starting point of the CoCoNuT calculation. Upon the start of CoCoNuT, an instance of Analysis is made and the method run is executed. The coupled_solver keeps track of all Components and runs the methods Initialize , Finalize , InitializeSolutionStep and FinalizeSolutionStep , when its respective methods are executed. Tools Some code to perform specific tasks, like printing with a certain layout or performing a time measurement is useful throughout the code. These functionalities are grouped in the file tools . It suffices to import the file to make uses of its functions.","title":"General"},{"location":"coupling_components/#coupling-components","text":"The coupling components are the basic building blocks of the CoCoNuT coupling tool. There are five types: convergence_criteria which determine when the calculation in a time step has converged coupled_solvers (completed by models ) which perform the actual coupling, implementing a coupling algorithm mappers which map from one interface discretization to another predictors which provide an initial guess at the start of a new time step solver_wrappers which provide communication which the actual solvers The idea behind these components is modularity. For example, changing a solver_wrapper or creating a new one can be done wihtout having to adapt any other components. This allows for high degree of flexibility, a short learning curve and a limited development effort. Moreover, components can be used multiple times without the need for copying code. Detailed information on these components can be found in the specific documentation. All these coupling components inherit from a same superclass called Component . In this class some methods are implemented, which control the flow within CoCoNuT. For every coupling component, there are Initialize and Finalize , which are called at the start and end of a calculation and there are InitializeSolutionStep and FinalizeSolutionStep , which are called at the start and end of each time step. If needed these methods are overwritten to perform a specific action. For example in the Finalize method of a solver_wrapper , the is implemented which will terminate the solver software. A schematic of the relation between the coupling components for a basic calculation is given in the following figure. These coupling components have to communicate with each other. This is done through the use of Interfaces , indicated with arrows on the figure. These objects contain discretized data on the interface and references to among others, the coordinates of the discretized interface.","title":"Coupling components"},{"location":"coupling_components/#start-of-the-calculation","text":"The main coupling component in which all other coupling components are instantiated is the coupled_solver . The coupled_solver itself is created in the Analysis class, which is the starting point of the CoCoNuT calculation. Upon the start of CoCoNuT, an instance of Analysis is made and the method run is executed. The coupled_solver keeps track of all Components and runs the methods Initialize , Finalize , InitializeSolutionStep and FinalizeSolutionStep , when its respective methods are executed.","title":"Start of the calculation"},{"location":"coupling_components/#tools","text":"Some code to perform specific tasks, like printing with a certain layout or performing a time measurement is useful throughout the code. These functionalities are grouped in the file tools . It suffices to import the file to make uses of its functions.","title":"Tools"},{"location":"data_structure/","text":"TODO : write docs about data structure","title":"Data structure"},{"location":"docs/","text":"Documentation This website is a collection of all MarkDown (MD) files found in the coconut package. These files are converted to a static website using MkDocs , based on the outline defined in the mkdocs.yml file. Documentation in MarkDown MD files are easy to write and read in raw form, and can easily be converted to HTML for nicer rendering. It is easy to learn, see e.g. this tutorial . Several flavors of MD exist, which differ only in some details. GitHub has its own GitHub Flavored Markdown (GFM) , which is used to render MD documents found in repositories on the run. PyCharm comes with an automatic rendering tool built in, and I assume many other IDE's too. The MD documents for the CoCoNuT documentation must be written in the Python-Markdown flavor, because they are processed by MkDocs . This flavor stays very close to the reference implementation of MD. Pay attention to lists: they should be indented with 4 spaces (contrary to GFM). An important rule for writing MD files for this documentation website is that the name of the file must be unique: use names like fluent.md or examples.md , not readme.md . Links to other MarkDown files It is possible to use relative links to other MarkDown files in CoCoNuT, using the syntax [ link description ]( relative_path ) where relative_path is the relative path to another MarkDown file, e.g. ../coupling_components/mappers/mappers.md . These links can be used in rendered MarkDown, e.g. in PyCharm, but also on GitHub itself (see this blogpost ). These links also work on the documentation website, as they are automatically replaced by the correct URL. Take for example a look at the documentation of the mappers or the examples . Math For writing mathematics, LaTeX notation can be used. Inline equations must be enclosed in single dollar signs (e.g. E = m c^2 E = m c^2 ), block-style equations in double dolar signs, e.g. e^{i \\pi} + 1 = 0. e^{i \\pi} + 1 = 0. LaTeX expressions will not be rendered on GitHub, but only on the documentation website. For the latter, the MD extension Arithmatex is used to render the expressions with MathJax. Note that MathJax syntax is a little more restrictive than a real LaTeX installation. Images External images can be included with their URL. Adding locally stored images is a bit more complicated: these images must be stored in a directory images next to the MD file. If another location is used, they will not be shown on the website, only on GitHub. Furthermore, images must have a unique name. A warning is shown when this is not the case. An image can be added with the MD command ! [ alt ] ( images / example . png \"description\" ) with alt displayed when the image cannot be shown/viewed for some reason, and description appearing when hovering over the image with your mouse. For example: Only image formats specified in run_mkdocs.py are copied to the website; missing extensions can be added. Images from all coconut subdirectories called images are copied to the website, so care must be taken that images is not used in e.g. the output of the test examples. Creating a static website with MkDocs MkDocs can be installed using pip: pip install mkdocs Furthermore, the Material theme must be installed: pip install mkdocs-material To render LaTeX equations, the PyMdown MD extensions must be installed: pip install pymdown-extensions All three can be installed locally by adding the argument -t /some/absolute/path . In that case, two lines must be added to your .bashrc : export PYTHONPATH = /some/absolute/path: $PYTHONPATH export PATH = /some/absolute/path/bin: $PATH The structure/outline of the website is dictated by the nav variable in mkdocs.yml . This is the only variable that must be adjusted when new MD files are added to the code. The complete process to create the documentation website is automated by run_mkdocs.py . This does the following things: Copy all MD files in coconut and its subfolders to folder docs . Check if there are duplicate filenames: these overwrite each other! If duplicates are found, a warning is given with the original paths. Check if each MD file is mentioned in mkdocs.yml . If a file is not mentioned, a warning is given. Build static HTML website using mkdocs build . The behavior of run_mkdocs.py can be altered by adding an extra command line argument. python run_mkdocs.py --deploy deploys the website on GitHub Pages using mkdocs gh-deploy . It seems this is currently only possible if the remote is configured with SSH, not with HTTPS. python run_mkdocs.py --preview example opens a preview of the website in Firefox, showing the webpage corresponding to the file example.md . This can be used to check MD and LaTeX syntax.","title":"Documentation"},{"location":"docs/#documentation","text":"This website is a collection of all MarkDown (MD) files found in the coconut package. These files are converted to a static website using MkDocs , based on the outline defined in the mkdocs.yml file.","title":"Documentation"},{"location":"docs/#documentation-in-markdown","text":"MD files are easy to write and read in raw form, and can easily be converted to HTML for nicer rendering. It is easy to learn, see e.g. this tutorial . Several flavors of MD exist, which differ only in some details. GitHub has its own GitHub Flavored Markdown (GFM) , which is used to render MD documents found in repositories on the run. PyCharm comes with an automatic rendering tool built in, and I assume many other IDE's too. The MD documents for the CoCoNuT documentation must be written in the Python-Markdown flavor, because they are processed by MkDocs . This flavor stays very close to the reference implementation of MD. Pay attention to lists: they should be indented with 4 spaces (contrary to GFM). An important rule for writing MD files for this documentation website is that the name of the file must be unique: use names like fluent.md or examples.md , not readme.md .","title":"Documentation in MarkDown"},{"location":"docs/#links-to-other-markdown-files","text":"It is possible to use relative links to other MarkDown files in CoCoNuT, using the syntax [ link description ]( relative_path ) where relative_path is the relative path to another MarkDown file, e.g. ../coupling_components/mappers/mappers.md . These links can be used in rendered MarkDown, e.g. in PyCharm, but also on GitHub itself (see this blogpost ). These links also work on the documentation website, as they are automatically replaced by the correct URL. Take for example a look at the documentation of the mappers or the examples .","title":"Links to other MarkDown files"},{"location":"docs/#math","text":"For writing mathematics, LaTeX notation can be used. Inline equations must be enclosed in single dollar signs (e.g. E = m c^2 E = m c^2 ), block-style equations in double dolar signs, e.g. e^{i \\pi} + 1 = 0. e^{i \\pi} + 1 = 0. LaTeX expressions will not be rendered on GitHub, but only on the documentation website. For the latter, the MD extension Arithmatex is used to render the expressions with MathJax. Note that MathJax syntax is a little more restrictive than a real LaTeX installation.","title":"Math"},{"location":"docs/#images","text":"External images can be included with their URL. Adding locally stored images is a bit more complicated: these images must be stored in a directory images next to the MD file. If another location is used, they will not be shown on the website, only on GitHub. Furthermore, images must have a unique name. A warning is shown when this is not the case. An image can be added with the MD command ! [ alt ] ( images / example . png \"description\" ) with alt displayed when the image cannot be shown/viewed for some reason, and description appearing when hovering over the image with your mouse. For example: Only image formats specified in run_mkdocs.py are copied to the website; missing extensions can be added. Images from all coconut subdirectories called images are copied to the website, so care must be taken that images is not used in e.g. the output of the test examples.","title":"Images"},{"location":"docs/#creating-a-static-website-with-mkdocs","text":"MkDocs can be installed using pip: pip install mkdocs Furthermore, the Material theme must be installed: pip install mkdocs-material To render LaTeX equations, the PyMdown MD extensions must be installed: pip install pymdown-extensions All three can be installed locally by adding the argument -t /some/absolute/path . In that case, two lines must be added to your .bashrc : export PYTHONPATH = /some/absolute/path: $PYTHONPATH export PATH = /some/absolute/path/bin: $PATH The structure/outline of the website is dictated by the nav variable in mkdocs.yml . This is the only variable that must be adjusted when new MD files are added to the code. The complete process to create the documentation website is automated by run_mkdocs.py . This does the following things: Copy all MD files in coconut and its subfolders to folder docs . Check if there are duplicate filenames: these overwrite each other! If duplicates are found, a warning is given with the original paths. Check if each MD file is mentioned in mkdocs.yml . If a file is not mentioned, a warning is given. Build static HTML website using mkdocs build . The behavior of run_mkdocs.py can be altered by adding an extra command line argument. python run_mkdocs.py --deploy deploys the website on GitHub Pages using mkdocs gh-deploy . It seems this is currently only possible if the remote is configured with SSH, not with HTTPS. python run_mkdocs.py --preview example opens a preview of the website in Firefox, showing the webpage corresponding to the file example.md . This can be used to check MD and LaTeX syntax.","title":"Creating a static website with MkDocs"},{"location":"examples/","text":"Examples This documentation describes the different example cases. Currently all these examples calculate the flow in a flexible tube. Folder and file structure This section describes the different folders and files that are provided. run_simulation.py : main file, has to be run with the parameter file as argument parameters.json : parameter file in JSON format setup_X : setup folder containing all files for setting up solver X setup_X.sh : bash script, has to be run to set up solver X X.md : description of the specific example When the setup files are run, working directories are created that have to match the ones specified in the parameter file. These folder are expandable and are deleted when the setup files are (re)run. Project Parameters The parameter file parameters.json can be interpreted as a dictionary. There are two main keys. The first is settings in which the number of time steps for which the calculation is run is specified. The second is coupled_solver in which all parameters related to solver algorithm are given: coupling algorithm, predictor, convergence criteria and solvers. Running a case In order to run an example case, first, the setup files have to be run to create the working directories. Then, the calculation is started by running run_simulation.py with the parameter file as argument. Note that for Abaqus, the setup file must be sourced . For example, for a case with Fluent and Abaqus, you would run the following commands: ./setup_fluent source setup_abaqus.sh python run_simulation.py project_parameters_X.json Debug files The folder examples also contains a folder debug_files containing scripts for debug purposes. These files might need some adjustements to work. In order to use them, the debug boolean self.debug has to be True in the code of the corresponding solver wrappers.","title":"General"},{"location":"examples/#examples","text":"This documentation describes the different example cases. Currently all these examples calculate the flow in a flexible tube.","title":"Examples"},{"location":"examples/#folder-and-file-structure","text":"This section describes the different folders and files that are provided. run_simulation.py : main file, has to be run with the parameter file as argument parameters.json : parameter file in JSON format setup_X : setup folder containing all files for setting up solver X setup_X.sh : bash script, has to be run to set up solver X X.md : description of the specific example When the setup files are run, working directories are created that have to match the ones specified in the parameter file. These folder are expandable and are deleted when the setup files are (re)run.","title":"Folder and file structure"},{"location":"examples/#project-parameters","text":"The parameter file parameters.json can be interpreted as a dictionary. There are two main keys. The first is settings in which the number of time steps for which the calculation is run is specified. The second is coupled_solver in which all parameters related to solver algorithm are given: coupling algorithm, predictor, convergence criteria and solvers.","title":"Project Parameters"},{"location":"examples/#running-a-case","text":"In order to run an example case, first, the setup files have to be run to create the working directories. Then, the calculation is started by running run_simulation.py with the parameter file as argument. Note that for Abaqus, the setup file must be sourced . For example, for a case with Fluent and Abaqus, you would run the following commands: ./setup_fluent source setup_abaqus.sh python run_simulation.py project_parameters_X.json","title":"Running a case"},{"location":"examples/#debug-files","text":"The folder examples also contains a folder debug_files containing scripts for debug purposes. These files might need some adjustements to work. In order to use them, the debug boolean self.debug has to be True in the code of the corresponding solver wrappers.","title":"Debug files"},{"location":"fluent/","text":"SolverWrapperFluent This is the documentation for all Fluent solver-wrappers. Currently only FSI simulations are supported, no other multiphysics problems. Also, inviscid flows are not supported yet. Parameters This section describes the parameters in the JSON file, listed in alphabetical order. parameter type description case_file string Name of the case file. It must be present in the folder working_directory . cores int Number of processor cores to use when running Fluent (tested only on single node so far). dimensions int Dimension used in flow solver: 2 for 2D and axisymmetric, 3 for 3D. delta_t double Fixed timestep size in flow solver. This parameter is usually specified in a higher Component . flow_iterations int Number of non-linear iterations in Fluent per coupling iteration. fluent_gui bool Set to true to run Fluent with the graphical interface. hybrid_initialization bool If true , the hybrid initialization is used in Fluent before the first timestep. If false , the standard initialization is used, which requires that adequate reference values have been set in advance by the user in the case_file . interface_input dict Keys are names of ModelParts for Fluent nodes. Each name must be the concatenation of an entry from thread_names and \"_nodes\". The values are (lists of) names of Variables . interface_output dict Analogous to interface_input , but for Fluent faces ('_faces'). max_nodes_per_face int This value is used to construct unique IDs for faces, based on unique IDs of nodes (provided by Fluent). It should be at least as high as the maximum number of nodes on a face on the interface. Use e.g. 4 for rectangular faces, 3 for triangular faces. save_iterations int Number of timesteps between consecutive saves of the Fluent case and data files. thread_names list List with Fluent names of the surface threads on the interface. IS THE ORDER IMPORTANT? TODO timestep_start int Timestep number to (re)start a transient FSI calculation. If 0 is given, the simulation starts from the case_file , else the code looks for the relevant case and data files. This parameter is usually specified in a higher Component . unsteady bool true for transient FSI, false for steady FSI. working_directory string Absolute path to the working directory or relative path w.r.t the current directory. timestep_start and delta_t are necessary parameters, but are usually defined in a higher Component . However, they can also be given directly as parameter of the solver-wrapper (e.g. for standalone testing). If they are defined both in a higher Component and in the solver-wrapper, then the former value is used and a warning is printed. If different parameters are used with different Fluent versions, this should be specified both in this section and in the version specific documentation section. Overview of operation The solver-wrapper consists of 3 files (with X the Fluent version, e.g. v2019R1 ): X.py : defines the SolverWrapperFluentX class X.jou : Fluent journal file to interactively run the FSI simulation, written in Scheme X.c : Fluent UDF file that implements additional functionality used in Fluent, written in C The __init__ method During initialization, the journal and UDF files are adapted (parameter values are filled in) and copied to the working_directory . Fluent is then started in that directory using the parameters cores , dimensions and fluent_gui . Fluent then writes a case summery, so that SolverWrapperFluentX can link the interface thread names (specified in thread_names ) to Fluent thread IDs, for use in the UDFs. Then the Model and ModelParts are created, based on data written by Fluent in timestep 0. After a restart, this same data must be found, i.e. if that file is removed from the folder working_directory , the simulation cannot be restarted. If the simulation was restarted, the coordinates X , Y , Z in the Nodes are updated to the current values. Finally, the Interfaces are made. Files created during simulation In the file conventions, A is the timestep number and B the Fluent thread ID. Fluent case and data files are saved as files of the form case_timestepA.cas and case_timestepA.dat . Current node and face coordinates are passed from Fluent to Python with files of the form nodes_timestepA_threadB.dat and faces_timestepA_threadB.dat . The new node coordinates are passed from Python to Fluent with files of the form nodes_update_timestepA_threadB . Pressure and tractions are passed from Fluent to Python with files of the form pressure_traction_timestepA_threadB.dat . Files with extension .coco are used to pass messages between Python and Fluent (via the journal). Setting up a new case Following items should be set up and saved in the case_file (this list may be non-exhaustive): additional UDFs must be configured steady/unsteady (should match with the unsteady parameter) 2D, 3D or axisymmetric (should match with the dimensions parameter) dynamic mesh for all zones, except the FSI interfaces boundary conditions, material properties, numerical models, discretization schemes, operating conditions, turbulence modeling, convergence criteria if hybrid_initialization is false , then defaults should be set for standard initialization Following items are taken care of by CoCoNuT, and must therefore not be included in the case_file : dynamic mesh for the FSI interfaces (which are defined in thread_names ) the timestep ( delta_t ) initialization of the solution field Version specific documentation v2019R1 (19.3.0) First version. v2019R2 (19.4.0) No changes. v2019R3 (19.5.0) The solutions in this version are (slightly) different because the Rhie-Chow face flux interpolation in the pressure-based solver has changed. This setting can be reverted with the TUI command solve set previous undo-2019r3 y n , which is included in v2019R3.jou . The results can be slightly different when restarts are used for multicore simulations for the following reason: For parallel cases with smoothing that do not use dynamic load balancing, a zonal partitioning with Laplace smoothing will automatically be applied when the file is read, which should result in better load balancing for the mesh smoothing calculations. After a restart, the partitioning can be different and hence the mesh deformation can be slightly different. v2020R3 (20.1.0) Same behavior as v2019R3.","title":"SolverWrapperFluent"},{"location":"fluent/#solverwrapperfluent","text":"This is the documentation for all Fluent solver-wrappers. Currently only FSI simulations are supported, no other multiphysics problems. Also, inviscid flows are not supported yet.","title":"SolverWrapperFluent"},{"location":"fluent/#parameters","text":"This section describes the parameters in the JSON file, listed in alphabetical order. parameter type description case_file string Name of the case file. It must be present in the folder working_directory . cores int Number of processor cores to use when running Fluent (tested only on single node so far). dimensions int Dimension used in flow solver: 2 for 2D and axisymmetric, 3 for 3D. delta_t double Fixed timestep size in flow solver. This parameter is usually specified in a higher Component . flow_iterations int Number of non-linear iterations in Fluent per coupling iteration. fluent_gui bool Set to true to run Fluent with the graphical interface. hybrid_initialization bool If true , the hybrid initialization is used in Fluent before the first timestep. If false , the standard initialization is used, which requires that adequate reference values have been set in advance by the user in the case_file . interface_input dict Keys are names of ModelParts for Fluent nodes. Each name must be the concatenation of an entry from thread_names and \"_nodes\". The values are (lists of) names of Variables . interface_output dict Analogous to interface_input , but for Fluent faces ('_faces'). max_nodes_per_face int This value is used to construct unique IDs for faces, based on unique IDs of nodes (provided by Fluent). It should be at least as high as the maximum number of nodes on a face on the interface. Use e.g. 4 for rectangular faces, 3 for triangular faces. save_iterations int Number of timesteps between consecutive saves of the Fluent case and data files. thread_names list List with Fluent names of the surface threads on the interface. IS THE ORDER IMPORTANT? TODO timestep_start int Timestep number to (re)start a transient FSI calculation. If 0 is given, the simulation starts from the case_file , else the code looks for the relevant case and data files. This parameter is usually specified in a higher Component . unsteady bool true for transient FSI, false for steady FSI. working_directory string Absolute path to the working directory or relative path w.r.t the current directory. timestep_start and delta_t are necessary parameters, but are usually defined in a higher Component . However, they can also be given directly as parameter of the solver-wrapper (e.g. for standalone testing). If they are defined both in a higher Component and in the solver-wrapper, then the former value is used and a warning is printed. If different parameters are used with different Fluent versions, this should be specified both in this section and in the version specific documentation section.","title":"Parameters"},{"location":"fluent/#overview-of-operation","text":"The solver-wrapper consists of 3 files (with X the Fluent version, e.g. v2019R1 ): X.py : defines the SolverWrapperFluentX class X.jou : Fluent journal file to interactively run the FSI simulation, written in Scheme X.c : Fluent UDF file that implements additional functionality used in Fluent, written in C","title":"Overview of operation"},{"location":"fluent/#the-__init__-method","text":"During initialization, the journal and UDF files are adapted (parameter values are filled in) and copied to the working_directory . Fluent is then started in that directory using the parameters cores , dimensions and fluent_gui . Fluent then writes a case summery, so that SolverWrapperFluentX can link the interface thread names (specified in thread_names ) to Fluent thread IDs, for use in the UDFs. Then the Model and ModelParts are created, based on data written by Fluent in timestep 0. After a restart, this same data must be found, i.e. if that file is removed from the folder working_directory , the simulation cannot be restarted. If the simulation was restarted, the coordinates X , Y , Z in the Nodes are updated to the current values. Finally, the Interfaces are made.","title":"The __init__ method"},{"location":"fluent/#files-created-during-simulation","text":"In the file conventions, A is the timestep number and B the Fluent thread ID. Fluent case and data files are saved as files of the form case_timestepA.cas and case_timestepA.dat . Current node and face coordinates are passed from Fluent to Python with files of the form nodes_timestepA_threadB.dat and faces_timestepA_threadB.dat . The new node coordinates are passed from Python to Fluent with files of the form nodes_update_timestepA_threadB . Pressure and tractions are passed from Fluent to Python with files of the form pressure_traction_timestepA_threadB.dat . Files with extension .coco are used to pass messages between Python and Fluent (via the journal).","title":"Files created during simulation"},{"location":"fluent/#setting-up-a-new-case","text":"Following items should be set up and saved in the case_file (this list may be non-exhaustive): additional UDFs must be configured steady/unsteady (should match with the unsteady parameter) 2D, 3D or axisymmetric (should match with the dimensions parameter) dynamic mesh for all zones, except the FSI interfaces boundary conditions, material properties, numerical models, discretization schemes, operating conditions, turbulence modeling, convergence criteria if hybrid_initialization is false , then defaults should be set for standard initialization Following items are taken care of by CoCoNuT, and must therefore not be included in the case_file : dynamic mesh for the FSI interfaces (which are defined in thread_names ) the timestep ( delta_t ) initialization of the solution field","title":"Setting up a new case"},{"location":"fluent/#version-specific-documentation","text":"","title":"Version specific documentation"},{"location":"fluent/#v2019r1-1930","text":"First version.","title":"v2019R1 (19.3.0)"},{"location":"fluent/#v2019r2-1940","text":"No changes.","title":"v2019R2 (19.4.0)"},{"location":"fluent/#v2019r3-1950","text":"The solutions in this version are (slightly) different because the Rhie-Chow face flux interpolation in the pressure-based solver has changed. This setting can be reverted with the TUI command solve set previous undo-2019r3 y n , which is included in v2019R3.jou . The results can be slightly different when restarts are used for multicore simulations for the following reason: For parallel cases with smoothing that do not use dynamic load balancing, a zonal partitioning with Laplace smoothing will automatically be applied when the file is read, which should result in better load balancing for the mesh smoothing calculations. After a restart, the partitioning can be different and hence the mesh deformation can be slightly different.","title":"v2019R3 (19.5.0)"},{"location":"fluent/#v2020r3-2010","text":"Same behavior as v2019R3.","title":"v2020R3 (20.1.0)"},{"location":"kratos/","text":"SolverWrapperKratos - StructuralMechanicsApplication This is the documentation for the solver wrapper of the StructuralMechanicsApplication in KratosMultiphysics. Parameters This section describes the parameters in the JSON file, listed in alphabetical order. parameter type description cores int Number of processor cores to use when running KratosMultiphysics (Works with 1 core, multi-processing is work in progress). delta_t double Fixed timestep size in flow solver. This parameter is usually specified in a higher Component . input_file string Project parameters file used by Kratos in json format, interface_input dict List ModelParts names and Variables pairs that provides interface boundary conditions for the Kratos solver. Each entry in the list has two keys: model_part and variables with values as name of the ModelPart and list of input variables available in variables.py . The ModelPart name must be the concatenation of an entry from kratos_interface_sub_model_parts_list and \"_input\". interface_output dict Analogous to interface_input , but here the name must be the concatenation of an entry from kratos_interface_sub_model_parts_list and \"_output\". The entries in the list provides boundary conditions for the other solver(s) participating in the coupled simulation. solver_load_cmd string Bash commmand for loading required modules and environmental variables to run KratosMultiphysics, kratos_interface_sub_model_parts_list string Names of sub-model parts used for input and output in KratosMultiphysics, timestep_start int Timestep number t:wqo (re)start a transient FSI calculation. If 0 is given, the simulation starts from t = 0, else the code looks for the relevant case and data files. This parameter is usually specified in a higher Component . working_directory string Absolute path to the working directory or relative path w.r.t the current directory. timestep_start and delta_t are necessary parameters, but are usually defined in a higher Component . However, they can also be given directly as parameter of the solver-wrapper (e.g. for standalone testing). If they are defined both in a higher Component and in the solver-wrapper, then the former value is used and a warning is printed. If different parameters are used with different Kratos versions, this should be specified both in this section and in the version specific documentation section. Overview of operation The solver-wrapper consists of 2 files, where X is the Kratos version without decimal, e.g. for version 6.0 60 : vX.py : defines the SolverWrapperKratosStructureX class run_kratos_structural_X.py : The python file which runs Kratos in the background. This interacts with CoCoNuT for coupling. The __init__ method During initialization, the ProjectParameters.json file of KratosMultiphysics is read and adapted (parameter values are filled in) and copied to the working_directory . One additional parameter called interface_sub_model_parts_list is added in the ProjectParameters.json that tells Kratos about the interface model parts used in the coupling. Kratos structural simulation is then started in that directory using the parameter cores (multi-processing not implemented yet). The solver wrapper waits for the Kratos simulation to output interface sub-model parts nodes, so that SolverWrapperKratosStructureX can create model parts in CoCoNuT for each entry in interface_input and interface_output . Finally, the interfaces are created. Files created during simulation The interface sub-model parts nodes are saved as <sub_model_part_name>_nodes.csv . The displacement from Kratos is written in a file named <sub_model_part_name>_displacement.csv . Pressure and tractions are passed from python to Kratos with files of the form <sub_model_part_name>_pressure.csv and <sub_model_part_name>_surface_load.csv , respectively. Files with extension .coco are used to pass messages between Python and Kratos. Setting up a new case Following items should be set up and saved in the working_directory (this list may be non-exhaustive): ProjectParameters.json with all the required parameters and end_time set to very high value, e.g. 1e9 Mesh file with extension mdpa StructuralMaterials.json with the material properties. Following items are taken care of by CoCoNuT, and must therefore will be automatically changed at the begining of the simulation: the start_time ( timestep_start ) the timestep ( delta_t ) initialization of the solution field Version specific documentation v60 (6.0) First version.","title":"SolverWrapperKratos - StructuralMechanicsApplication"},{"location":"kratos/#solverwrapperkratos-structuralmechanicsapplication","text":"This is the documentation for the solver wrapper of the StructuralMechanicsApplication in KratosMultiphysics.","title":"SolverWrapperKratos - StructuralMechanicsApplication"},{"location":"kratos/#parameters","text":"This section describes the parameters in the JSON file, listed in alphabetical order. parameter type description cores int Number of processor cores to use when running KratosMultiphysics (Works with 1 core, multi-processing is work in progress). delta_t double Fixed timestep size in flow solver. This parameter is usually specified in a higher Component . input_file string Project parameters file used by Kratos in json format, interface_input dict List ModelParts names and Variables pairs that provides interface boundary conditions for the Kratos solver. Each entry in the list has two keys: model_part and variables with values as name of the ModelPart and list of input variables available in variables.py . The ModelPart name must be the concatenation of an entry from kratos_interface_sub_model_parts_list and \"_input\". interface_output dict Analogous to interface_input , but here the name must be the concatenation of an entry from kratos_interface_sub_model_parts_list and \"_output\". The entries in the list provides boundary conditions for the other solver(s) participating in the coupled simulation. solver_load_cmd string Bash commmand for loading required modules and environmental variables to run KratosMultiphysics, kratos_interface_sub_model_parts_list string Names of sub-model parts used for input and output in KratosMultiphysics, timestep_start int Timestep number t:wqo (re)start a transient FSI calculation. If 0 is given, the simulation starts from t = 0, else the code looks for the relevant case and data files. This parameter is usually specified in a higher Component . working_directory string Absolute path to the working directory or relative path w.r.t the current directory. timestep_start and delta_t are necessary parameters, but are usually defined in a higher Component . However, they can also be given directly as parameter of the solver-wrapper (e.g. for standalone testing). If they are defined both in a higher Component and in the solver-wrapper, then the former value is used and a warning is printed. If different parameters are used with different Kratos versions, this should be specified both in this section and in the version specific documentation section.","title":"Parameters"},{"location":"kratos/#overview-of-operation","text":"The solver-wrapper consists of 2 files, where X is the Kratos version without decimal, e.g. for version 6.0 60 : vX.py : defines the SolverWrapperKratosStructureX class run_kratos_structural_X.py : The python file which runs Kratos in the background. This interacts with CoCoNuT for coupling.","title":"Overview of operation"},{"location":"kratos/#the-__init__-method","text":"During initialization, the ProjectParameters.json file of KratosMultiphysics is read and adapted (parameter values are filled in) and copied to the working_directory . One additional parameter called interface_sub_model_parts_list is added in the ProjectParameters.json that tells Kratos about the interface model parts used in the coupling. Kratos structural simulation is then started in that directory using the parameter cores (multi-processing not implemented yet). The solver wrapper waits for the Kratos simulation to output interface sub-model parts nodes, so that SolverWrapperKratosStructureX can create model parts in CoCoNuT for each entry in interface_input and interface_output . Finally, the interfaces are created.","title":"The __init__ method"},{"location":"kratos/#files-created-during-simulation","text":"The interface sub-model parts nodes are saved as <sub_model_part_name>_nodes.csv . The displacement from Kratos is written in a file named <sub_model_part_name>_displacement.csv . Pressure and tractions are passed from python to Kratos with files of the form <sub_model_part_name>_pressure.csv and <sub_model_part_name>_surface_load.csv , respectively. Files with extension .coco are used to pass messages between Python and Kratos.","title":"Files created during simulation"},{"location":"kratos/#setting-up-a-new-case","text":"Following items should be set up and saved in the working_directory (this list may be non-exhaustive): ProjectParameters.json with all the required parameters and end_time set to very high value, e.g. 1e9 Mesh file with extension mdpa StructuralMaterials.json with the material properties. Following items are taken care of by CoCoNuT, and must therefore will be automatically changed at the begining of the simulation: the start_time ( timestep_start ) the timestep ( delta_t ) initialization of the solution field","title":"Setting up a new case"},{"location":"kratos/#version-specific-documentation","text":"","title":"Version specific documentation"},{"location":"kratos/#v60-60","text":"First version.","title":"v60 (6.0)"},{"location":"mappers/","text":"Mappers General concepts Hierarchy of mapping-related objects CoCoNuT interacts with the mappers through the SolverWrapperMapped object. This solver-wrapper appears and behaves exactly the same as real solver-wrappers. It contains 3 Components : a mapper for the input, a real solver-wrapper and a mapper for the output. The mappers are initialized through the set_interface_input and set_interface_output methods respectively, by providing them with the Interfaces that will be respectively the input and output of the SolverWrapperMapped object. The two mappers in the SolverWrapperMapped are also of a special type: they work on the level of Interfaces . They are some sort of mapper-wrapper around the actual mappers which work on ModelPart level. Currently only one such mapper is available, aptly called MapperInterface . At the lowest level, mappers interpolate historical variables between two ModelParts , based on the coordinates of the Nodes . Interpolation is always done from the from - ModelPart to the to - ModelPart . These mappers can be chained together in a MapperCombined mapper, creating in fact another layer of mapping. So many layers! Like an onion! Interpolators and transformers The ModelPart -level mappers have two main methods: Initialize and __call__ . The Initialize method performs one-time expensive operations, namely nearest-neighbour search and calculation of the interpolation coefficients. The initialization is done based on the original coordinates X0 , Y0 and Z0 . The __call__ method is used for the actual mapping. It takes two tuples as arguments ( from and to respectively), each tuple containing the ModelPart and the Variable to be used in the interpolation. This method returns nothing: the interpolation is done in-place in the ModelParts . There are two types of ModelPart -level mappers: interpolators and transformers . They can be distinguished by their boolean interpolator attribute (see __init__ ). For interpolators, Initialize gets two ModelPart objects ( from and to ), and returns nothing. These mappers do the real interpolation. Currently MapperNearest , MapperLinear and MapperRadialBasis are available. For transformers, Initialize gets only one ModelPart (from either the from or to side, depending on the transformation), and returns the other ModelPart . Currently MapperPermutation , MapperAxisymmetric2DTo3D and MapperAxisymmetric3DTo2D are available. A transformer can never be used by itself, it must always be combined with an interpolator: the reason is that interpolators use information coming from two sides, which is exactly what the SolverWrapperMapped and MapperInterface objects want. To chain together multiple mappers, the MapperCombined is used: it contains always 1 interpolator and 0 or more transformers, on either side of the interpolator. Overview of special mappers MapperInterface Special mapper-class that maps on the level of Interface objects. It takes two Interfaces , and maps the ModelParts to each other in order of appearance, all using the same ModelPart mapper. To use a different ModelPart mapper for the different ModelParts in the Interface , or even for the different historical variables, a new Interface mapper must be written. JSON setting type description type str ModelPart mapper to be used. settings dict All the settings for the ModelPart mapper specified in type . MapperCombined The MapperCombined is used to chain together multiple mappers. It contains always 1 interpolator and 0 or more transformers, on either side of the interpolator. If transformers are present, intermediate ModelParts are created during initialization. This is done by working inwards towards the interpolator. This means that transformers upstream of the interpolator, are initialized based on the from ModelPart (input), while downstream transformers are initialized based on the to ModelPart (output). Some transformers can only be initialized in one direction, e.g. for MapperAxisymmetric3DTo2D , the 2D to - ModelPart must be supplied, therefore it must be downstream of the interpolator. JSON setting type description mappers list An ordered list of all the ModelPart mappers to be used. Overview of transformers MapperPermutation Permutates the coordinates and the vector variables according to the given permutation . This transformer can be initialized in both directions. JSON setting type description permutation list A permutation of the list [0, 1, 2]. MapperAxisymmetric2DTo3D Transforms from a 2D axisymmetric geometry to a 3D geometry. This transformer can only be initialized in the forward direction, i.e. based on the 2D axisymmetric ModelPart . Therefore, it should be upstream of the interpolator in the MapperCombined . The 3D ModelPart is returned by the initialization. n_tangential specifies the number of Node objects in the tangential (circumferential) direction. For each Node in the 2D ModelPart , n_tangential Nodes are created in the 3D ModelPart . It is important to take the value of n_tangential large enough. By preference as close as possible to the number of nodes in the tangential direction of the 3D ModelPart . The code knows which directions are axial, radial and tangential thanks to the input parameters direction_axial and direction_radial . It is not possible to change the axial direction between 2D and 3D: a separate MapperPermutation should be added for that purpose. Scalar variables are simply mapped from the 2D Node to all corresponding 3D Nodes . For vector variables, the axial component is simply mapped, the radial component is rotated. The tangential component (e.g. swirl) cannot be taken into account. JSON setting type description direction_axial string Must be \"x\" , \"y\" or \"z\" , specifies the symmetry axis. direction_radial string Must be \"x\" , \"y\" or \"z\" , specifies the second (radial) axis in 2D. n_tangential int Degrees of freedom in tangential (circumferential) direction of 3D ModelPart that is created during initialization. Must be \\geq 6 \\geq 6 . MapperAxisymmetric3DTo2D Transforms from a 3D geometry to a 2D axisymmetric geometry. This transformer can only be initialized in the backward direction, i.e. based on the 2D axisymmetric ModelPart . Therefore, it should be downstream of the MapperInterpolator in the MapperCombined . For scalar variables, the circumferential average is taken for each 2D Node . For vector variables too, taking into account the correct radial direction in each 3D Node . Again, swirl cannot be taken into account: if a tangential component is present in 3D, it is not mapped to 2D. For more information and JSON settings, see MapperAxisymmetric2DTo3D which is very similar. Overview of interpolators MapperInterpolator Base-class for all interpolators (currently MapperNearest , MapperLinear and MapperRadialBasis ). JSON setting type description directions list List of coordinate directions, maximum three entries, may contain \"x\" , \"y\" , \"z\" . scaling list Optional. List of scaling factors, must be same length as directions . Coordinates are scaled with these factors, this may improve interpolation e.g. when cells have a high aspect ratio with respect to one of the axes. balanced_tree bool Optional, default false . If set to true a balanced cKDTree is created, which is more stable, but takes longer to build. Set to true in the rare case that the tree gives problems. The Initialize method should be called in all child-classes. It does the following: read and store the coordinates from the from and to ModelParts scale coordinates if necessary check if the bounding boxes of the from and to ModelParts are more or less overlapping do an efficient nearest neighbour search using scipy.spatial.cKDTree check if the from ModelPart does not contain duplicate Nodes (i.e. with same coordinates) The __call__ method should not be overridden in the child-classes. It maps historical variables based on neighbours and coefficients determined in Initialize . Historical variables of type Double and type Array can be mapped (the latter is just the application of the former for each vector component). MapperNearest Child-class of MapperInterpolator , does not require additional settings. Does simple nearest-neighbour mapping. MapperLinear Child-class of MapperInterpolator , additional settings: JSON setting type description parallel bool Optional, default false . If true the package multiprocessing is used to parallellize the loop that the calculates the interpolation coefficients. This is only useful for ModelParts with a very high number of Nodes . The kind of linear mapping depends on the number of coordinate directions, as given in the directions setting. 1D - If the to -point lies between the 2 nearest from -points, linear interpolation is done. Else, nearest neighbour interpolation is done. 2D - The to -point is first projected on the line through the 2 nearest from -points. If the projected point lies between the from -points, linear interpolation is done. Else, nearest neighbour interpolation is done. 3D - The to -point is first projected on the plane through the 3 nearest from -points. If the triangle consinsting of those 3 points is deprecated (colinear points), the 2D-methodology is followed. Else, if the projected point lies inside the triangle, barycentric interpolation is done. If it lies outside the triangle, the 2D-methodology is followed. MapperRadialBasis Child-class of MapperInterpolator , additional settings: JSON setting type description parallel bool Optional, default false . If true the package multiprocessing is used to parallellize the loop that the calculates the interpolation coefficients. This is only useful for ModelParts with a very high number of Nodes . shape_parameter int Optional, default 200 . Should be chosen as large as possible without rendering the interpolation matrix ill-conditioned. Radial basis function interpolation is relatively straightforward: implementation for 1D, 2D and 3D is exactly the same and can be written in a condensed way using scipy.spatial.distance . Normal radial basis interpolation is done as follows. \\phi(r) \\phi(r) is a radial basis function defined as \\phi(r) = \\begin{cases} (1-\\frac{r}{d_{ref}})^4 (1 + 4\\frac{r}{d_{ref}}) \\quad &\\mathrm{for} \\quad 0 \\leq \\frac{r}{d_{ref}} < 1 \\\\ 0 &\\mathrm{for} \\quad 1 \\leq \\frac{r}{d_{ref}} \\end{cases} \\phi(r) = \\begin{cases} (1-\\frac{r}{d_{ref}})^4 (1 + 4\\frac{r}{d_{ref}}) \\quad &\\mathrm{for} \\quad 0 \\leq \\frac{r}{d_{ref}} < 1 \\\\ 0 &\\mathrm{for} \\quad 1 \\leq \\frac{r}{d_{ref}} \\end{cases} with r r a positive distance. To control the width of the function, r r is scaled with a reference distance d_{ref} d_{ref} . Assume that n n nearest from -points will be used in the interpolation. An unknown function f(\\boldsymbol{x}) f(\\boldsymbol{x}) can then be approximated as the weighted sum of n n shifted radial basis functions: f(\\boldsymbol{x}) = \\sum_j \\alpha_j \\phi(||\\boldsymbol{x} - \\boldsymbol{x}_j||) f(\\boldsymbol{x}) = \\sum_j \\alpha_j \\phi(||\\boldsymbol{x} - \\boldsymbol{x}_j||) To determine the coefficients \\alpha_j \\alpha_j , we require that the exact function value is returned at the n n from -points. This gives us n n equations f(\\boldsymbol{x}_i) = f_i = \\sum_j \\alpha_j \\phi(||\\boldsymbol{x}_i - \\boldsymbol{x}_j||) f(\\boldsymbol{x}_i) = f_i = \\sum_j \\alpha_j \\phi(||\\boldsymbol{x}_i - \\boldsymbol{x}_j||) which can be written in matrix form as \\boldsymbol{f} = \\boldsymbol{\\Phi} \\boldsymbol{\\alpha} \\boldsymbol{f} = \\boldsymbol{\\Phi} \\boldsymbol{\\alpha} with \\boldsymbol{f}, \\boldsymbol{\\alpha} \\in \\mathbb{R}^{n \\times 1} \\boldsymbol{f}, \\boldsymbol{\\alpha} \\in \\mathbb{R}^{n \\times 1} , and \\boldsymbol{\\Phi} \\in \\mathbb{R}^{n \\times n} \\boldsymbol{\\Phi} \\in \\mathbb{R}^{n \\times n} . This system can be solved for the weights-vector \\boldsymbol{\\alpha} \\boldsymbol{\\alpha} . However, in our case, the from -point values vector \\boldsymbol{f} \\boldsymbol{f} is not known in advance: it contains the values of the Variable that will be interpolated. Therefore, the approximation to calculate the interpolatoin in the to -point is rewritten as follows: f(\\boldsymbol{x}_{to}) = \\sum_j \\alpha_j \\phi(||\\boldsymbol{x}_{to} - \\boldsymbol{x}_j||) = \\boldsymbol{\\Phi}_{to}^T \\boldsymbol{\\alpha} = \\boldsymbol{\\Phi}_{to}^T \\boldsymbol{\\Phi}^{-1} \\boldsymbol{f} = \\boldsymbol{c}^T \\boldsymbol{f} f(\\boldsymbol{x}_{to}) = \\sum_j \\alpha_j \\phi(||\\boldsymbol{x}_{to} - \\boldsymbol{x}_j||) = \\boldsymbol{\\Phi}_{to}^T \\boldsymbol{\\alpha} = \\boldsymbol{\\Phi}_{to}^T \\boldsymbol{\\Phi}^{-1} \\boldsymbol{f} = \\boldsymbol{c}^T \\boldsymbol{f} The coefficients vector \\boldsymbol{c} \\boldsymbol{c} can now be calculated based only on the coordinates by solving the system \\boldsymbol{\\Phi} \\ \\boldsymbol{c} = \\boldsymbol{\\Phi}_{to}. \\boldsymbol{\\Phi} \\ \\boldsymbol{c} = \\boldsymbol{\\Phi}_{to}. As every to-point has different nearest neighbours in the from -points, the coefficient vector \\boldsymbol{c} \\boldsymbol{c} must be calculated for each to -point independently. The matrix \\boldsymbol{\\Phi} \\boldsymbol{\\Phi} and vector \\boldsymbol{\\Phi}_{to} \\boldsymbol{\\Phi}_{to} must also be calculated for every to -point independently. For every to -point, the reference distance d_{ref} d_{ref} is determined as the product of the shape_parameter and the distance between the to -point and the furthest from -point. In order to ensure that the basis function of each of the nearest from -points covers every from -point, the shape_parameter should be larger than two. This value may however lead to an interpolation function which consists of sharp peaks or wiggles, with the correct value near the from -points, but a deviating value away from them. In the extreme case of d_{ref} d_{ref} approaching zero, the so-called \"bed-of-nails interpolant\" is obtained, which is close to zero everywhere, except near the from -points where it sharply peaks. In this case the interpolation matrix approaches the identity matrix. Choosing a higher value improves the interpolation as the basis functions become wider, but the interpolation matrix becomes less stable, i.e. the condition number increases. The default value is 200. In practice, the shape_parameter is chosen so that the interpolation matrix is \"on the edge of ill-conditioning\" (eg. with a condition number of roughly 10^{13} 10^{13} for double-precision floating point). A warning is printed when the condition number of an interpolation matrix becomes higher than 10^{13} 10^{13} .","title":"Mappers"},{"location":"mappers/#mappers","text":"","title":"Mappers"},{"location":"mappers/#general-concepts","text":"","title":"General concepts"},{"location":"mappers/#hierarchy-of-mapping-related-objects","text":"CoCoNuT interacts with the mappers through the SolverWrapperMapped object. This solver-wrapper appears and behaves exactly the same as real solver-wrappers. It contains 3 Components : a mapper for the input, a real solver-wrapper and a mapper for the output. The mappers are initialized through the set_interface_input and set_interface_output methods respectively, by providing them with the Interfaces that will be respectively the input and output of the SolverWrapperMapped object. The two mappers in the SolverWrapperMapped are also of a special type: they work on the level of Interfaces . They are some sort of mapper-wrapper around the actual mappers which work on ModelPart level. Currently only one such mapper is available, aptly called MapperInterface . At the lowest level, mappers interpolate historical variables between two ModelParts , based on the coordinates of the Nodes . Interpolation is always done from the from - ModelPart to the to - ModelPart . These mappers can be chained together in a MapperCombined mapper, creating in fact another layer of mapping. So many layers! Like an onion!","title":"Hierarchy of mapping-related objects"},{"location":"mappers/#interpolators-and-transformers","text":"The ModelPart -level mappers have two main methods: Initialize and __call__ . The Initialize method performs one-time expensive operations, namely nearest-neighbour search and calculation of the interpolation coefficients. The initialization is done based on the original coordinates X0 , Y0 and Z0 . The __call__ method is used for the actual mapping. It takes two tuples as arguments ( from and to respectively), each tuple containing the ModelPart and the Variable to be used in the interpolation. This method returns nothing: the interpolation is done in-place in the ModelParts . There are two types of ModelPart -level mappers: interpolators and transformers . They can be distinguished by their boolean interpolator attribute (see __init__ ). For interpolators, Initialize gets two ModelPart objects ( from and to ), and returns nothing. These mappers do the real interpolation. Currently MapperNearest , MapperLinear and MapperRadialBasis are available. For transformers, Initialize gets only one ModelPart (from either the from or to side, depending on the transformation), and returns the other ModelPart . Currently MapperPermutation , MapperAxisymmetric2DTo3D and MapperAxisymmetric3DTo2D are available. A transformer can never be used by itself, it must always be combined with an interpolator: the reason is that interpolators use information coming from two sides, which is exactly what the SolverWrapperMapped and MapperInterface objects want. To chain together multiple mappers, the MapperCombined is used: it contains always 1 interpolator and 0 or more transformers, on either side of the interpolator.","title":"Interpolators and transformers"},{"location":"mappers/#overview-of-special-mappers","text":"","title":"Overview of special mappers"},{"location":"mappers/#mapperinterface","text":"Special mapper-class that maps on the level of Interface objects. It takes two Interfaces , and maps the ModelParts to each other in order of appearance, all using the same ModelPart mapper. To use a different ModelPart mapper for the different ModelParts in the Interface , or even for the different historical variables, a new Interface mapper must be written. JSON setting type description type str ModelPart mapper to be used. settings dict All the settings for the ModelPart mapper specified in type .","title":"MapperInterface"},{"location":"mappers/#mappercombined","text":"The MapperCombined is used to chain together multiple mappers. It contains always 1 interpolator and 0 or more transformers, on either side of the interpolator. If transformers are present, intermediate ModelParts are created during initialization. This is done by working inwards towards the interpolator. This means that transformers upstream of the interpolator, are initialized based on the from ModelPart (input), while downstream transformers are initialized based on the to ModelPart (output). Some transformers can only be initialized in one direction, e.g. for MapperAxisymmetric3DTo2D , the 2D to - ModelPart must be supplied, therefore it must be downstream of the interpolator. JSON setting type description mappers list An ordered list of all the ModelPart mappers to be used.","title":"MapperCombined"},{"location":"mappers/#overview-of-transformers","text":"","title":"Overview of transformers"},{"location":"mappers/#mapperpermutation","text":"Permutates the coordinates and the vector variables according to the given permutation . This transformer can be initialized in both directions. JSON setting type description permutation list A permutation of the list [0, 1, 2].","title":"MapperPermutation"},{"location":"mappers/#mapperaxisymmetric2dto3d","text":"Transforms from a 2D axisymmetric geometry to a 3D geometry. This transformer can only be initialized in the forward direction, i.e. based on the 2D axisymmetric ModelPart . Therefore, it should be upstream of the interpolator in the MapperCombined . The 3D ModelPart is returned by the initialization. n_tangential specifies the number of Node objects in the tangential (circumferential) direction. For each Node in the 2D ModelPart , n_tangential Nodes are created in the 3D ModelPart . It is important to take the value of n_tangential large enough. By preference as close as possible to the number of nodes in the tangential direction of the 3D ModelPart . The code knows which directions are axial, radial and tangential thanks to the input parameters direction_axial and direction_radial . It is not possible to change the axial direction between 2D and 3D: a separate MapperPermutation should be added for that purpose. Scalar variables are simply mapped from the 2D Node to all corresponding 3D Nodes . For vector variables, the axial component is simply mapped, the radial component is rotated. The tangential component (e.g. swirl) cannot be taken into account. JSON setting type description direction_axial string Must be \"x\" , \"y\" or \"z\" , specifies the symmetry axis. direction_radial string Must be \"x\" , \"y\" or \"z\" , specifies the second (radial) axis in 2D. n_tangential int Degrees of freedom in tangential (circumferential) direction of 3D ModelPart that is created during initialization. Must be \\geq 6 \\geq 6 .","title":"MapperAxisymmetric2DTo3D"},{"location":"mappers/#mapperaxisymmetric3dto2d","text":"Transforms from a 3D geometry to a 2D axisymmetric geometry. This transformer can only be initialized in the backward direction, i.e. based on the 2D axisymmetric ModelPart . Therefore, it should be downstream of the MapperInterpolator in the MapperCombined . For scalar variables, the circumferential average is taken for each 2D Node . For vector variables too, taking into account the correct radial direction in each 3D Node . Again, swirl cannot be taken into account: if a tangential component is present in 3D, it is not mapped to 2D. For more information and JSON settings, see MapperAxisymmetric2DTo3D which is very similar.","title":"MapperAxisymmetric3DTo2D"},{"location":"mappers/#overview-of-interpolators","text":"","title":"Overview of interpolators"},{"location":"mappers/#mapperinterpolator","text":"Base-class for all interpolators (currently MapperNearest , MapperLinear and MapperRadialBasis ). JSON setting type description directions list List of coordinate directions, maximum three entries, may contain \"x\" , \"y\" , \"z\" . scaling list Optional. List of scaling factors, must be same length as directions . Coordinates are scaled with these factors, this may improve interpolation e.g. when cells have a high aspect ratio with respect to one of the axes. balanced_tree bool Optional, default false . If set to true a balanced cKDTree is created, which is more stable, but takes longer to build. Set to true in the rare case that the tree gives problems. The Initialize method should be called in all child-classes. It does the following: read and store the coordinates from the from and to ModelParts scale coordinates if necessary check if the bounding boxes of the from and to ModelParts are more or less overlapping do an efficient nearest neighbour search using scipy.spatial.cKDTree check if the from ModelPart does not contain duplicate Nodes (i.e. with same coordinates) The __call__ method should not be overridden in the child-classes. It maps historical variables based on neighbours and coefficients determined in Initialize . Historical variables of type Double and type Array can be mapped (the latter is just the application of the former for each vector component).","title":"MapperInterpolator"},{"location":"mappers/#mappernearest","text":"Child-class of MapperInterpolator , does not require additional settings. Does simple nearest-neighbour mapping.","title":"MapperNearest"},{"location":"mappers/#mapperlinear","text":"Child-class of MapperInterpolator , additional settings: JSON setting type description parallel bool Optional, default false . If true the package multiprocessing is used to parallellize the loop that the calculates the interpolation coefficients. This is only useful for ModelParts with a very high number of Nodes . The kind of linear mapping depends on the number of coordinate directions, as given in the directions setting. 1D - If the to -point lies between the 2 nearest from -points, linear interpolation is done. Else, nearest neighbour interpolation is done. 2D - The to -point is first projected on the line through the 2 nearest from -points. If the projected point lies between the from -points, linear interpolation is done. Else, nearest neighbour interpolation is done. 3D - The to -point is first projected on the plane through the 3 nearest from -points. If the triangle consinsting of those 3 points is deprecated (colinear points), the 2D-methodology is followed. Else, if the projected point lies inside the triangle, barycentric interpolation is done. If it lies outside the triangle, the 2D-methodology is followed.","title":"MapperLinear"},{"location":"mappers/#mapperradialbasis","text":"Child-class of MapperInterpolator , additional settings: JSON setting type description parallel bool Optional, default false . If true the package multiprocessing is used to parallellize the loop that the calculates the interpolation coefficients. This is only useful for ModelParts with a very high number of Nodes . shape_parameter int Optional, default 200 . Should be chosen as large as possible without rendering the interpolation matrix ill-conditioned. Radial basis function interpolation is relatively straightforward: implementation for 1D, 2D and 3D is exactly the same and can be written in a condensed way using scipy.spatial.distance . Normal radial basis interpolation is done as follows. \\phi(r) \\phi(r) is a radial basis function defined as \\phi(r) = \\begin{cases} (1-\\frac{r}{d_{ref}})^4 (1 + 4\\frac{r}{d_{ref}}) \\quad &\\mathrm{for} \\quad 0 \\leq \\frac{r}{d_{ref}} < 1 \\\\ 0 &\\mathrm{for} \\quad 1 \\leq \\frac{r}{d_{ref}} \\end{cases} \\phi(r) = \\begin{cases} (1-\\frac{r}{d_{ref}})^4 (1 + 4\\frac{r}{d_{ref}}) \\quad &\\mathrm{for} \\quad 0 \\leq \\frac{r}{d_{ref}} < 1 \\\\ 0 &\\mathrm{for} \\quad 1 \\leq \\frac{r}{d_{ref}} \\end{cases} with r r a positive distance. To control the width of the function, r r is scaled with a reference distance d_{ref} d_{ref} . Assume that n n nearest from -points will be used in the interpolation. An unknown function f(\\boldsymbol{x}) f(\\boldsymbol{x}) can then be approximated as the weighted sum of n n shifted radial basis functions: f(\\boldsymbol{x}) = \\sum_j \\alpha_j \\phi(||\\boldsymbol{x} - \\boldsymbol{x}_j||) f(\\boldsymbol{x}) = \\sum_j \\alpha_j \\phi(||\\boldsymbol{x} - \\boldsymbol{x}_j||) To determine the coefficients \\alpha_j \\alpha_j , we require that the exact function value is returned at the n n from -points. This gives us n n equations f(\\boldsymbol{x}_i) = f_i = \\sum_j \\alpha_j \\phi(||\\boldsymbol{x}_i - \\boldsymbol{x}_j||) f(\\boldsymbol{x}_i) = f_i = \\sum_j \\alpha_j \\phi(||\\boldsymbol{x}_i - \\boldsymbol{x}_j||) which can be written in matrix form as \\boldsymbol{f} = \\boldsymbol{\\Phi} \\boldsymbol{\\alpha} \\boldsymbol{f} = \\boldsymbol{\\Phi} \\boldsymbol{\\alpha} with \\boldsymbol{f}, \\boldsymbol{\\alpha} \\in \\mathbb{R}^{n \\times 1} \\boldsymbol{f}, \\boldsymbol{\\alpha} \\in \\mathbb{R}^{n \\times 1} , and \\boldsymbol{\\Phi} \\in \\mathbb{R}^{n \\times n} \\boldsymbol{\\Phi} \\in \\mathbb{R}^{n \\times n} . This system can be solved for the weights-vector \\boldsymbol{\\alpha} \\boldsymbol{\\alpha} . However, in our case, the from -point values vector \\boldsymbol{f} \\boldsymbol{f} is not known in advance: it contains the values of the Variable that will be interpolated. Therefore, the approximation to calculate the interpolatoin in the to -point is rewritten as follows: f(\\boldsymbol{x}_{to}) = \\sum_j \\alpha_j \\phi(||\\boldsymbol{x}_{to} - \\boldsymbol{x}_j||) = \\boldsymbol{\\Phi}_{to}^T \\boldsymbol{\\alpha} = \\boldsymbol{\\Phi}_{to}^T \\boldsymbol{\\Phi}^{-1} \\boldsymbol{f} = \\boldsymbol{c}^T \\boldsymbol{f} f(\\boldsymbol{x}_{to}) = \\sum_j \\alpha_j \\phi(||\\boldsymbol{x}_{to} - \\boldsymbol{x}_j||) = \\boldsymbol{\\Phi}_{to}^T \\boldsymbol{\\alpha} = \\boldsymbol{\\Phi}_{to}^T \\boldsymbol{\\Phi}^{-1} \\boldsymbol{f} = \\boldsymbol{c}^T \\boldsymbol{f} The coefficients vector \\boldsymbol{c} \\boldsymbol{c} can now be calculated based only on the coordinates by solving the system \\boldsymbol{\\Phi} \\ \\boldsymbol{c} = \\boldsymbol{\\Phi}_{to}. \\boldsymbol{\\Phi} \\ \\boldsymbol{c} = \\boldsymbol{\\Phi}_{to}. As every to-point has different nearest neighbours in the from -points, the coefficient vector \\boldsymbol{c} \\boldsymbol{c} must be calculated for each to -point independently. The matrix \\boldsymbol{\\Phi} \\boldsymbol{\\Phi} and vector \\boldsymbol{\\Phi}_{to} \\boldsymbol{\\Phi}_{to} must also be calculated for every to -point independently. For every to -point, the reference distance d_{ref} d_{ref} is determined as the product of the shape_parameter and the distance between the to -point and the furthest from -point. In order to ensure that the basis function of each of the nearest from -points covers every from -point, the shape_parameter should be larger than two. This value may however lead to an interpolation function which consists of sharp peaks or wiggles, with the correct value near the from -points, but a deviating value away from them. In the extreme case of d_{ref} d_{ref} approaching zero, the so-called \"bed-of-nails interpolant\" is obtained, which is close to zero everywhere, except near the from -points where it sharply peaks. In this case the interpolation matrix approaches the identity matrix. Choosing a higher value improves the interpolation as the basis functions become wider, but the interpolation matrix becomes less stable, i.e. the condition number increases. The default value is 200. In practice, the shape_parameter is chosen so that the interpolation matrix is \"on the edge of ill-conditioning\" (eg. with a condition number of roughly 10^{13} 10^{13} for double-precision floating point). A warning is printed when the condition number of an interpolation matrix becomes higher than 10^{13} 10^{13} .","title":"MapperRadialBasis"},{"location":"models/","text":"Models This documentation describes the models which are available. These models always approximate a (inverse) Jacobian, denoted here by J J . Receiving an input, called \\Delta x \\Delta x , they return an estimation of J\\Delta x=\\Delta r J\\Delta x=\\Delta r . In order to improve the estimation, information is added, when it becomes available. This information consists of pairs of calculated differences \\Delta x \\Delta x and \\Delta r \\Delta r . The different models use this information in a different way. LS The abbreviation LS stands for least-squares . This model requires the approximation of J J , to fulfill the secant equations of the current and q previous time steps. Moreover, it is required that the approximation is least-squares. This model is matrix-free, due to an implementation using QR-decomposition. With matrix-free is meant that no large dense matrices are constructed, not that no matrices are used at all. The optimal value of q is problem dependent. Typically however, an optimal value is around 10. The R R matrix from the QR-decompostion has to be invertible. Therefore, (almost) linear columns in the matrix containing the input information from the current and previous time steps should be removed. This is called filtering. The larger q , the more important filtering becomes. If the diagonal element in R R is smaller than an absolute tolerance level, the corresponding column is removed. The most recent information is kept. For more information refer to . Settings The following parameters need to be included in the settings dictionary. They are listed in alphabetical order. parameter type description min_significant double Absolute tolerance for filtering. q int Number of previous time steps that are reused. In a steady simulation there are no previous time steps, so then it should be 0. MV The abbreviation MV stands for multi-vector . not matrix free, not for large number of degrees of freedom on the interface. This model requires the approximation of J J , to fulfill the secant equations of the current time step only. Moreover, it is required that the approximation is as close as possible to the previous time step. In this model large dense matrices are constructed and is hence discouraged for cases with a large number of degrees of freedom on the interface. Here filtering can also be applied. Then, (almost) linear columns in the matrix containing the input information from the current time step are removed. If the diagonal element in R R is smaller than an absolute tolerance level, the corresponding column is removed. The most recent information is kept. However, filtering is much less critical compared to the LS model as it concerns only the information from th current time step. If no filtering is wanted, the tolerance level should be set to zero. For more infromation refer to . Settings The following parameters need to be included in the settings dictionary. They are listed in alphabetical order. parameter type description min_significant double Absolute tolerance for filtering. MV-MF The abbreviation MV-MF stands for multi-vector matrix-free . This method implements the multi-vector method, but in a matrix-free way. Therefore, a parameter q is used to denote how many time steps are re-used. Setting this parameter very large, this model will act the same as MV , which reuses all time steps. Settings The following parameters need to be included in the settings dictionary. They are listed in alphabetical order. parameter type description min_significant double Absolute tolerance for filtering. q int Number of previous time steps that are reused. In a steady simulation there are no previous time steps, so then it should be 0.","title":"Models"},{"location":"models/#models","text":"This documentation describes the models which are available. These models always approximate a (inverse) Jacobian, denoted here by J J . Receiving an input, called \\Delta x \\Delta x , they return an estimation of J\\Delta x=\\Delta r J\\Delta x=\\Delta r . In order to improve the estimation, information is added, when it becomes available. This information consists of pairs of calculated differences \\Delta x \\Delta x and \\Delta r \\Delta r . The different models use this information in a different way.","title":"Models"},{"location":"models/#ls","text":"The abbreviation LS stands for least-squares . This model requires the approximation of J J , to fulfill the secant equations of the current and q previous time steps. Moreover, it is required that the approximation is least-squares. This model is matrix-free, due to an implementation using QR-decomposition. With matrix-free is meant that no large dense matrices are constructed, not that no matrices are used at all. The optimal value of q is problem dependent. Typically however, an optimal value is around 10. The R R matrix from the QR-decompostion has to be invertible. Therefore, (almost) linear columns in the matrix containing the input information from the current and previous time steps should be removed. This is called filtering. The larger q , the more important filtering becomes. If the diagonal element in R R is smaller than an absolute tolerance level, the corresponding column is removed. The most recent information is kept. For more information refer to .","title":"LS"},{"location":"models/#settings","text":"The following parameters need to be included in the settings dictionary. They are listed in alphabetical order. parameter type description min_significant double Absolute tolerance for filtering. q int Number of previous time steps that are reused. In a steady simulation there are no previous time steps, so then it should be 0.","title":"Settings"},{"location":"models/#mv","text":"The abbreviation MV stands for multi-vector . not matrix free, not for large number of degrees of freedom on the interface. This model requires the approximation of J J , to fulfill the secant equations of the current time step only. Moreover, it is required that the approximation is as close as possible to the previous time step. In this model large dense matrices are constructed and is hence discouraged for cases with a large number of degrees of freedom on the interface. Here filtering can also be applied. Then, (almost) linear columns in the matrix containing the input information from the current time step are removed. If the diagonal element in R R is smaller than an absolute tolerance level, the corresponding column is removed. The most recent information is kept. However, filtering is much less critical compared to the LS model as it concerns only the information from th current time step. If no filtering is wanted, the tolerance level should be set to zero. For more infromation refer to .","title":"MV"},{"location":"models/#settings_1","text":"The following parameters need to be included in the settings dictionary. They are listed in alphabetical order. parameter type description min_significant double Absolute tolerance for filtering.","title":"Settings"},{"location":"models/#mv-mf","text":"The abbreviation MV-MF stands for multi-vector matrix-free . This method implements the multi-vector method, but in a matrix-free way. Therefore, a parameter q is used to denote how many time steps are re-used. Setting this parameter very large, this model will act the same as MV , which reuses all time steps.","title":"MV-MF"},{"location":"models/#settings_2","text":"The following parameters need to be included in the settings dictionary. They are listed in alphabetical order. parameter type description min_significant double Absolute tolerance for filtering. q int Number of previous time steps that are reused. In a steady simulation there are no previous time steps, so then it should be 0.","title":"Settings"},{"location":"openfoam/","text":"SolverWrapperOpenFOAM This is the documentation for all OpenFOAM solver-wrappers. Currently only FSI simulations are supported, no other multiphysics problems. Parameters This section describes the parameters in the JSON file, listed in alphabetical order. parameter type description application string Name of the (adapted) OpenFOAM-solver to be used for the flow problem. This name should start with CoCoNuT_ . working_directory string Directory where the OpenFOAM-case is defined (and which contains the JSON-file). dimensions int Dimension used in flow solver: 2 for 2D and axisymmetric, 3 for 3D. start_time double Physical start time of the simulation. This should correspond to the name of the time step folder in OpenFOAM from which the initial data and boundary conditions are read. end_time double Physical end time of the simulation. dt double Fixed timestep size in flow solver. This parameter is usually specified in a higher Component . boundary_names list List of names of the patches corresponding to the interface. These names should match the patch names defined in the OpenFOAM-case. interface_input dict List of ModelPart names and Variables pairs that provides interface boundary conditions for the OpenFOAM solver. Each entry in the list has two keys: model_part and variables with values as name of the ModelPart and list of input variables available in variables.py . The ModelPart name must be the concatenation of an entry from boundary_names and \"_input\". interface_output dict Analogous to interface_input , but here the name must be the concatenation of an entry from boundary_names and \"_output\". The entries in the list provides boundary conditions for the other solver(s) participating in the coupled simulation. cores int Number of cores on which the OpenFOAM-solver can run. This variable will be replaced in the raw decomposeParDict -file, after which the case is decomposed of the given number of cores. decomposeMethod string Name of the mesh decomposition method to be used in OpenFOAM (e.g. simple , scotch ...). write_interval double Period between subsequent saves of the entire flow field. write_precision int Number of digits after the decimal sign to be used when writing data to time step folders or the postProcessing -folder. time_precision int Number of digits after the decimal sign to be used in the name of the time step directories which are made during execution. meshmotion_solver string Name of the mesh motion solver to be used in OpenFOAM (e.g. displacementLaplacian ...). diffusivity string Name of the diffusivity constant used in the mesh motion solver in OpenFOAM (e.g. inverseDistance ...). Overview of the Python-file The solver-wrapper itself consists of only one Python-file: OpenFOAM_X.py , with X the identifier of the OpenFOAM-version (e.g. 41 for OpenFOAM 4.1). Aside from this, the Python-file constructs a number of files such as controlDict , pointDisplacement and decomposeParDict by starting from the _raw -files in the solver-wrapper directory and replacing the names of the settings with their user-defined values (listed in the table above). Finally, using an OpenFOAM-solver in CoCoNuT requires the adaptation of the solver to accomodate the internal messaging system used during the FSI-simulation. Currently, only pimpleFoam and interFoam have been adapted; the solvers called by the solver-wrapper have the same name as the original OpenFOAM-solver but with CoCoNuT_ added to the name. Upon using the OpenFOAM-wrapper, the solver to be used upon execution needs to be compiled using the default OpenFOAM-compilation method (loading the OpenFOAM-module and using wmake ). The __init__ method During initialization, the case settings as defined in the JSON-file are read into the corresponding Python-variables. Afterwards, the required OpenFOAM-files are constructed and some checks are in place to verify whether the necessary (and correct) modules are loaded. Next, the interface names are loaded and the tool writeCellCentres is used to read in the points located on said interfaces. Finally, the variables on each interface are stored in the data-structure of CoCoNuT. The Initialize method The OpenFOAM-solver, which should be adapted to operation in CoCoNuT, is launched in a subprocess. Other variables, such as time step index and physical time, are initialized. The InitializeSolutionStep method This function is called at the start of every time step. The time step index is increased by one, the iteration index is set to zero and the OpenFOAM file directory is made in which the time step data needs to be stored (this last part is probably superfluous and can be removed at a later stage). The SolveSolutionStep method The interface displacement is converted into an OpenFOAM-readable format (with the function write_node_input ), after which the OpenFOAM-loop is called in a subprocess. After completion of the OpenFOAM-loop, the function read_node_output is called, which reads the interface loads from the corresponding OpenFOAM-directory (in the postProcessing -folder). The FinalizeSolutionStep method In this method, it is checked whether the other flow variables need to be written in an OpenFOAM-directory. This save-option is done in OpenFOAM. The Finalize method The OpenFOAM-subprocess, which was launched in the Initialize method, is killed. Comments Files with extension .coco are used to pass messages between Python and OpenFOAM. After sending a message from Python to OpenFOAM, the Python-script is paused until it receives the corresponding message from OpenFOAM. The OpenFOAM-solver is operating in an infinite while -loop until it receives a message from Python. Upon receipt of this message, OpenFOAM executes the corresponding action after which it sends a response to Python and reverts into its infinite loop (waiting mode). The aforementioned messaging procedure implies that OpenFOAM is constantly running during execution of the CoCoNuT-simulation. It is closed by the Python-code only in the Finalize method, but if CoCoNuT crashes, the OpenFOAM-programme keeps running. The user should take care to kill that OpenFOAM-loop manually (using kill or pkill in the Linux-terminal, e.g. pkill CoCoNuT_* ). The interface displacement is stored in a pointDisplacement -field, which is read in by OpenFOAM in every iteration (this required some adaptation of the solver, see next section). The dynamic mesh motion is handled by OpenFOAM itself. The interface loads are stored in the postProcessing -directory, under the names PRESSURE and TRACTION . These are constructed from a controlDict -file which is defined in the _init_ -method of the solver wrapper in Python. Overview of an OpenFOAM-solver used in CoCoNuT Default OpenFOAM-solvers cannot be used in the CoCoNuT-framework, but need to be adjusted. Adapted solvers are stored in the solverwrapper-directory and receive the name CoCoNuT_X , where X is the name of the original solver, e.g. pimpleFoam . If a new solver needs to be adapted to operation in CoCoNuT, one of the already established solvers can work as an example. In brief, the following steps should be undertaken: Except for the initial include -statements, the entire solver code should be put in a loop that starts with while(true) . Just before this while-loop, add the statement runTime.run(); ! This is important as it creates and initializes the functionObjects in the controlDict -file which will be used for storing the interface loads. Due to the fact that the infinite loop is driven by while(true) and not the default OpenFOAM-expression while(runTime.run()) , OpenFOAM does not check itself whether the final time step is reached. In proper CoCoNuT-operation, OpenFOAM is killed when the solver wrapper reaches the final time step, but this might not be the case if the OpenFOAM-solverwrapper is tested separately. Inside the while-loop, a sleep-command is added such that the solver is not constantly checking the conditional statements. The while-loop contains several conditional statements, each of which check whether the Python-code in CoCoNuT has sent a message to the OpenFOAM-solver. This message is sent by creating an empty file with a specific name in the OpenFOAM-directory. The following file names should be checked by the OpenFOAM-solver: next.coco , continue.coco , save.coco , stop.coco . If the file next.coco exists, the runTime-object should be increased by one. OpenFOAM should create a file next_ready.coco upon completion. Do not forget to delete the original next.coco -file, which is advised to do just before creating the next_ready.coco , so near the end of the if -clause. If the file continue.coco exists, the flow equations need to be solved. This if -statement consequently contains most of the original solver definition, in which the flow equations are called in the same order as in the original CFD solver. OpenFOAM should create a file continue_ready.coco upon completion. Do not forget to delete the original continue.coco -file, which is advised to do just before creating the continue_ready.coco , so near the end of the if -clause. If the file save.coco exists, OpenFOAM checks whether the flow variables should be stored in corresponding files, according to the user-defined save interval. OpenFOAM should create a file save_ready.coco upon completion. Do not forget to delete the original save.coco -file, which is advised to do just before creating the save_ready.coco , so near the end of the if -clause. If the file stop.coco exists, a break -statement should end the infinite loop (the subprocess is also killed in the Python-code). OpenFOAM should create a file stop_ready.coco before breaking the while -loop. Do not forget to delete the original stop.coco -file, which is advised to do just before creating the stop_ready.coco , so near the end of the if -clause. Setting up a new case Following items should be present in the OpenFOAM-directory prior to launching CoCoNuT: The entire framework of the CFD-case in OpenFOAM which is to be used in the CoCoNuT simulation (so it should contain the constant and system directory as well as a time step directory). The working directory should be defined as if you would like to run it as a CFD case. The working directory is defined in a JSON-file and therefore the CoCoNuT-files do not need to be in the same folder as the OpenFOAM-case. a JSON-file containing all of the settings stipulated above. Following items are taken care of by CoCoNuT, and must therefore not be included in the original OpenFOAM-directory: controlDict -file with the necessary function objects to define the interface pressure/traction dynamicMeshDict -file which contains the settings for OpenFOAM's dynamic motion solver decomposeParDict -file with the necessary decomposition of the fluid domain (if cores >1) Comments It is probably best to derive a new case from a test case already present in the CoCoNuT-installation in order to copy its structure. If you do not use an OpenFOAM-solver which is already converted for operation in CoCoNuT, you will need to adapt the solver yourself. This can be done in a rather straightforward way by taking a look at already implemented solvers. You should compile the new solver BEFORE loading the CoCoNuT-modules as the overwriting of compiler modules can break the wmake -command. Once the new solver is compiled, it works fine even after loading the CoCoNuT-modules. OpenFOAM is known for generating a lot of files, which is not different in CoCoNuT-operation. Make sure you have sufficient storage space on your cluster and that you are able to write a large number of files (the latter is specifically important when storing data in your home-directory). Version specific documentation OpenFOAM_41 (OpenFOAM 4.1) This is currently the only version.","title":"SolverWrapperOpenFOAM"},{"location":"openfoam/#solverwrapperopenfoam","text":"This is the documentation for all OpenFOAM solver-wrappers. Currently only FSI simulations are supported, no other multiphysics problems.","title":"SolverWrapperOpenFOAM"},{"location":"openfoam/#parameters","text":"This section describes the parameters in the JSON file, listed in alphabetical order. parameter type description application string Name of the (adapted) OpenFOAM-solver to be used for the flow problem. This name should start with CoCoNuT_ . working_directory string Directory where the OpenFOAM-case is defined (and which contains the JSON-file). dimensions int Dimension used in flow solver: 2 for 2D and axisymmetric, 3 for 3D. start_time double Physical start time of the simulation. This should correspond to the name of the time step folder in OpenFOAM from which the initial data and boundary conditions are read. end_time double Physical end time of the simulation. dt double Fixed timestep size in flow solver. This parameter is usually specified in a higher Component . boundary_names list List of names of the patches corresponding to the interface. These names should match the patch names defined in the OpenFOAM-case. interface_input dict List of ModelPart names and Variables pairs that provides interface boundary conditions for the OpenFOAM solver. Each entry in the list has two keys: model_part and variables with values as name of the ModelPart and list of input variables available in variables.py . The ModelPart name must be the concatenation of an entry from boundary_names and \"_input\". interface_output dict Analogous to interface_input , but here the name must be the concatenation of an entry from boundary_names and \"_output\". The entries in the list provides boundary conditions for the other solver(s) participating in the coupled simulation. cores int Number of cores on which the OpenFOAM-solver can run. This variable will be replaced in the raw decomposeParDict -file, after which the case is decomposed of the given number of cores. decomposeMethod string Name of the mesh decomposition method to be used in OpenFOAM (e.g. simple , scotch ...). write_interval double Period between subsequent saves of the entire flow field. write_precision int Number of digits after the decimal sign to be used when writing data to time step folders or the postProcessing -folder. time_precision int Number of digits after the decimal sign to be used in the name of the time step directories which are made during execution. meshmotion_solver string Name of the mesh motion solver to be used in OpenFOAM (e.g. displacementLaplacian ...). diffusivity string Name of the diffusivity constant used in the mesh motion solver in OpenFOAM (e.g. inverseDistance ...).","title":"Parameters"},{"location":"openfoam/#overview-of-the-python-file","text":"The solver-wrapper itself consists of only one Python-file: OpenFOAM_X.py , with X the identifier of the OpenFOAM-version (e.g. 41 for OpenFOAM 4.1). Aside from this, the Python-file constructs a number of files such as controlDict , pointDisplacement and decomposeParDict by starting from the _raw -files in the solver-wrapper directory and replacing the names of the settings with their user-defined values (listed in the table above). Finally, using an OpenFOAM-solver in CoCoNuT requires the adaptation of the solver to accomodate the internal messaging system used during the FSI-simulation. Currently, only pimpleFoam and interFoam have been adapted; the solvers called by the solver-wrapper have the same name as the original OpenFOAM-solver but with CoCoNuT_ added to the name. Upon using the OpenFOAM-wrapper, the solver to be used upon execution needs to be compiled using the default OpenFOAM-compilation method (loading the OpenFOAM-module and using wmake ).","title":"Overview of the Python-file"},{"location":"openfoam/#the-__init__-method","text":"During initialization, the case settings as defined in the JSON-file are read into the corresponding Python-variables. Afterwards, the required OpenFOAM-files are constructed and some checks are in place to verify whether the necessary (and correct) modules are loaded. Next, the interface names are loaded and the tool writeCellCentres is used to read in the points located on said interfaces. Finally, the variables on each interface are stored in the data-structure of CoCoNuT.","title":"The __init__ method"},{"location":"openfoam/#the-initialize-method","text":"The OpenFOAM-solver, which should be adapted to operation in CoCoNuT, is launched in a subprocess. Other variables, such as time step index and physical time, are initialized.","title":"The Initialize method"},{"location":"openfoam/#the-initializesolutionstep-method","text":"This function is called at the start of every time step. The time step index is increased by one, the iteration index is set to zero and the OpenFOAM file directory is made in which the time step data needs to be stored (this last part is probably superfluous and can be removed at a later stage).","title":"The InitializeSolutionStep method"},{"location":"openfoam/#the-solvesolutionstep-method","text":"The interface displacement is converted into an OpenFOAM-readable format (with the function write_node_input ), after which the OpenFOAM-loop is called in a subprocess. After completion of the OpenFOAM-loop, the function read_node_output is called, which reads the interface loads from the corresponding OpenFOAM-directory (in the postProcessing -folder).","title":"The SolveSolutionStep method"},{"location":"openfoam/#the-finalizesolutionstep-method","text":"In this method, it is checked whether the other flow variables need to be written in an OpenFOAM-directory. This save-option is done in OpenFOAM.","title":"The FinalizeSolutionStep method"},{"location":"openfoam/#the-finalize-method","text":"The OpenFOAM-subprocess, which was launched in the Initialize method, is killed.","title":"The Finalize method"},{"location":"openfoam/#comments","text":"Files with extension .coco are used to pass messages between Python and OpenFOAM. After sending a message from Python to OpenFOAM, the Python-script is paused until it receives the corresponding message from OpenFOAM. The OpenFOAM-solver is operating in an infinite while -loop until it receives a message from Python. Upon receipt of this message, OpenFOAM executes the corresponding action after which it sends a response to Python and reverts into its infinite loop (waiting mode). The aforementioned messaging procedure implies that OpenFOAM is constantly running during execution of the CoCoNuT-simulation. It is closed by the Python-code only in the Finalize method, but if CoCoNuT crashes, the OpenFOAM-programme keeps running. The user should take care to kill that OpenFOAM-loop manually (using kill or pkill in the Linux-terminal, e.g. pkill CoCoNuT_* ). The interface displacement is stored in a pointDisplacement -field, which is read in by OpenFOAM in every iteration (this required some adaptation of the solver, see next section). The dynamic mesh motion is handled by OpenFOAM itself. The interface loads are stored in the postProcessing -directory, under the names PRESSURE and TRACTION . These are constructed from a controlDict -file which is defined in the _init_ -method of the solver wrapper in Python.","title":"Comments"},{"location":"openfoam/#overview-of-an-openfoam-solver-used-in-coconut","text":"Default OpenFOAM-solvers cannot be used in the CoCoNuT-framework, but need to be adjusted. Adapted solvers are stored in the solverwrapper-directory and receive the name CoCoNuT_X , where X is the name of the original solver, e.g. pimpleFoam . If a new solver needs to be adapted to operation in CoCoNuT, one of the already established solvers can work as an example. In brief, the following steps should be undertaken: Except for the initial include -statements, the entire solver code should be put in a loop that starts with while(true) . Just before this while-loop, add the statement runTime.run(); ! This is important as it creates and initializes the functionObjects in the controlDict -file which will be used for storing the interface loads. Due to the fact that the infinite loop is driven by while(true) and not the default OpenFOAM-expression while(runTime.run()) , OpenFOAM does not check itself whether the final time step is reached. In proper CoCoNuT-operation, OpenFOAM is killed when the solver wrapper reaches the final time step, but this might not be the case if the OpenFOAM-solverwrapper is tested separately. Inside the while-loop, a sleep-command is added such that the solver is not constantly checking the conditional statements. The while-loop contains several conditional statements, each of which check whether the Python-code in CoCoNuT has sent a message to the OpenFOAM-solver. This message is sent by creating an empty file with a specific name in the OpenFOAM-directory. The following file names should be checked by the OpenFOAM-solver: next.coco , continue.coco , save.coco , stop.coco . If the file next.coco exists, the runTime-object should be increased by one. OpenFOAM should create a file next_ready.coco upon completion. Do not forget to delete the original next.coco -file, which is advised to do just before creating the next_ready.coco , so near the end of the if -clause. If the file continue.coco exists, the flow equations need to be solved. This if -statement consequently contains most of the original solver definition, in which the flow equations are called in the same order as in the original CFD solver. OpenFOAM should create a file continue_ready.coco upon completion. Do not forget to delete the original continue.coco -file, which is advised to do just before creating the continue_ready.coco , so near the end of the if -clause. If the file save.coco exists, OpenFOAM checks whether the flow variables should be stored in corresponding files, according to the user-defined save interval. OpenFOAM should create a file save_ready.coco upon completion. Do not forget to delete the original save.coco -file, which is advised to do just before creating the save_ready.coco , so near the end of the if -clause. If the file stop.coco exists, a break -statement should end the infinite loop (the subprocess is also killed in the Python-code). OpenFOAM should create a file stop_ready.coco before breaking the while -loop. Do not forget to delete the original stop.coco -file, which is advised to do just before creating the stop_ready.coco , so near the end of the if -clause.","title":"Overview of an OpenFOAM-solver used in CoCoNuT"},{"location":"openfoam/#setting-up-a-new-case","text":"Following items should be present in the OpenFOAM-directory prior to launching CoCoNuT: The entire framework of the CFD-case in OpenFOAM which is to be used in the CoCoNuT simulation (so it should contain the constant and system directory as well as a time step directory). The working directory should be defined as if you would like to run it as a CFD case. The working directory is defined in a JSON-file and therefore the CoCoNuT-files do not need to be in the same folder as the OpenFOAM-case. a JSON-file containing all of the settings stipulated above. Following items are taken care of by CoCoNuT, and must therefore not be included in the original OpenFOAM-directory: controlDict -file with the necessary function objects to define the interface pressure/traction dynamicMeshDict -file which contains the settings for OpenFOAM's dynamic motion solver decomposeParDict -file with the necessary decomposition of the fluid domain (if cores >1)","title":"Setting up a new case"},{"location":"openfoam/#comments_1","text":"It is probably best to derive a new case from a test case already present in the CoCoNuT-installation in order to copy its structure. If you do not use an OpenFOAM-solver which is already converted for operation in CoCoNuT, you will need to adapt the solver yourself. This can be done in a rather straightforward way by taking a look at already implemented solvers. You should compile the new solver BEFORE loading the CoCoNuT-modules as the overwriting of compiler modules can break the wmake -command. Once the new solver is compiled, it works fine even after loading the CoCoNuT-modules. OpenFOAM is known for generating a lot of files, which is not different in CoCoNuT-operation. Make sure you have sufficient storage space on your cluster and that you are able to write a large number of files (the latter is specifically important when storing data in your home-directory).","title":"Comments"},{"location":"openfoam/#version-specific-documentation","text":"","title":"Version specific documentation"},{"location":"openfoam/#openfoam_41-openfoam-41","text":"This is currently the only version.","title":"OpenFOAM_41 (OpenFOAM 4.1)"},{"location":"predictors/","text":"Predictors This documentation describes the available predictors. A predictor is used to determine the initial guess in each time step by extrapolating the solution from previous time steps. The different predictors differ in the number of previous iterations they take into account and the polynomial degree that is used. Only the type has to be provided (e.g. predictors.linear ), no settings dictionary is required. Specification of a predictor is mandatory, also for a steady simulation. In that case however, it does not matter which predictor is chosen as only one \"time step\" is performed. Constant This predictor uses the result from the last time step as the initial guess in the current time step $$ x^{n+1}=x^{n}. $$ Linear This predictor uses the results from the last two time steps to determine the initial guess in the current time step using a linear extrapolation as follows $$ x^{n+1}=2x^{n}-1x^{n-1}. $$ If no two previous solutions are available, the solution from the last time step is used, i.e. the predictor constant . Legacy This predictor uses the results from the last three time steps to determine the initial guess in the current time step using a linear extrapolation as follows $$ x^{n+1}=\\frac{5}{2}x^{n}-2x^{n-1}+\\frac{1}{2}x^{n-2}. $$ If no three previous solutions are available, the predictor linear is used. This predictor is called legacy as it corresponds to the 2nd order extrapolator in the coupling code Tango. Quadratic This predictor uses the results from the last three time steps to determine the initial guess in the current time step using a quadratic extrapolation as follows $$ x^{n+1}=3x^{n}-3x^{n-1}+1x^{n-2}. $$ If no three previous solutions are available, the predictor linear is used. Cubic This predictor uses the results from the last three time steps to determine the initial guess in the current time step using a cubic extrapolation as follows $$ x^{n+1}=4x^{n}-6x^{n-1}+4x^{n-2}-1x^{n-3}. $$ If no four previous solutions are available, the predictor quadratic is used.","title":"Predictors"},{"location":"predictors/#predictors","text":"This documentation describes the available predictors. A predictor is used to determine the initial guess in each time step by extrapolating the solution from previous time steps. The different predictors differ in the number of previous iterations they take into account and the polynomial degree that is used. Only the type has to be provided (e.g. predictors.linear ), no settings dictionary is required. Specification of a predictor is mandatory, also for a steady simulation. In that case however, it does not matter which predictor is chosen as only one \"time step\" is performed.","title":"Predictors"},{"location":"predictors/#constant","text":"This predictor uses the result from the last time step as the initial guess in the current time step $$ x^{n+1}=x^{n}. $$","title":"Constant"},{"location":"predictors/#linear","text":"This predictor uses the results from the last two time steps to determine the initial guess in the current time step using a linear extrapolation as follows $$ x^{n+1}=2x^{n}-1x^{n-1}. $$ If no two previous solutions are available, the solution from the last time step is used, i.e. the predictor constant .","title":"Linear"},{"location":"predictors/#legacy","text":"This predictor uses the results from the last three time steps to determine the initial guess in the current time step using a linear extrapolation as follows $$ x^{n+1}=\\frac{5}{2}x^{n}-2x^{n-1}+\\frac{1}{2}x^{n-2}. $$ If no three previous solutions are available, the predictor linear is used. This predictor is called legacy as it corresponds to the 2nd order extrapolator in the coupling code Tango.","title":"Legacy"},{"location":"predictors/#quadratic","text":"This predictor uses the results from the last three time steps to determine the initial guess in the current time step using a quadratic extrapolation as follows $$ x^{n+1}=3x^{n}-3x^{n-1}+1x^{n-2}. $$ If no three previous solutions are available, the predictor linear is used.","title":"Quadratic"},{"location":"predictors/#cubic","text":"This predictor uses the results from the last three time steps to determine the initial guess in the current time step using a cubic extrapolation as follows $$ x^{n+1}=4x^{n}-6x^{n-1}+4x^{n-2}-1x^{n-3}. $$ If no four previous solutions are available, the predictor quadratic is used.","title":"Cubic"},{"location":"python/","text":"SolverWrapperPython This is the documentation for all Python SolverWrappers. Currently only solvers exist for the 1D calculation of a straight flexible tube. Tube There are three tube solvers for a straight tube with circular cross-section. The axial direction is along the z-axis. All of them are 1D solvers. This means the tube is divided in m intervals in the axial z-direction and only variations in that direction are taken into account. In other words, all variables are uniform over a cross-section. They are calculated in the center of each of the m cells. There is one flow solver (TubeFlow) and two structure solvers, one with inertia (TubeStructure) and one without (TubeRingmodel). Settings The following parameters, listed in alphabetical order, need to be provided in the JSON parameter file as setttings of the solver wrapper. parameter type description delta_t double Fixed time step size in flow solver. This parameter is usually specified in a higher Component. input_file string Name of the input file, which must be present in the folder working_directory . The file contains all parameters required for the solver, in JSON-format. interface_input dict Keys are names of ModelParts. The values are (lists of) names of Variables. For a flow solver: \"DISPLACEMENT\" . For a structure solver: [\"PRESSURE\",\"TRACTION\"] . interface_output dict Analogous to interface_input , but for the flow solver output. For a flow solver: [\"PRESSURE\",\"TRACTION\"] . For a structure solver: \"DISPLACEMENT\" . unsteady bool (optional) Indicates if case is steady or unsteady. If omitted, true is assumed. working_directory string Absolute path to the working directory or relative path w.r.t the current directory. delta_t is a necessary parameter, but is usually defined in a higher Component. However, it can also be given directly as parameter of the solver wrapper (e.g. for standalone testing). If it is defined both in higher Component and in the solver wrapper, then the former value is used and a warning is printed. If no intepolation is applied, the names of the ModelParts of both flow and structure solver need to be the same. There is no parameter timestep_start , as currently, restart is not implemented in this solver wrapper. TubeFlow This flow solver calculates the flow inside a 1D straight and flexible tube. The required input is the radial displacement of the tube wall. The resulting output is the pressure on the tube wall. From the radial displacements the area of each cross-section is calculated. The flow is governed by the continuity and momentum equation $$ \\frac{\\partial a}{\\partial t}+\\frac{\\partial av}{\\partial z}=0 $$ $$ \\frac{\\partial av}{\\partial t}+\\frac{\\partial av^2}{\\partial z}+\\frac{1}{\\rho_f}\\left(\\frac{\\partial ap}{\\partial z}-p\\frac{\\partial a}{\\partial z}\\right)=0 $$ with a=\\pi r^2 a=\\pi r^2 the cross-sectional area of the tube and r r the inner radius. Furthermore, t t is the time, v v the velocity along the axis of the tube, p p the pressure and \\rho_f \\rho_f the density of the fluid. Add the start and end of the tube the boundary conditions have to be applied. Discretizing these equations results in a system of linear algebraic equations which can be solved for the pressure and velocity by performing Newton-Raphson iterations. Inside the solver the kinematic pressure is used, which is the pressure divided by the density of the fluid. For more information about the implementation this solver refer to . Solver parameters The following parameters, listed in alphabetical order, need to be specified in a file with name input_file . This file should be located in the working_directory . Care should be taken that the values of d , e , h , l and rhof match the corresponding values of the structural solver. parameter type description axial_offset double (optional) Distance over which tube is displaced axially in the coordinate system. If not provided, the value of this parameter is 0. d double Nominal diameter of the tube. e double Modulus of elasticity of the tube wall. h double Thickness of tube wall. inlet_boundary dict Dictionary containing all information with respect to the inlet boundary condition. l double Length of the tube. m int Number of cells for discretization. The values are calculated in the cell centers. newtonmax double Maximum number of Newton-Raphson iterations for the flow solver calculation. newtontol double Relative tolerance for the Newton-Raphson iterations for the flow solver calculation. outlet_boundary dict Dictionary containing all information with respect to the outlet boundary condition. preference double (optional) Reference pressure and initial pressure. If not provided, the value of this parameter is 0. u0 double (optional) Initial velocity. If omitted, ureference is used. ureference double Reference velocity used for determination of pressure stabilization term. rhof double Density of the fluid. Inlet Boundary This section describes all parameters that need to be specified in the dictionary inlet_boundary , listed in alphabetical order. parameter type description amplitude double Amplitude of the inlet boundary condition. period double Period of the inlet boundary condition. Period of oscillation for a periodic boundary condition, duration for a non-periodic boundary condition. Not used for a fixed value boundary condition (type 4). reference double (optional) Reference value of inlet boundary condition. If not provided, the value of this parameter is the corresponding reference value provided above, i.e. ureference , preference or preference + ureference ^2. type int Type of inlet boundary condition. If 1, a sine wave is used with amplitude, reference and period as specified. If 2, a pulse is used with amplitude as specified and a duration equal to the parameter period. After the pulse the variable is equal to the reference value. If 3, a quadratic sine wave is used with amplitude, reference and period as specified. If 4, a fixed value equal to the sum of the reference value and the amplitude. Used for steady cases. If other, a steady increase of the value at the inlet with slope of amplitude divided by period is used. variable string Variable upon which the inlet boundary condition is definded, either 'pressure', 'velocity' or 'total pressure'. Outlet Boundary This section describes all parameters that need to be specified in the dictionary outlet_boundary , listed in alphabetical order. parameter type description type int Type of outlet boundary condition. If 1, a non-reflecting boundary condition is applied. This type can not be used for a steady calculation. If other, a fixed value equal to the reference pressure is applied. TubeRingModel This structure solver calculates the deformation of the wall of a straight and flexible tube. The tube is regarded as made up of independent rings. The required input is the pressure on the tube wall. The resulting output is the radial displacement. The behaviour of the elastic tube wall is described by a Hookean relation, which results in the following equation $$ a=a_0\\left(\\frac{p_0-2c^2_{MK}}{p_0-2c^2_{MK}}\\right)^2 $$ with a=\\pi r^2 a=\\pi r^2 the cross-sectional area of the tube and r r the inner radius. Furthermore, p p the pressure, p_0 p_0 the reference pressure, \\rho_f \\rho_f the density of the fluid and c^2_{MK} c^2_{MK} the Moens-Korteweg wave speed given by $$ c^2_{MK}=\\sqrt{\\frac{Eh}{2\\rho_f r_0}} $$ Here, E E is the modulus of elasticity, h h the thickness of the tube wall and r_0 r_0 the reference radius. No boundary conditions are required. Inside the solver the kinematic pressure is used, which is the pressure divided by the density of the fluid. For more information about the implementation this solver refer to . Solver parameters The following parameters, listed in alphabetical order, need to be specified in a file with name input_file . This file should be located in the working_directory . Care should be taken that the values of d , e , h , l and rhof match the corresponding values of the flow solver. parameter type description axial_offset double (optional) Distance over which tube is displaced axially in the coordinate system. If not provided, the value of this parameter is 0. d double Nominal diameter of the tube. e double Modulus of elasticity of the tube wall. h double Thickness of tube wall. l double Length of the tube. m int Number of cells for discretization. The values are calculated in the cell centers. preference double (optional) Reference pressure. If not provided, the value of this parameter is 0. rhof double Density of the fluid. TubeStructure This structure solver calculates the deformation of the wall of a straight and flexible tube. In this model inertia is taken into account, but still only radial displacements are considered. The required input is the pressure on the tube wall. The resulting output is the radial displacement. The deformation of the tube in the radial direction is determined by $$ \\rho_s h\\frac{\\partial^2 r}{\\partial t^2}+b_1\\frac{\\partial^4 r}{\\partial z^4}-b_2\\frac{\\partial^2 r}{\\partial z^2}+b_3(r-r_o)=p-p_o $$ with \\rho_s \\rho_s the solid density and h h the thickness of the tube's wall. Further, r r is the inner radius, p p pressure and t t time. The variables r_0 r_0 and p_0 p_0 are a reference radius and pressure, respectively. The tube is considered clamped at both ends. The parameters b_1 b_1 and b_2 b_2 ( b_1, b_2 \\ge 0 b_1, b_2 \\ge 0 ) account for the inner action of the bending and the axial tension in the wall, while the parameter b_3 b_3 accounts for the circumferential stress in the tube wall. For a thin-walled tube that is clamped in the axial direction, they are defined as $$ b_1=\\frac{hE}{1-\\nu^2}\\frac{h^2}{12} \\textrm{, } b_2=\\frac{hE}{1-\\nu^2}\\frac{h^2}{12}\\frac{2\\nu}{r_o^2} \\textrm{ and } b_3=\\frac{hE}{1-\\nu^2}\\frac{1}{r_o^2}+\\frac{hE}{1-\\nu^2}\\frac{h^2}{12}\\frac{1}{r_o^4} $$ with E E the Young's modulus and \\nu \\nu Poisson's coefficient. The second term of b_3 b_3 is considered small compared to the first one because h\\ll r_o h\\ll r_o and is thus neglected. Discretizing these equations results in a system of linear algebraic equations whit a Jacobian that does not depend on the pressure. The system can be solved for the radius in one step. For more information about the implementation this solver refer to . Solver parameters The following parameters, listed in alphabetical order, need to be specified in a file with name input_file .This file should be located in the working_directory . Care should be taken that the values of d , e , h , l and rhof match the corresponding values of the flow solver. parameter type description axial_offset double (optional) Distance over which tube is displaced axially in the coordinate system. If not provided, the value of this parameter is 0. beta double (optional) Newmark parameter \\beta \\beta . Only required when the Newmark-beta time discretization is used. d double Nominal diameter of the tube. e double Modulus of elasticity of the tube wall. h double Thickness of tube wall. gamma double (optional) Newmark parameter \\gamma \\gamma . Only required when the Newmark-beta time discretization is used. l double Length of the tube. m int Number of cells for discretization. The values are calculated in the cell centers. nu double Poisson's ratio. preference double (optional) Reference pressure. If not provided, the value of this parameter is 0. rhof double Density of the fluid. rhos double Density of the tube wall. time_disretization string (optional) Either 'Newmark' or 'backward Euler'. If not provided, backward Euler is used. The equations are discretized in time with the Newmark-beta method or backward Euler method. In the former case, two Newmark parameters \\beta \\beta and \\gamma \\gamma are required, which result in an un-conditionally stable integration scheme if $$ \\gamma\\geq\\frac{1}{2} \\textrm{ and } \\beta\\geq\\frac{1}{4}\\left(\\frac{1}{2}+\\gamma\\right)^2. $$ Typical values are \\gamma \\gamma equal to 1/2 and \\beta \\beta equal to 1/4. A different time discretization for flow and structure can lead to difficulties for strongly coupled problems, especially looking at the resulting pressure distributions. As most flow solvers are discretized using the backward Euler method, it is advised to chose the same method for the structure solver.","title":"SolverWrapperPython"},{"location":"python/#solverwrapperpython","text":"This is the documentation for all Python SolverWrappers. Currently only solvers exist for the 1D calculation of a straight flexible tube.","title":"SolverWrapperPython"},{"location":"python/#tube","text":"There are three tube solvers for a straight tube with circular cross-section. The axial direction is along the z-axis. All of them are 1D solvers. This means the tube is divided in m intervals in the axial z-direction and only variations in that direction are taken into account. In other words, all variables are uniform over a cross-section. They are calculated in the center of each of the m cells. There is one flow solver (TubeFlow) and two structure solvers, one with inertia (TubeStructure) and one without (TubeRingmodel).","title":"Tube"},{"location":"python/#settings","text":"The following parameters, listed in alphabetical order, need to be provided in the JSON parameter file as setttings of the solver wrapper. parameter type description delta_t double Fixed time step size in flow solver. This parameter is usually specified in a higher Component. input_file string Name of the input file, which must be present in the folder working_directory . The file contains all parameters required for the solver, in JSON-format. interface_input dict Keys are names of ModelParts. The values are (lists of) names of Variables. For a flow solver: \"DISPLACEMENT\" . For a structure solver: [\"PRESSURE\",\"TRACTION\"] . interface_output dict Analogous to interface_input , but for the flow solver output. For a flow solver: [\"PRESSURE\",\"TRACTION\"] . For a structure solver: \"DISPLACEMENT\" . unsteady bool (optional) Indicates if case is steady or unsteady. If omitted, true is assumed. working_directory string Absolute path to the working directory or relative path w.r.t the current directory. delta_t is a necessary parameter, but is usually defined in a higher Component. However, it can also be given directly as parameter of the solver wrapper (e.g. for standalone testing). If it is defined both in higher Component and in the solver wrapper, then the former value is used and a warning is printed. If no intepolation is applied, the names of the ModelParts of both flow and structure solver need to be the same. There is no parameter timestep_start , as currently, restart is not implemented in this solver wrapper.","title":"Settings"},{"location":"python/#tubeflow","text":"This flow solver calculates the flow inside a 1D straight and flexible tube. The required input is the radial displacement of the tube wall. The resulting output is the pressure on the tube wall. From the radial displacements the area of each cross-section is calculated. The flow is governed by the continuity and momentum equation $$ \\frac{\\partial a}{\\partial t}+\\frac{\\partial av}{\\partial z}=0 $$ $$ \\frac{\\partial av}{\\partial t}+\\frac{\\partial av^2}{\\partial z}+\\frac{1}{\\rho_f}\\left(\\frac{\\partial ap}{\\partial z}-p\\frac{\\partial a}{\\partial z}\\right)=0 $$ with a=\\pi r^2 a=\\pi r^2 the cross-sectional area of the tube and r r the inner radius. Furthermore, t t is the time, v v the velocity along the axis of the tube, p p the pressure and \\rho_f \\rho_f the density of the fluid. Add the start and end of the tube the boundary conditions have to be applied. Discretizing these equations results in a system of linear algebraic equations which can be solved for the pressure and velocity by performing Newton-Raphson iterations. Inside the solver the kinematic pressure is used, which is the pressure divided by the density of the fluid. For more information about the implementation this solver refer to .","title":"TubeFlow"},{"location":"python/#solver-parameters","text":"The following parameters, listed in alphabetical order, need to be specified in a file with name input_file . This file should be located in the working_directory . Care should be taken that the values of d , e , h , l and rhof match the corresponding values of the structural solver. parameter type description axial_offset double (optional) Distance over which tube is displaced axially in the coordinate system. If not provided, the value of this parameter is 0. d double Nominal diameter of the tube. e double Modulus of elasticity of the tube wall. h double Thickness of tube wall. inlet_boundary dict Dictionary containing all information with respect to the inlet boundary condition. l double Length of the tube. m int Number of cells for discretization. The values are calculated in the cell centers. newtonmax double Maximum number of Newton-Raphson iterations for the flow solver calculation. newtontol double Relative tolerance for the Newton-Raphson iterations for the flow solver calculation. outlet_boundary dict Dictionary containing all information with respect to the outlet boundary condition. preference double (optional) Reference pressure and initial pressure. If not provided, the value of this parameter is 0. u0 double (optional) Initial velocity. If omitted, ureference is used. ureference double Reference velocity used for determination of pressure stabilization term. rhof double Density of the fluid.","title":"Solver parameters"},{"location":"python/#inlet-boundary","text":"This section describes all parameters that need to be specified in the dictionary inlet_boundary , listed in alphabetical order. parameter type description amplitude double Amplitude of the inlet boundary condition. period double Period of the inlet boundary condition. Period of oscillation for a periodic boundary condition, duration for a non-periodic boundary condition. Not used for a fixed value boundary condition (type 4). reference double (optional) Reference value of inlet boundary condition. If not provided, the value of this parameter is the corresponding reference value provided above, i.e. ureference , preference or preference + ureference ^2. type int Type of inlet boundary condition. If 1, a sine wave is used with amplitude, reference and period as specified. If 2, a pulse is used with amplitude as specified and a duration equal to the parameter period. After the pulse the variable is equal to the reference value. If 3, a quadratic sine wave is used with amplitude, reference and period as specified. If 4, a fixed value equal to the sum of the reference value and the amplitude. Used for steady cases. If other, a steady increase of the value at the inlet with slope of amplitude divided by period is used. variable string Variable upon which the inlet boundary condition is definded, either 'pressure', 'velocity' or 'total pressure'.","title":"Inlet Boundary"},{"location":"python/#outlet-boundary","text":"This section describes all parameters that need to be specified in the dictionary outlet_boundary , listed in alphabetical order. parameter type description type int Type of outlet boundary condition. If 1, a non-reflecting boundary condition is applied. This type can not be used for a steady calculation. If other, a fixed value equal to the reference pressure is applied.","title":"Outlet Boundary"},{"location":"python/#tuberingmodel","text":"This structure solver calculates the deformation of the wall of a straight and flexible tube. The tube is regarded as made up of independent rings. The required input is the pressure on the tube wall. The resulting output is the radial displacement. The behaviour of the elastic tube wall is described by a Hookean relation, which results in the following equation $$ a=a_0\\left(\\frac{p_0-2c^2_{MK}}{p_0-2c^2_{MK}}\\right)^2 $$ with a=\\pi r^2 a=\\pi r^2 the cross-sectional area of the tube and r r the inner radius. Furthermore, p p the pressure, p_0 p_0 the reference pressure, \\rho_f \\rho_f the density of the fluid and c^2_{MK} c^2_{MK} the Moens-Korteweg wave speed given by $$ c^2_{MK}=\\sqrt{\\frac{Eh}{2\\rho_f r_0}} $$ Here, E E is the modulus of elasticity, h h the thickness of the tube wall and r_0 r_0 the reference radius. No boundary conditions are required. Inside the solver the kinematic pressure is used, which is the pressure divided by the density of the fluid. For more information about the implementation this solver refer to .","title":"TubeRingModel"},{"location":"python/#solver-parameters_1","text":"The following parameters, listed in alphabetical order, need to be specified in a file with name input_file . This file should be located in the working_directory . Care should be taken that the values of d , e , h , l and rhof match the corresponding values of the flow solver. parameter type description axial_offset double (optional) Distance over which tube is displaced axially in the coordinate system. If not provided, the value of this parameter is 0. d double Nominal diameter of the tube. e double Modulus of elasticity of the tube wall. h double Thickness of tube wall. l double Length of the tube. m int Number of cells for discretization. The values are calculated in the cell centers. preference double (optional) Reference pressure. If not provided, the value of this parameter is 0. rhof double Density of the fluid.","title":"Solver parameters"},{"location":"python/#tubestructure","text":"This structure solver calculates the deformation of the wall of a straight and flexible tube. In this model inertia is taken into account, but still only radial displacements are considered. The required input is the pressure on the tube wall. The resulting output is the radial displacement. The deformation of the tube in the radial direction is determined by $$ \\rho_s h\\frac{\\partial^2 r}{\\partial t^2}+b_1\\frac{\\partial^4 r}{\\partial z^4}-b_2\\frac{\\partial^2 r}{\\partial z^2}+b_3(r-r_o)=p-p_o $$ with \\rho_s \\rho_s the solid density and h h the thickness of the tube's wall. Further, r r is the inner radius, p p pressure and t t time. The variables r_0 r_0 and p_0 p_0 are a reference radius and pressure, respectively. The tube is considered clamped at both ends. The parameters b_1 b_1 and b_2 b_2 ( b_1, b_2 \\ge 0 b_1, b_2 \\ge 0 ) account for the inner action of the bending and the axial tension in the wall, while the parameter b_3 b_3 accounts for the circumferential stress in the tube wall. For a thin-walled tube that is clamped in the axial direction, they are defined as $$ b_1=\\frac{hE}{1-\\nu^2}\\frac{h^2}{12} \\textrm{, } b_2=\\frac{hE}{1-\\nu^2}\\frac{h^2}{12}\\frac{2\\nu}{r_o^2} \\textrm{ and } b_3=\\frac{hE}{1-\\nu^2}\\frac{1}{r_o^2}+\\frac{hE}{1-\\nu^2}\\frac{h^2}{12}\\frac{1}{r_o^4} $$ with E E the Young's modulus and \\nu \\nu Poisson's coefficient. The second term of b_3 b_3 is considered small compared to the first one because h\\ll r_o h\\ll r_o and is thus neglected. Discretizing these equations results in a system of linear algebraic equations whit a Jacobian that does not depend on the pressure. The system can be solved for the radius in one step. For more information about the implementation this solver refer to .","title":"TubeStructure"},{"location":"python/#solver-parameters_2","text":"The following parameters, listed in alphabetical order, need to be specified in a file with name input_file .This file should be located in the working_directory . Care should be taken that the values of d , e , h , l and rhof match the corresponding values of the flow solver. parameter type description axial_offset double (optional) Distance over which tube is displaced axially in the coordinate system. If not provided, the value of this parameter is 0. beta double (optional) Newmark parameter \\beta \\beta . Only required when the Newmark-beta time discretization is used. d double Nominal diameter of the tube. e double Modulus of elasticity of the tube wall. h double Thickness of tube wall. gamma double (optional) Newmark parameter \\gamma \\gamma . Only required when the Newmark-beta time discretization is used. l double Length of the tube. m int Number of cells for discretization. The values are calculated in the cell centers. nu double Poisson's ratio. preference double (optional) Reference pressure. If not provided, the value of this parameter is 0. rhof double Density of the fluid. rhos double Density of the tube wall. time_disretization string (optional) Either 'Newmark' or 'backward Euler'. If not provided, backward Euler is used. The equations are discretized in time with the Newmark-beta method or backward Euler method. In the former case, two Newmark parameters \\beta \\beta and \\gamma \\gamma are required, which result in an un-conditionally stable integration scheme if $$ \\gamma\\geq\\frac{1}{2} \\textrm{ and } \\beta\\geq\\frac{1}{4}\\left(\\frac{1}{2}+\\gamma\\right)^2. $$ Typical values are \\gamma \\gamma equal to 1/2 and \\beta \\beta equal to 1/4. A different time discretization for flow and structure can lead to difficulties for strongly coupled problems, especially looking at the resulting pressure distributions. As most flow solvers are discretized using the backward Euler method, it is advised to chose the same method for the structure solver.","title":"Solver parameters"},{"location":"tests/","text":"Tests Running unittests The unittests in CoCoNuT uses unittest module available in python. To run all the tests you have to first go to tests/ directory and run the following command in the terminal: python -m unittest discover -bv The discover keyword finds all the unittests writen in the files named test_<some name> . It will recursively find all the test files with this pattern for all the folders containing __init__.py file. Further documentation on unittest discover can be found here . By default, all the unitests except the ones for the solver wrappers will be run. Including unittests for solver-wrappers Solver wrapper provides an interface to an external solver that is coupled while performing coupled simulation. Since this depends on the availability of the solver in a system, the unittests for the solver wrappers are made optional. Including the unitests for solver wrappers in the list of unittests that need to be run involves following steps: Load the corresponding solvers. Import the unittest classes for the solver wrappers in the python file, tests/solver_wrappers/__init__.py . Add the unittest classes for the solver wrappers in the list called tests_cases in the python file, tests/solver_wrappers/__init__.py . After following the above steps, if you now run all the tests using the command given in the previous section from the directory tests/ , unitests for the added solver wrappers will be run along with all the default ones.","title":"Tests"},{"location":"tests/#tests","text":"","title":"Tests"},{"location":"tests/#running-unittests","text":"The unittests in CoCoNuT uses unittest module available in python. To run all the tests you have to first go to tests/ directory and run the following command in the terminal: python -m unittest discover -bv The discover keyword finds all the unittests writen in the files named test_<some name> . It will recursively find all the test files with this pattern for all the folders containing __init__.py file. Further documentation on unittest discover can be found here . By default, all the unitests except the ones for the solver wrappers will be run.","title":"Running unittests"},{"location":"tests/#including-unittests-for-solver-wrappers","text":"Solver wrapper provides an interface to an external solver that is coupled while performing coupled simulation. Since this depends on the availability of the solver in a system, the unittests for the solver wrappers are made optional. Including the unitests for solver wrappers in the list of unittests that need to be run involves following steps: Load the corresponding solvers. Import the unittest classes for the solver wrappers in the python file, tests/solver_wrappers/__init__.py . Add the unittest classes for the solver wrappers in the list called tests_cases in the python file, tests/solver_wrappers/__init__.py . After following the above steps, if you now run all the tests using the command given in the previous section from the directory tests/ , unitests for the added solver wrappers will be run along with all the default ones.","title":"Including unittests for solver-wrappers"},{"location":"tube_fluent2d_abaqus2d/","text":"Tube case with Fluent2D and Abaqus2D This example calculates the flow inside and the deformation and stresses of a straight flexible tube, where a pressure pulse is applied at the inlet. This done by using Fluent and Abaqus, both on an axisymmetric case. Coupling algorithm The coupling technique used is the interface quasi-Newton algorithm with an approximation for the inverse of the Jacobian from a least-squares model (IQNI-LS). Predictor The initial guess in every time step is done using the linear predictor. Convergence criterion Two convergence criteria have been specified: The number of iterations in every time step is larger than 10. The residual norm on the displacement is a factor 10^{-4} 10^{-4} lower than the initial value. When either criterion is satisfied the simulation stops. Solvers The flow solver is Fluent, used to solve an axisymmetric representation of the tube, with 100 cells on the fluid-structure interface. When setting up the case, the mesh is build based on the file mesh.jou using Gambit. The displacements are applied in the nodes, of which there are 101. In contrast, the loads (pressure and traction) are calculated in the cell centers, of which there are 100. The axial direction is along the x-axis, the radial direction along the y-axis. The structure solver is Abaqus, used to solve an axisymmetric representation of the tube, with 50 elements on the fluid-structure interface. The Abaqus case is not build when setting up the case, but is provided as the file Base.inp . The Abaqus element type used is CAX8RH. These are continuum elements for axisymmetric calculations, for stress and displacement without twist. They are: 8-node biquadratic, reduced integration, hybrid with linear pressure. See Abaqus documentaion for more information. The loads are applied on the faces in three points per element, which means on 150 load points in total. The displacement is calculated in the nodes. There are 101 nodes on the fluid-structure interface. The axial direction is along the y-axis, the radial direction along the x-axis. The difference in reference frames and number of cells on the fluid-structure interface requires the use of mappers. In the structure solver wrapper, a permutation mapper is introduced to match the coordinate frames, flipping the x- and y-axis of the input. Thereafter, a linear interpolation mapper is used to interpolate in the x- and y-direction from the 100 cell centers of Fluent to the 150 load points in Abaqus. For the output the same is done in the opposite order: first interpolating and then flipping the axes.","title":"Fluent 2D - Abaqus 2D"},{"location":"tube_fluent2d_abaqus2d/#tube-case-with-fluent2d-and-abaqus2d","text":"This example calculates the flow inside and the deformation and stresses of a straight flexible tube, where a pressure pulse is applied at the inlet. This done by using Fluent and Abaqus, both on an axisymmetric case.","title":"Tube case with Fluent2D and Abaqus2D"},{"location":"tube_fluent2d_abaqus2d/#coupling-algorithm","text":"The coupling technique used is the interface quasi-Newton algorithm with an approximation for the inverse of the Jacobian from a least-squares model (IQNI-LS).","title":"Coupling algorithm"},{"location":"tube_fluent2d_abaqus2d/#predictor","text":"The initial guess in every time step is done using the linear predictor.","title":"Predictor"},{"location":"tube_fluent2d_abaqus2d/#convergence-criterion","text":"Two convergence criteria have been specified: The number of iterations in every time step is larger than 10. The residual norm on the displacement is a factor 10^{-4} 10^{-4} lower than the initial value. When either criterion is satisfied the simulation stops.","title":"Convergence criterion"},{"location":"tube_fluent2d_abaqus2d/#solvers","text":"The flow solver is Fluent, used to solve an axisymmetric representation of the tube, with 100 cells on the fluid-structure interface. When setting up the case, the mesh is build based on the file mesh.jou using Gambit. The displacements are applied in the nodes, of which there are 101. In contrast, the loads (pressure and traction) are calculated in the cell centers, of which there are 100. The axial direction is along the x-axis, the radial direction along the y-axis. The structure solver is Abaqus, used to solve an axisymmetric representation of the tube, with 50 elements on the fluid-structure interface. The Abaqus case is not build when setting up the case, but is provided as the file Base.inp . The Abaqus element type used is CAX8RH. These are continuum elements for axisymmetric calculations, for stress and displacement without twist. They are: 8-node biquadratic, reduced integration, hybrid with linear pressure. See Abaqus documentaion for more information. The loads are applied on the faces in three points per element, which means on 150 load points in total. The displacement is calculated in the nodes. There are 101 nodes on the fluid-structure interface. The axial direction is along the y-axis, the radial direction along the x-axis. The difference in reference frames and number of cells on the fluid-structure interface requires the use of mappers. In the structure solver wrapper, a permutation mapper is introduced to match the coordinate frames, flipping the x- and y-axis of the input. Thereafter, a linear interpolation mapper is used to interpolate in the x- and y-direction from the 100 cell centers of Fluent to the 150 load points in Abaqus. For the output the same is done in the opposite order: first interpolating and then flipping the axes.","title":"Solvers"},{"location":"tube_fluent2d_abaqus2d_steady/","text":"Tube case with Fluent2D and Abaqus2D - Steady This example calculates the flow inside and the deformation and stresses of a straight flexible tube, when a steady pressure difference is applied over the tube. This done by using Fluent and Abaqus, both on an axisymmetric case. The test example is similar in setup to 'tube_fluent2d_abaqus2d'. The only difference is that a steady problem is simulated. Here the most important differences and peculiarities of a steady case are highlighted. General settings Although the caculation is steady, a delta_t is still required. Its value is abritrary and usualy 1.0 is used. timestep_start is required as well and is normally equal to 0. Coupling algorithm The coupling technique used is the interface quasi-Newton algorithm with an approximation for the inverse of the Jacobian from a least-squares model (IQNI-LS). The paramter q is not used no as there is only one time step. Note that in a steady caculation, the models ls (IQN-ILS) and mv (IQN-MVJ) are identical. Predictor A predictor is still required, but not used as only one time step is calculated. Solvers Of course the suplied case files in both Fluent and Abaqus also need to be steady. In Abaqus this can be done using a Static step, typically with subcycling and and a linearly ramped load. The parameters subcycling and ramp are set on true in the json-file. As such Abaqus performs subiterations in each coupling iterations in which the load is increased linearly over the step. The parameters minInc , initialInc , maxNumInc and maxInc are used to determine its behaviour. The ramping does not occur in Abaqus itself as, amplitude references are ignored for nonuniform loads given by user subroutine DLOAD in an Abaqus/Standard analysis. Instead, the ramping is implemented in the DLOAD subroutine itself. For the first iteration of the first time step an initial load is required which is set to zero in the Abaqus wrapper.","title":"Fluent 2D - Abaqus 2D - Steady"},{"location":"tube_fluent2d_abaqus2d_steady/#tube-case-with-fluent2d-and-abaqus2d-steady","text":"This example calculates the flow inside and the deformation and stresses of a straight flexible tube, when a steady pressure difference is applied over the tube. This done by using Fluent and Abaqus, both on an axisymmetric case. The test example is similar in setup to 'tube_fluent2d_abaqus2d'. The only difference is that a steady problem is simulated. Here the most important differences and peculiarities of a steady case are highlighted.","title":"Tube case with Fluent2D and Abaqus2D - Steady"},{"location":"tube_fluent2d_abaqus2d_steady/#general-settings","text":"Although the caculation is steady, a delta_t is still required. Its value is abritrary and usualy 1.0 is used. timestep_start is required as well and is normally equal to 0.","title":"General settings"},{"location":"tube_fluent2d_abaqus2d_steady/#coupling-algorithm","text":"The coupling technique used is the interface quasi-Newton algorithm with an approximation for the inverse of the Jacobian from a least-squares model (IQNI-LS). The paramter q is not used no as there is only one time step. Note that in a steady caculation, the models ls (IQN-ILS) and mv (IQN-MVJ) are identical.","title":"Coupling algorithm"},{"location":"tube_fluent2d_abaqus2d_steady/#predictor","text":"A predictor is still required, but not used as only one time step is calculated.","title":"Predictor"},{"location":"tube_fluent2d_abaqus2d_steady/#solvers","text":"Of course the suplied case files in both Fluent and Abaqus also need to be steady. In Abaqus this can be done using a Static step, typically with subcycling and and a linearly ramped load. The parameters subcycling and ramp are set on true in the json-file. As such Abaqus performs subiterations in each coupling iterations in which the load is increased linearly over the step. The parameters minInc , initialInc , maxNumInc and maxInc are used to determine its behaviour. The ramping does not occur in Abaqus itself as, amplitude references are ignored for nonuniform loads given by user subroutine DLOAD in an Abaqus/Standard analysis. Instead, the ramping is implemented in the DLOAD subroutine itself. For the first iteration of the first time step an initial load is required which is set to zero in the Abaqus wrapper.","title":"Solvers"},{"location":"tube_fluent2d_tube_structure/","text":"Tube case with Fluent2D and TubeStructure This example calculates the flow inside and the deformation and stresses of a straight flexible tube, where a pressure pulse is applied at the inlet. This done by using Fluent (axisymmetric) and the Python solver TubeStructure. Coupling algorithm The coupling technique used is the interface quasi-Newton algorithm with an approximation for the inverse of the Jacobian from a least-squares model (IQNI-LS). Predictor The initial guess in every time step is done using the linear predictor. Convergence criterion Two convergence criteria have been specified: The number of iterations in every time step is larger than 15. The residual norm on the displacement is a factor 10^{-6} 10^{-6} lower than the initial value. When either criterion is satisfied the simulation stops. Solvers The flow solver is Fluent, used to solve an axisymmetric representation of the tube, with 100 cells on the fluid-structure interface. When setting up the case, the mesh is build based on the file mesh.jou using Gambit. The displacements are applied in the nodes, of which there are 101. In contrast, the loads (pressure and traction) are calculated in the cell centers, of which there are 100. The axial direction is along the x-axis, the radial direction along the y-axis. The structure solver is the Python solver TubeStructure, which implements a 1D model of the tube wall, with 100 elements on the fluid-structure interface. The parameters for this model are specified in the setup folder by the file solver_parameter.json . The loads, in fact only pressure for this 1D case, are applied on the cell centers. The displacements are calculated in the cell centers as well. Only the radial displacement is different from zero. The axial direction is along the z-axis, the radial direction along the y-axis. Whereas for Fluent the origin is situated axially in the center of the tube, for TubeStructure the origin is located at the start. Therefore, the parameter axial_offset is used in its solver_parameter.json file to correct for this. The difference in reference frames and number of cells on the fluid-structure interface requires the use of mappers. In the structure solver wrapper, a permutation mapper is introduced to match the coordinate frames, flipping the x- and z-axis of the input. Thereafter, a linear interpolation mapper is used to interpolate in the y- and z-direction from the 100 cell centers of Fluent to the 100 cell centers of TubeStructure. For the output the same is done in the opposite order: first interpolating and then flipping the axes.","title":"Fluent 2D - Python TubeStructure"},{"location":"tube_fluent2d_tube_structure/#tube-case-with-fluent2d-and-tubestructure","text":"This example calculates the flow inside and the deformation and stresses of a straight flexible tube, where a pressure pulse is applied at the inlet. This done by using Fluent (axisymmetric) and the Python solver TubeStructure.","title":"Tube case with Fluent2D and TubeStructure"},{"location":"tube_fluent2d_tube_structure/#coupling-algorithm","text":"The coupling technique used is the interface quasi-Newton algorithm with an approximation for the inverse of the Jacobian from a least-squares model (IQNI-LS).","title":"Coupling algorithm"},{"location":"tube_fluent2d_tube_structure/#predictor","text":"The initial guess in every time step is done using the linear predictor.","title":"Predictor"},{"location":"tube_fluent2d_tube_structure/#convergence-criterion","text":"Two convergence criteria have been specified: The number of iterations in every time step is larger than 15. The residual norm on the displacement is a factor 10^{-6} 10^{-6} lower than the initial value. When either criterion is satisfied the simulation stops.","title":"Convergence criterion"},{"location":"tube_fluent2d_tube_structure/#solvers","text":"The flow solver is Fluent, used to solve an axisymmetric representation of the tube, with 100 cells on the fluid-structure interface. When setting up the case, the mesh is build based on the file mesh.jou using Gambit. The displacements are applied in the nodes, of which there are 101. In contrast, the loads (pressure and traction) are calculated in the cell centers, of which there are 100. The axial direction is along the x-axis, the radial direction along the y-axis. The structure solver is the Python solver TubeStructure, which implements a 1D model of the tube wall, with 100 elements on the fluid-structure interface. The parameters for this model are specified in the setup folder by the file solver_parameter.json . The loads, in fact only pressure for this 1D case, are applied on the cell centers. The displacements are calculated in the cell centers as well. Only the radial displacement is different from zero. The axial direction is along the z-axis, the radial direction along the y-axis. Whereas for Fluent the origin is situated axially in the center of the tube, for TubeStructure the origin is located at the start. Therefore, the parameter axial_offset is used in its solver_parameter.json file to correct for this. The difference in reference frames and number of cells on the fluid-structure interface requires the use of mappers. In the structure solver wrapper, a permutation mapper is introduced to match the coordinate frames, flipping the x- and z-axis of the input. Thereafter, a linear interpolation mapper is used to interpolate in the y- and z-direction from the 100 cell centers of Fluent to the 100 cell centers of TubeStructure. For the output the same is done in the opposite order: first interpolating and then flipping the axes.","title":"Solvers"},{"location":"tube_fluent3d_abaqus2d/","text":"Tube case with Fluent3D and Abaqus2D This example calculates the flow inside and the deformation and stresses of a straight flexible tube, where a pressure pulse is applied at the inlet. This done by using Fluent (3D case) and Abaqus (axisymmetric case). Coupling algorithm The coupling technique used is the interface quasi-Newton algorithm with an approximation for the inverse of the Jacobian from a least-squares model (IQNI-LS). Predictor The initial guess in every time step is done using the linear predictor. Convergence criterion Two convergence criteria have been specified: The number of iterations in every time step is larger than 20. The residual norm on the displacement is a factor 10^{-3} 10^{-3} lower than the initial value. When either criterion is satisfied the simulation stops. Solvers The flow solver is Fluent, used to solve a fully 3D tube, with 48 cells on the fluid-structure interface in the length-wise direction and 8 in the circumferential direction. When setting up the case, the mesh is build based on the file mesh.jou using Gambit. The displacements are applied in the nodes. In contrast, the loads (pressure and traction) are calculated in the cell centers. The axial direction is along the x-axis, the radial direction along the y-axis. The structure solver is Abaqus, used to solve an axisymmetric representation of the tube, with 50 elements on the fluid-structure interface. The Abaqus case is not build when setting up the case, but is provided as the file Base.inp . The Abaqus element type used is CAX8RH. These are continuum elements for axisymmetric calculations, for stress and displacement without twist. They are: 8-node biquadratic, reduced integration, hybrid with linear pressure. See Abaqus documentaion for more information. The loads are applied on the faces in three points per element, which means on 150 load points in total. The displacement is calculated in the nodes. There are 101 nodes on the fluid-structure interface. The axial direction is along the y-axis, the radial direction along the x-axis. The difference in reference frames and number of cells on the fluid-structure interface, but also the difference in dimensions require the use of mappers, In the structure solver wrapper, a permutation mapper is introduced to match the coordinate frames, flipping the x- and y-axis of the input. Thereafter, a radial basis mapper is used to interpolate in the x-, y- and z-direction from the loads coming from Fluent to a temporary 3D interface corresponding to Abaqus. Finally a mapper is added to go from 3D to 2D. For the output the same is done in the opposite order: first going from 2D to 3D, then interpolating and finally flipping the axes.","title":"Fluent 3D - Abaqus 2D"},{"location":"tube_fluent3d_abaqus2d/#tube-case-with-fluent3d-and-abaqus2d","text":"This example calculates the flow inside and the deformation and stresses of a straight flexible tube, where a pressure pulse is applied at the inlet. This done by using Fluent (3D case) and Abaqus (axisymmetric case).","title":"Tube case with Fluent3D and Abaqus2D"},{"location":"tube_fluent3d_abaqus2d/#coupling-algorithm","text":"The coupling technique used is the interface quasi-Newton algorithm with an approximation for the inverse of the Jacobian from a least-squares model (IQNI-LS).","title":"Coupling algorithm"},{"location":"tube_fluent3d_abaqus2d/#predictor","text":"The initial guess in every time step is done using the linear predictor.","title":"Predictor"},{"location":"tube_fluent3d_abaqus2d/#convergence-criterion","text":"Two convergence criteria have been specified: The number of iterations in every time step is larger than 20. The residual norm on the displacement is a factor 10^{-3} 10^{-3} lower than the initial value. When either criterion is satisfied the simulation stops.","title":"Convergence criterion"},{"location":"tube_fluent3d_abaqus2d/#solvers","text":"The flow solver is Fluent, used to solve a fully 3D tube, with 48 cells on the fluid-structure interface in the length-wise direction and 8 in the circumferential direction. When setting up the case, the mesh is build based on the file mesh.jou using Gambit. The displacements are applied in the nodes. In contrast, the loads (pressure and traction) are calculated in the cell centers. The axial direction is along the x-axis, the radial direction along the y-axis. The structure solver is Abaqus, used to solve an axisymmetric representation of the tube, with 50 elements on the fluid-structure interface. The Abaqus case is not build when setting up the case, but is provided as the file Base.inp . The Abaqus element type used is CAX8RH. These are continuum elements for axisymmetric calculations, for stress and displacement without twist. They are: 8-node biquadratic, reduced integration, hybrid with linear pressure. See Abaqus documentaion for more information. The loads are applied on the faces in three points per element, which means on 150 load points in total. The displacement is calculated in the nodes. There are 101 nodes on the fluid-structure interface. The axial direction is along the y-axis, the radial direction along the x-axis. The difference in reference frames and number of cells on the fluid-structure interface, but also the difference in dimensions require the use of mappers, In the structure solver wrapper, a permutation mapper is introduced to match the coordinate frames, flipping the x- and y-axis of the input. Thereafter, a radial basis mapper is used to interpolate in the x-, y- and z-direction from the loads coming from Fluent to a temporary 3D interface corresponding to Abaqus. Finally a mapper is added to go from 3D to 2D. For the output the same is done in the opposite order: first going from 2D to 3D, then interpolating and finally flipping the axes.","title":"Solvers"},{"location":"tube_fluent3d_abaqus3d/","text":"Tube case with Fluent3D and Abaqus3D This example calculates the flow inside and the deformation and stresses of a straight flexible tube, where a pressure pulse is applied at the inlet. This done by using Fluent and Abaqus, both with a fully 3D case. Coupling algorithm The coupling technique used is the interface quasi-Newton algorithm with an approximation for the inverse of the Jacobian from a least-squares model (IQNI-LS). Predictor The initial guess in every time step is done using the linear predictor. Convergence criterion Two convergence criteria have been specified: The number of iterations in every time step is larger than 20. The residual norm on the displacement is a factor 10^{-3} 10^{-3} lower than the initial value. When either criterion is satisfied the simulation stops. Solvers The flow solver is Fluent, used to solve a fully 3D tube, with 48 cells on the fluid-structure interface in the length-wise direction and 8 in the circumferential direction. When setting up the case, the mesh is build based on the file mesh.jou using Gambit. The displacements are applied in the nodes. In contrast, the loads (pressure and traction) are calculated in the cell centers. The axial direction is along the x-axis, the radial direction along the y-axis. The structure solver is Abaqus, used to solve a fully 3D tube, with 12 elements on the fluid-structure interface in the length-wise direction and 8 in the circumferential direction. The Abaqus case is not build when setting up the case, but is provided as the file Base.inp . The Abaqus element type used is S8R. These are 8-node shell elements. The R refers to reduced integration. See Abaqus documentation for more information. The loads are applied on the faces in 9 points per element, which means on 864 load points in total. The displacement is calculated in the nodes. There are 304 nodes on the fluid-structure interface. The axial direction is along the x-axis, the radial direction along the y-axis. The coordinate frames of both solvers are the same so there is no need for a permutation mapper. In contrast, the difference of the points where loads and displacements are applied or calculated, require the use of interpolation mappers. Therefore, a radial basis mapper is introduced in the structure solver to interpolate in the x-, y- and z-direction.","title":"Fluent 3D - Abaqus 3D"},{"location":"tube_fluent3d_abaqus3d/#tube-case-with-fluent3d-and-abaqus3d","text":"This example calculates the flow inside and the deformation and stresses of a straight flexible tube, where a pressure pulse is applied at the inlet. This done by using Fluent and Abaqus, both with a fully 3D case.","title":"Tube case with Fluent3D and Abaqus3D"},{"location":"tube_fluent3d_abaqus3d/#coupling-algorithm","text":"The coupling technique used is the interface quasi-Newton algorithm with an approximation for the inverse of the Jacobian from a least-squares model (IQNI-LS).","title":"Coupling algorithm"},{"location":"tube_fluent3d_abaqus3d/#predictor","text":"The initial guess in every time step is done using the linear predictor.","title":"Predictor"},{"location":"tube_fluent3d_abaqus3d/#convergence-criterion","text":"Two convergence criteria have been specified: The number of iterations in every time step is larger than 20. The residual norm on the displacement is a factor 10^{-3} 10^{-3} lower than the initial value. When either criterion is satisfied the simulation stops.","title":"Convergence criterion"},{"location":"tube_fluent3d_abaqus3d/#solvers","text":"The flow solver is Fluent, used to solve a fully 3D tube, with 48 cells on the fluid-structure interface in the length-wise direction and 8 in the circumferential direction. When setting up the case, the mesh is build based on the file mesh.jou using Gambit. The displacements are applied in the nodes. In contrast, the loads (pressure and traction) are calculated in the cell centers. The axial direction is along the x-axis, the radial direction along the y-axis. The structure solver is Abaqus, used to solve a fully 3D tube, with 12 elements on the fluid-structure interface in the length-wise direction and 8 in the circumferential direction. The Abaqus case is not build when setting up the case, but is provided as the file Base.inp . The Abaqus element type used is S8R. These are 8-node shell elements. The R refers to reduced integration. See Abaqus documentation for more information. The loads are applied on the faces in 9 points per element, which means on 864 load points in total. The displacement is calculated in the nodes. There are 304 nodes on the fluid-structure interface. The axial direction is along the x-axis, the radial direction along the y-axis. The coordinate frames of both solvers are the same so there is no need for a permutation mapper. In contrast, the difference of the points where loads and displacements are applied or calculated, require the use of interpolation mappers. Therefore, a radial basis mapper is introduced in the structure solver to interpolate in the x-, y- and z-direction.","title":"Solvers"},{"location":"tube_fluent3d_kratos_structure3d/","text":"Tube case with Fluent3D and Kratos3D This example calculates the flow inside and the deformation and stresses of a straight flexible tube, where a pressure pulse is applied at the inlet. This done by using Fluent and StructuralMechanicsApplication of Kratos, both with a fully 3D case. Coupling algorithm The coupling technique used is the interface quasi-Newton algorithm with an approximation for the inverse of the Jacobian from a least-squares model (IQNI-LS). Predictor The initial guess in every time step is done using the linear predictor. Convergence criterion Two convergence criteria have been specified: - The number of iterations in every time step is larger than 20. - The residual norm on the displacement is a factor 10^{-3} 10^{-3} lower than the initial value. When either criterion is satisfied the simulation stops. Solvers The flow solver is Fluent, used to solve a fully 3D tube, with 48 cells on the fluid-structure interface in the length-wise direction and 8 in the circumferential direction. When setting up the case, the mesh is build based on the file mesh.jou using Gambit. The displacements are applied in the nodes. In contrast, the loads (pressure and traction) are calculated in the cell centers. The axial direction is along the x-axis, the radial direction along the y-axis. The structure solver is Kratos, used to solve a fully 3D tube, with 24 elements on the fluid-structure interface in the length-wise direction and 8 in the circumferential direction. The Kratos element type used is ShellThickElementCorotational3D4N. These are 4-node shell elements. The displacement and loads are calculated/applied on the nodes. There are 200 nodes on the fluid-structure interface. The axial direction is along the x-axis, The coordinate frames of both solvers are the same so there is no need for a permutation mapper. On the other hand, difference in the discretization between the fluid and the structure mesh requires the use of interpolation mappers. Therefore, a radial basis mapper is used to interpolate in the x-, y- and z-direction.","title":"Fluent 3D - Kratos Structure 3D"},{"location":"tube_fluent3d_kratos_structure3d/#tube-case-with-fluent3d-and-kratos3d","text":"This example calculates the flow inside and the deformation and stresses of a straight flexible tube, where a pressure pulse is applied at the inlet. This done by using Fluent and StructuralMechanicsApplication of Kratos, both with a fully 3D case.","title":"Tube case with Fluent3D and Kratos3D"},{"location":"tube_fluent3d_kratos_structure3d/#coupling-algorithm","text":"The coupling technique used is the interface quasi-Newton algorithm with an approximation for the inverse of the Jacobian from a least-squares model (IQNI-LS).","title":"Coupling algorithm"},{"location":"tube_fluent3d_kratos_structure3d/#predictor","text":"The initial guess in every time step is done using the linear predictor.","title":"Predictor"},{"location":"tube_fluent3d_kratos_structure3d/#convergence-criterion","text":"Two convergence criteria have been specified: - The number of iterations in every time step is larger than 20. - The residual norm on the displacement is a factor 10^{-3} 10^{-3} lower than the initial value. When either criterion is satisfied the simulation stops.","title":"Convergence criterion"},{"location":"tube_fluent3d_kratos_structure3d/#solvers","text":"The flow solver is Fluent, used to solve a fully 3D tube, with 48 cells on the fluid-structure interface in the length-wise direction and 8 in the circumferential direction. When setting up the case, the mesh is build based on the file mesh.jou using Gambit. The displacements are applied in the nodes. In contrast, the loads (pressure and traction) are calculated in the cell centers. The axial direction is along the x-axis, the radial direction along the y-axis. The structure solver is Kratos, used to solve a fully 3D tube, with 24 elements on the fluid-structure interface in the length-wise direction and 8 in the circumferential direction. The Kratos element type used is ShellThickElementCorotational3D4N. These are 4-node shell elements. The displacement and loads are calculated/applied on the nodes. There are 200 nodes on the fluid-structure interface. The axial direction is along the x-axis, The coordinate frames of both solvers are the same so there is no need for a permutation mapper. On the other hand, difference in the discretization between the fluid and the structure mesh requires the use of interpolation mappers. Therefore, a radial basis mapper is used to interpolate in the x-, y- and z-direction.","title":"Solvers"},{"location":"tube_openfoam3d_abaqus3d/","text":"Tube case with OpenFOAM3D and Abaqus3D !! Should still be adapted to OpenFOAM, was copied from Fluent!! This example calculates the flow inside and the deformation and stresses of a straight flexible tube, where a pressure pulse is applied at the inlet. This done by using OpenFOAM and Abaqus, both with a fully 3D case. Coupling algorithm The coupling technique used is the interface quasi-Newton algorithm with an approximation for the inverse of the Jacobian from a least-squares model (IQNI-LS). Predictor The initial guess in every time step is done using the linear predictor. Convergence criterion Two convergence criteria have been specified: - The number of iterations in every time step is larger than 20. - The residual norm on the displacement is a factor 10^{-3} 10^{-3} lower than the initial value. When either criterion is satisfied the simulation stops. Solvers The flow solver is OpenFoam, used to solve a fully 3D tube, with 48 cells on the fluid-structure interface in the length-wise direction and 8 in the circumferential direction. When setting up the case, the mesh is build based on the file blockMeshDict . The displacements are applied in the nodes. In contrast, the loads (pressure and traction) are calculated in the cell centers. The axial direction is along the x-axis, the radial direction along the y-axis. The structure solver is Abaqus, used to solve a fully 3D tube, with 12 elements on the fluid-structure interface in the length-wise direction and 8 in the circumferential direction. The Abaqus case is not build when setting up the case, but is provided as the file Base.inp . The Abaqus element type used is S8R. These are 8-node shell elements. The R refers to reduced integration. See Abaqus documentation for more information. The loads are applied on the faces in 9 points per element, which means on 864 load points in total. The displacement is calculated in the nodes. There are 304 nodes on the fluid-structure interface. The axial direction is along the x-axis, the radial direction along the y-axis. The coordinate frames of both solvers are the same so there is no need for a permutation mapper. In contrast, the difference of the points where loads and displacements are applied or calculated, require the use of interpolation mappers. Therefore, a radial basis mapper is introduced in the structure solver to interpolate in the x-, y- and z-direction.","title":"OpenFOAM 3D - Abaqus 3D"},{"location":"tube_openfoam3d_abaqus3d/#tube-case-with-openfoam3d-and-abaqus3d","text":"!! Should still be adapted to OpenFOAM, was copied from Fluent!! This example calculates the flow inside and the deformation and stresses of a straight flexible tube, where a pressure pulse is applied at the inlet. This done by using OpenFOAM and Abaqus, both with a fully 3D case.","title":"Tube case with OpenFOAM3D and Abaqus3D"},{"location":"tube_openfoam3d_abaqus3d/#coupling-algorithm","text":"The coupling technique used is the interface quasi-Newton algorithm with an approximation for the inverse of the Jacobian from a least-squares model (IQNI-LS).","title":"Coupling algorithm"},{"location":"tube_openfoam3d_abaqus3d/#predictor","text":"The initial guess in every time step is done using the linear predictor.","title":"Predictor"},{"location":"tube_openfoam3d_abaqus3d/#convergence-criterion","text":"Two convergence criteria have been specified: - The number of iterations in every time step is larger than 20. - The residual norm on the displacement is a factor 10^{-3} 10^{-3} lower than the initial value. When either criterion is satisfied the simulation stops.","title":"Convergence criterion"},{"location":"tube_openfoam3d_abaqus3d/#solvers","text":"The flow solver is OpenFoam, used to solve a fully 3D tube, with 48 cells on the fluid-structure interface in the length-wise direction and 8 in the circumferential direction. When setting up the case, the mesh is build based on the file blockMeshDict . The displacements are applied in the nodes. In contrast, the loads (pressure and traction) are calculated in the cell centers. The axial direction is along the x-axis, the radial direction along the y-axis. The structure solver is Abaqus, used to solve a fully 3D tube, with 12 elements on the fluid-structure interface in the length-wise direction and 8 in the circumferential direction. The Abaqus case is not build when setting up the case, but is provided as the file Base.inp . The Abaqus element type used is S8R. These are 8-node shell elements. The R refers to reduced integration. See Abaqus documentation for more information. The loads are applied on the faces in 9 points per element, which means on 864 load points in total. The displacement is calculated in the nodes. There are 304 nodes on the fluid-structure interface. The axial direction is along the x-axis, the radial direction along the y-axis. The coordinate frames of both solvers are the same so there is no need for a permutation mapper. In contrast, the difference of the points where loads and displacements are applied or calculated, require the use of interpolation mappers. Therefore, a radial basis mapper is introduced in the structure solver to interpolate in the x-, y- and z-direction.","title":"Solvers"},{"location":"tube_openfoam3d_kratos3d/","text":"Tube case with OpenFOAM3D and Kratos3 This example calculates the flow inside and the deformation and stresses of a straight flexible tube, where a pressure pulse is applied at the inlet. This done by using OpenFOAM and StructuralMechanicsApplication of Kratos, both with a fully 3D case. Coupling algorithm The coupling technique used is the interface quasi-Newton algorithm with an approximation for the inverse of the Jacobian from a least-squares model (IQNI-LS). Predictor The initial guess in every time step is done using the linear predictor. Convergence criterion Two convergence criteria have been specified: - The number of iterations in every time step is larger than 20. - The residual norm on the displacement is a factor 10^{-3} 10^{-3} lower than the initial value. When either criterion is satisfied the simulation stops. Solvers The flow solver is OpenFoam, used to solve a fully 3D tube, with 48 cells on the fluid-structure interface in the length-wise direction and 8 in the circumferential direction. When setting up the case, the mesh is build based on the file blockMeshDict . The displacements are applied in the nodes. In contrast, the loads (pressure and traction) are calculated in the cell centers. The axial direction is along the x-axis, the radial direction along the y-axis. The structure solver is Kratos, used to solve a fully 3D tube, with 24 elements on the fluid-structure interface in the length-wise direction and 8 in the circumferential direction. The Kratos element type used is ShellThickElementCorotational3D4N. These are 4-node shell elements. The displacement and loads are calculated/applied on the nodes. There are 200 nodes on the fluid-structure interface. The axial direction is along the x-axis, The coordinate frames of both solvers are the same so there is no need for a permutation mapper. On the other hand, difference in the discretization between the fluid and the structure mesh requires the use of interpolation mappers. Therefore, a radial basis mapper is used to interpolate in the x-, y- and z-direction.","title":"Tube case with OpenFOAM3D and Kratos3"},{"location":"tube_openfoam3d_kratos3d/#tube-case-with-openfoam3d-and-kratos3","text":"This example calculates the flow inside and the deformation and stresses of a straight flexible tube, where a pressure pulse is applied at the inlet. This done by using OpenFOAM and StructuralMechanicsApplication of Kratos, both with a fully 3D case.","title":"Tube case with OpenFOAM3D and Kratos3"},{"location":"tube_openfoam3d_kratos3d/#coupling-algorithm","text":"The coupling technique used is the interface quasi-Newton algorithm with an approximation for the inverse of the Jacobian from a least-squares model (IQNI-LS).","title":"Coupling algorithm"},{"location":"tube_openfoam3d_kratos3d/#predictor","text":"The initial guess in every time step is done using the linear predictor.","title":"Predictor"},{"location":"tube_openfoam3d_kratos3d/#convergence-criterion","text":"Two convergence criteria have been specified: - The number of iterations in every time step is larger than 20. - The residual norm on the displacement is a factor 10^{-3} 10^{-3} lower than the initial value. When either criterion is satisfied the simulation stops.","title":"Convergence criterion"},{"location":"tube_openfoam3d_kratos3d/#solvers","text":"The flow solver is OpenFoam, used to solve a fully 3D tube, with 48 cells on the fluid-structure interface in the length-wise direction and 8 in the circumferential direction. When setting up the case, the mesh is build based on the file blockMeshDict . The displacements are applied in the nodes. In contrast, the loads (pressure and traction) are calculated in the cell centers. The axial direction is along the x-axis, the radial direction along the y-axis. The structure solver is Kratos, used to solve a fully 3D tube, with 24 elements on the fluid-structure interface in the length-wise direction and 8 in the circumferential direction. The Kratos element type used is ShellThickElementCorotational3D4N. These are 4-node shell elements. The displacement and loads are calculated/applied on the nodes. There are 200 nodes on the fluid-structure interface. The axial direction is along the x-axis, The coordinate frames of both solvers are the same so there is no need for a permutation mapper. On the other hand, difference in the discretization between the fluid and the structure mesh requires the use of interpolation mappers. Therefore, a radial basis mapper is used to interpolate in the x-, y- and z-direction.","title":"Solvers"},{"location":"tube_test_single_solver/","text":"Example case to test individual solvers This example shows how the separate solvers or their cases in the respective working directories can be tested individually using test_single_solver as coupling component. For more information refer to coupled_solvers . Coupling algorithm The type is set to coupled_solvers.test_single_solver and an additional required dictionary test_settings is added. All other parameters in the JSON file, including the settings dictionary, can be set to the values that will be used in the actual coupled simulation. The settings dictionary is used to look up delta_t , timestep_start , save_results and name if not provided in test_settings . The other dictionaries are not used: no predictor , convergence_criterion or mapper are used. Solvers If you run this case as is, the Fluent case and solver will be tested, as the solver_index is set to 0 in test_settings . In that case the Abaqus settings won't be used. The Abaqus case can easily be tested by changing this value to 1. Then the Fluent settings will not be used. The index refers to the index of the respective solver in the solver_wrappers list in the JSON file. Dummy solver Even though the presence dummy_solver.py with a test class is not strictly required, it can be very valuable because it allows to have a non-zero input. The file included in this case provides an example. It contains, among others, SimpleTest , TransientTest and InterpolatedData to illustrate how variables can be defined based on undeformed coordinates ( x , y , z ) and time step ( n ). Note that the number of classes defined is not restricted. Also note that the __init__() method can be used to avoid repeating the same calculations multiple times. The name of the class that one wants to use should be specified in the JSON file. In this example the TransientTest is used. Each class contains function definitions with a pre-formatted name calculate_variable(x,y,z,n) , with <variable> being the variable(s) required by the tested solver, e.g. displacement , pressure or traction . How these variables are defined inside these methods, is up to the user. However, the methods need to return the right format: a 3-element list or numpy array for vector variables and a 1-element list or numpy array for scalar variables.","title":"Test single solver"},{"location":"tube_test_single_solver/#example-case-to-test-individual-solvers","text":"This example shows how the separate solvers or their cases in the respective working directories can be tested individually using test_single_solver as coupling component. For more information refer to coupled_solvers .","title":"Example case to test individual solvers"},{"location":"tube_test_single_solver/#coupling-algorithm","text":"The type is set to coupled_solvers.test_single_solver and an additional required dictionary test_settings is added. All other parameters in the JSON file, including the settings dictionary, can be set to the values that will be used in the actual coupled simulation. The settings dictionary is used to look up delta_t , timestep_start , save_results and name if not provided in test_settings . The other dictionaries are not used: no predictor , convergence_criterion or mapper are used.","title":"Coupling algorithm"},{"location":"tube_test_single_solver/#solvers","text":"If you run this case as is, the Fluent case and solver will be tested, as the solver_index is set to 0 in test_settings . In that case the Abaqus settings won't be used. The Abaqus case can easily be tested by changing this value to 1. Then the Fluent settings will not be used. The index refers to the index of the respective solver in the solver_wrappers list in the JSON file.","title":"Solvers"},{"location":"tube_test_single_solver/#dummy-solver","text":"Even though the presence dummy_solver.py with a test class is not strictly required, it can be very valuable because it allows to have a non-zero input. The file included in this case provides an example. It contains, among others, SimpleTest , TransientTest and InterpolatedData to illustrate how variables can be defined based on undeformed coordinates ( x , y , z ) and time step ( n ). Note that the number of classes defined is not restricted. Also note that the __init__() method can be used to avoid repeating the same calculations multiple times. The name of the class that one wants to use should be specified in the JSON file. In this example the TransientTest is used. Each class contains function definitions with a pre-formatted name calculate_variable(x,y,z,n) , with <variable> being the variable(s) required by the tested solver, e.g. displacement , pressure or traction . How these variables are defined inside these methods, is up to the user. However, the methods need to return the right format: a 3-element list or numpy array for vector variables and a 1-element list or numpy array for scalar variables.","title":"Dummy solver"},{"location":"tube_tube_flow_abaqus2d/","text":"Tube case with TubeFlow and Abaqus2D This example calculates the flow inside and the deformation and stresses of a straight flexible tube, where a pressure pulse is applied at the inlet. This done by using Python solver TubeFlow and Abaqus (axisymmetric). Coupling algorithm The coupling technique used is the interface quasi-Newton algorithm with an approximation for the inverse of the Jacobian from a least-squares model (IQNI-LS). Predictor The initial guess in every time step is done using the linear predictor. Convergence criterion Two convergence criteria have been specified: The number of iterations in every time step is larger than 15. The residual norm on the displacement is a factor 10^{-6} 10^{-6} lower than the initial value. When either criterion is satisfied the simulation stops. Solvers The flow solver is the Python solver TubeFlow, which implements a 1D model of the flow inside the tube, with 100 cells on the fluid-structure interface. The parameters for this model are specified in the setup folder by the file solver_parameter.json . The (radial) displacements are applied on the cell centers. The loads, in fact are only pressure for this 1D case, are calculated in the cell centers as well. The axial direction is along the z-axis, the radial direction along the y-axis. The structure solver is Abaqus, used to solve an axisymmetric representation of the tube, with 50 elements on the fluid-structure interface. The Abaqus case is not build when setting up the case, but is provided as the file Base.inp . The Abaqus element type used is CAX8RH. These are continuum elements for axisymmetric calculations, for stress and displacement without twist. They are: 8-node biquadratic, reduced integration, hybrid with linear pressure. See Abaqus documentaion for more information. The loads are applied on the faces in three points per element, which means on 150 load points in total. The displacement is calculated in the nodes. There are 101 nodes on the fluid-structure interface. The axial direction is along the y-axis, the radial direction along the x-axis. The difference in reference frames and number of cells on the fluid-structure interface requires the use of mappers. In the structure solver wrapper, a permutation mapper is introduced to match the coordinate frames. The new x-axis corresponds to y-axis of the incomming loads the new y-axis corresponds to the z-axis and the new z-axis to the x-axis. Thereafter, a linear interpolation mapper is used to interpolate in the x- and y-direction from the 100 cell centers of TubeFlow to the 150 load points in Abaqus. For the output the same is done in the opposite order: first interpolating and then swapping the axes. So the new x-axis is the z-axis of the displacements calculated by Abaqus, the new y-axis corresponds to the x-axis and the new z-axis to the y-axis.","title":"Python TubeFlow - Abaqus 2D"},{"location":"tube_tube_flow_abaqus2d/#tube-case-with-tubeflow-and-abaqus2d","text":"This example calculates the flow inside and the deformation and stresses of a straight flexible tube, where a pressure pulse is applied at the inlet. This done by using Python solver TubeFlow and Abaqus (axisymmetric).","title":"Tube case with TubeFlow and Abaqus2D"},{"location":"tube_tube_flow_abaqus2d/#coupling-algorithm","text":"The coupling technique used is the interface quasi-Newton algorithm with an approximation for the inverse of the Jacobian from a least-squares model (IQNI-LS).","title":"Coupling algorithm"},{"location":"tube_tube_flow_abaqus2d/#predictor","text":"The initial guess in every time step is done using the linear predictor.","title":"Predictor"},{"location":"tube_tube_flow_abaqus2d/#convergence-criterion","text":"Two convergence criteria have been specified: The number of iterations in every time step is larger than 15. The residual norm on the displacement is a factor 10^{-6} 10^{-6} lower than the initial value. When either criterion is satisfied the simulation stops.","title":"Convergence criterion"},{"location":"tube_tube_flow_abaqus2d/#solvers","text":"The flow solver is the Python solver TubeFlow, which implements a 1D model of the flow inside the tube, with 100 cells on the fluid-structure interface. The parameters for this model are specified in the setup folder by the file solver_parameter.json . The (radial) displacements are applied on the cell centers. The loads, in fact are only pressure for this 1D case, are calculated in the cell centers as well. The axial direction is along the z-axis, the radial direction along the y-axis. The structure solver is Abaqus, used to solve an axisymmetric representation of the tube, with 50 elements on the fluid-structure interface. The Abaqus case is not build when setting up the case, but is provided as the file Base.inp . The Abaqus element type used is CAX8RH. These are continuum elements for axisymmetric calculations, for stress and displacement without twist. They are: 8-node biquadratic, reduced integration, hybrid with linear pressure. See Abaqus documentaion for more information. The loads are applied on the faces in three points per element, which means on 150 load points in total. The displacement is calculated in the nodes. There are 101 nodes on the fluid-structure interface. The axial direction is along the y-axis, the radial direction along the x-axis. The difference in reference frames and number of cells on the fluid-structure interface requires the use of mappers. In the structure solver wrapper, a permutation mapper is introduced to match the coordinate frames. The new x-axis corresponds to y-axis of the incomming loads the new y-axis corresponds to the z-axis and the new z-axis to the x-axis. Thereafter, a linear interpolation mapper is used to interpolate in the x- and y-direction from the 100 cell centers of TubeFlow to the 150 load points in Abaqus. For the output the same is done in the opposite order: first interpolating and then swapping the axes. So the new x-axis is the z-axis of the displacements calculated by Abaqus, the new y-axis corresponds to the x-axis and the new z-axis to the y-axis.","title":"Solvers"},{"location":"tube_tube_flow_tube_ringmodel/","text":"Tube case with TubeFlow and TubeStructure This example calculates the flow inside and the deformation and stresses of a straight flexible tube, where a sinusoidal velocity is specified at the inlet. This done by using Python solvers TubeFlow and TubeRingmodel. Coupling algorithm The coupling technique used is the interface quasi-Newton algorithm with an approximation for the inverse of the Jacobian from a least-squares model (IQNI-LS). Predictor The initial guess in every time step is done using the linear predictor. Convergence criterion Two convergence criteria have been specified: The number of iterations in every time step is larger than 15. The residual norm on the displacement is a factor 10^{-6} 10^{-6} lower than the initial value. When either criterion is satisfied the simulation stops. Solvers The flow solver is the Python solver TubeFlow, which implements a 1D model of the flow inside the tube, with 100 cells on the fluid-structure interface. The parameters for this model are specified in the setup folder by the file solver_parameter.json . The (radial) displacements are applied on the cell centers. The loads, in fact are only pressure for this 1D case, are calculated in the cell centers as well. The axial direction is along the z-axis, the radial direction along the y-axis. The structure solver is the Python solver TubeRingmodel, which implements a 1D model of the tube wall, with 100 elements on the fluid-structure interface. It differs from the Python solver TubeStructure as the no inertia is considered. The tube is regarded as consisting out of 100 independent rings. The parameters for this model are specified in the setup folder by the file solver_parameter.json . The loads, which in fact only pressure for this 1D case, are applied on the cell centers. The displacements are calculated in the cell centers as well. Only the radial displacement is different from zero. The axial direction is along the z-axis, the radial direction along the y-axis. The coordinate frames of both solvers are the same so there is no need for a permutation mapper. However, the discretization of both solvers differ. To account for the difference of the points where loads and displacements are applied or calculated, the use of interpolation mappers is required. Therefore, a linear interpolation mapper is introduced in the structure solver to interpolate in the x-direction. Additionally a parameter file parameters_conformal.json is also provided. This parameter file performs no interpolation. It should be verified that the number of cells m is the same in both solvers before using it and is merely provided as a theoretical example as it will have close to no practical use.","title":"Python TubeFlow - Python TubeRingmodel"},{"location":"tube_tube_flow_tube_ringmodel/#tube-case-with-tubeflow-and-tubestructure","text":"This example calculates the flow inside and the deformation and stresses of a straight flexible tube, where a sinusoidal velocity is specified at the inlet. This done by using Python solvers TubeFlow and TubeRingmodel.","title":"Tube case with TubeFlow and TubeStructure"},{"location":"tube_tube_flow_tube_ringmodel/#coupling-algorithm","text":"The coupling technique used is the interface quasi-Newton algorithm with an approximation for the inverse of the Jacobian from a least-squares model (IQNI-LS).","title":"Coupling algorithm"},{"location":"tube_tube_flow_tube_ringmodel/#predictor","text":"The initial guess in every time step is done using the linear predictor.","title":"Predictor"},{"location":"tube_tube_flow_tube_ringmodel/#convergence-criterion","text":"Two convergence criteria have been specified: The number of iterations in every time step is larger than 15. The residual norm on the displacement is a factor 10^{-6} 10^{-6} lower than the initial value. When either criterion is satisfied the simulation stops.","title":"Convergence criterion"},{"location":"tube_tube_flow_tube_ringmodel/#solvers","text":"The flow solver is the Python solver TubeFlow, which implements a 1D model of the flow inside the tube, with 100 cells on the fluid-structure interface. The parameters for this model are specified in the setup folder by the file solver_parameter.json . The (radial) displacements are applied on the cell centers. The loads, in fact are only pressure for this 1D case, are calculated in the cell centers as well. The axial direction is along the z-axis, the radial direction along the y-axis. The structure solver is the Python solver TubeRingmodel, which implements a 1D model of the tube wall, with 100 elements on the fluid-structure interface. It differs from the Python solver TubeStructure as the no inertia is considered. The tube is regarded as consisting out of 100 independent rings. The parameters for this model are specified in the setup folder by the file solver_parameter.json . The loads, which in fact only pressure for this 1D case, are applied on the cell centers. The displacements are calculated in the cell centers as well. Only the radial displacement is different from zero. The axial direction is along the z-axis, the radial direction along the y-axis. The coordinate frames of both solvers are the same so there is no need for a permutation mapper. However, the discretization of both solvers differ. To account for the difference of the points where loads and displacements are applied or calculated, the use of interpolation mappers is required. Therefore, a linear interpolation mapper is introduced in the structure solver to interpolate in the x-direction. Additionally a parameter file parameters_conformal.json is also provided. This parameter file performs no interpolation. It should be verified that the number of cells m is the same in both solvers before using it and is merely provided as a theoretical example as it will have close to no practical use.","title":"Solvers"},{"location":"tube_tube_flow_tube_structure/","text":"Tube case with TubeFlow and TubeStructure This example calculates the flow inside and the deformation and stresses of a straight flexible tube, where a pressure pulse is applied at the inlet. This done by using Python solvers TubeFlow and TubeStructure. Coupling algorithm The coupling technique used is the interface quasi-Newton algorithm with an approximation for the inverse of the Jacobian from a least-squares model (IQNI-LS). Predictor The initial guess in every time step is done using the linear predictor. Convergence criterion Two convergence criteria have been specified: - The number of iterations in every time step is larger than 15. - The residual norm on the displacement is a factor 10^{-6} 10^{-6} lower than the initial value. When either criterion is satisfied the simulation stops. Solvers The flow solver is the Python solver TubeFlow, which implements a 1D model of the flow inside the tube, with 100 cells on the fluid-structure interface. The parameters for this model are specified in the setup folder by the file solver_parameter.json . The (radial) displacements are applied on the cell centers. The loads, in fact are only pressure for this 1D case, are calculated in the cell centers as well. The axial direction is along the z-axis, the radial direction along the y-axis. The structure solver is the Python solver TubeStructure, which implements a 1D model of the tube wall, with 100 elements on the fluid-structure interface. The parameters for this model are specified in the setup folder by the file solver_parameter.json . The loads, which in fact only pressure for this 1D case, are applied on the cell centers. The displacements are calculated in the cell centers as well. Only the radial displacement is different from zero. The axial direction is along the z-axis, the radial direction along the y-axis. The coordinate frames of both solvers are the same so there is no need for a permutation mapper. Moreover, as both solvers have 100 cells on the fluid-structure interface, no interpolation is required. Nonetheless, a linear interpolation mapper for the structure solver to interpolate in the x-direction is included in the parameter file. As such, the number of cells m can be varied independently in both solvers.","title":"Python TubeFlow - Python TubeStructre"},{"location":"tube_tube_flow_tube_structure/#tube-case-with-tubeflow-and-tubestructure","text":"This example calculates the flow inside and the deformation and stresses of a straight flexible tube, where a pressure pulse is applied at the inlet. This done by using Python solvers TubeFlow and TubeStructure.","title":"Tube case with TubeFlow and TubeStructure"},{"location":"tube_tube_flow_tube_structure/#coupling-algorithm","text":"The coupling technique used is the interface quasi-Newton algorithm with an approximation for the inverse of the Jacobian from a least-squares model (IQNI-LS).","title":"Coupling algorithm"},{"location":"tube_tube_flow_tube_structure/#predictor","text":"The initial guess in every time step is done using the linear predictor.","title":"Predictor"},{"location":"tube_tube_flow_tube_structure/#convergence-criterion","text":"Two convergence criteria have been specified: - The number of iterations in every time step is larger than 15. - The residual norm on the displacement is a factor 10^{-6} 10^{-6} lower than the initial value. When either criterion is satisfied the simulation stops.","title":"Convergence criterion"},{"location":"tube_tube_flow_tube_structure/#solvers","text":"The flow solver is the Python solver TubeFlow, which implements a 1D model of the flow inside the tube, with 100 cells on the fluid-structure interface. The parameters for this model are specified in the setup folder by the file solver_parameter.json . The (radial) displacements are applied on the cell centers. The loads, in fact are only pressure for this 1D case, are calculated in the cell centers as well. The axial direction is along the z-axis, the radial direction along the y-axis. The structure solver is the Python solver TubeStructure, which implements a 1D model of the tube wall, with 100 elements on the fluid-structure interface. The parameters for this model are specified in the setup folder by the file solver_parameter.json . The loads, which in fact only pressure for this 1D case, are applied on the cell centers. The displacements are calculated in the cell centers as well. Only the radial displacement is different from zero. The axial direction is along the z-axis, the radial direction along the y-axis. The coordinate frames of both solvers are the same so there is no need for a permutation mapper. Moreover, as both solvers have 100 cells on the fluid-structure interface, no interpolation is required. Nonetheless, a linear interpolation mapper for the structure solver to interpolate in the x-direction is included in the parameter file. As such, the number of cells m can be varied independently in both solvers.","title":"Solvers"}]}