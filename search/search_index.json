{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"CoCoNuT installation For users Requirements: Python 3.6+ (Anaconda 2019.03+ recommended) Installation: Download the source code from GitHub Unzip to a folder coconut . Add the parent folder of coconut to your Python path. For example, with a folder structure like /some/absolute/path/ coconut/ coupling_components/ data_structure/ ... README.md coconut can be added to your Python path with: export PYTHONPATH = /some/absolute/path: $PYTHONPATH This line can also be added to your .bashrc file. Documentation: All documentation is grouped on the CoCoNut website . For developers Requirements: Python 3.6+ (Anaconda 2019.03+ recommended) Git Installation: Choose or create a directory to install CoCoNuT. Move to this directory. Clone the GitHub repository with SSH or HTTPS by executing one of the following commands. The choice depends on your git configuration. With SSH: git clone git@github.com:pyfsi/coconut.git With HTTPS git clone https://github.com/pyfsi/coconut.git Move to the coconut directory. Load Anaconda module. Run run_coconut_tests.sh to see if the installation works. sh run_coconut_tests.sh Add the parent folder of coconut to your Python path. For example, with a folder structure like /some/absolute/path/ coconut/ coupling_components/ data_structure/ ... README.md coconut can be added to your Python path with: export PYTHONPATH = /some/absolute/path: $PYTHONPATH This line can also be added to your .bashrc file. Documentation: All documentation is grouped on the CoCoNut website .","title":"CoCoNuT installation"},{"location":"#coconut-installation","text":"","title":"CoCoNuT installation"},{"location":"#for-users","text":"Requirements: Python 3.6+ (Anaconda 2019.03+ recommended) Installation: Download the source code from GitHub Unzip to a folder coconut . Add the parent folder of coconut to your Python path. For example, with a folder structure like /some/absolute/path/ coconut/ coupling_components/ data_structure/ ... README.md coconut can be added to your Python path with: export PYTHONPATH = /some/absolute/path: $PYTHONPATH This line can also be added to your .bashrc file. Documentation: All documentation is grouped on the CoCoNut website .","title":"For users"},{"location":"#for-developers","text":"Requirements: Python 3.6+ (Anaconda 2019.03+ recommended) Git Installation: Choose or create a directory to install CoCoNuT. Move to this directory. Clone the GitHub repository with SSH or HTTPS by executing one of the following commands. The choice depends on your git configuration. With SSH: git clone git@github.com:pyfsi/coconut.git With HTTPS git clone https://github.com/pyfsi/coconut.git Move to the coconut directory. Load Anaconda module. Run run_coconut_tests.sh to see if the installation works. sh run_coconut_tests.sh Add the parent folder of coconut to your Python path. For example, with a folder structure like /some/absolute/path/ coconut/ coupling_components/ data_structure/ ... README.md coconut can be added to your Python path with: export PYTHONPATH = /some/absolute/path: $PYTHONPATH This line can also be added to your .bashrc file. Documentation: All documentation is grouped on the CoCoNut website .","title":"For developers"},{"location":"abaqus/","text":"SolverWrapperAbaqus This is the documentation for all Abaqus SolverWrappers. Currently only FSI simulations are supported, no other multiphysics problems. Subcycling within the structural solver is possible. Terminology Main directory : Directory where the Python code will be executed Source directory (for wrapper): .../coconut/coupling_components/solver_wrappers/abaqus/ Extra directory : Subdirectory of the source directory with some files to assist with the setup Working directory : Subdirectory of the main directory where Abaqus will be running Geometrical nodes : Nodes in Abaqus related to the geometry of the elements. At these nodes the displacement data is exported. Loadpoints : Every element has load points. This is where the loads (input to Abaqus) are applied. Environment A working directory for Abaqus needs to be created within the main directory. Its relative path to the main directory should be specified in the .json file. Abaqus needs an AbaqusHosts.txt file in the working directory. This host-file lists the machines on which Abaqus is allowed to run. One line per requested core, but excessive lines cause no harm. The extra directory contains an Example_makeHostFile.sh which was used the generate a host file for the local system. The Abaqus license server needs to be specified in the parametrized file abaqus_v6.env which is present in the source directory The extra directory contains a file abaqus_setup which should be sourced in the terminal that will be used to run the simulation. This script loads the Abaqus module as well as the compilers. Parameters This section describes the Parameters in the JSON file, listed in alphabetical order. A distinction is made between mandatory and optional parameters. Mandatory parameter type description arraysize integer Size specification for array in FORTRAN part of the code. Should be large enough and depends on the number of load points in the structural model. cores integer Number of cores to be used by Abaqus. delta_t float Size of the time step in Abaqus (Should be synchronized with the flow solver). This parameter is usually specified in a higher Component . dimensions integer Dimensionality of the problem (2 or 3). interface_input dict Should contain surfaces keys. Keys are names of ModelParts for Abaqus load points. Each name (key) must be the contain an entry from surfaceIDs . The list that follows specifies the historical variables that should be included in this ModelPart (note the comma). Example: \u2003\"NODESETA_load_points\": [\"PRESSURE\", \"TRACTION\"], \u2003\"NODESETB_load_points\": [\"PRESSURE\", \"TRACTION\"] interface_output dict Similar to interface_input but for Abaqus geometrical nodes. input_file string Name of the input file provided by the user. Example: \u201cBase.inp\u201d mp_mode string Determines how Abaqus is executed in parallel. Should be \u201cTHREADS\u201d as \u201cMPI\u201d is currently not implemented. save_iterations integer Determines what files are kept by Abaqus. All files are saved, but files not corresponding to the save_iterations are removed at the end of a time step. Important for restart options (also in correspondence with the save interval of the flow solver). surfaceIDs list of strings Comma-separated list with the names of the node sets associated with the geometrical nodes on the interface surfaces. Example: [\u201cNODESETA\u201d, \u201cNODESETB\u201d] Important notes: \u2003\u2022 The sequence of these surfaces has to correspond with the integer specified in the corresponding load-surface (see the Input file section). \u2003\u2022 The names of these surfaces should be all UPPERCASE as Abaqus recasts these when opening the .inp file. surfaces integer Number of surfaces on the FSI interface. Should correspond with the number of elements in surfaceIDs . timestep_start integer Time step to start from. Data should be available at this time step. For a new simulation this value will typically be 0. This parameter should be synchronized with the flow solver. This parameter is usually specified in a higher Component . working_directory string Relative path to the directory in which Abaqus will be executed and where all structural information will be stored. Should be created before execution and contain an AbaqusHosts.txt file. timestep_start and delta_t are necessary parameters, but are usually defined in a higher Component . However, they can also be given directly as parameter of the solver wrapper (e.g. for standalone testing). If they are defined both in higher object and in the solver wrapper, then the former value is used and a warning is printed. If different parameters are used with different Abaqus versions, this should be specified both in this section and in the version specific documentation section. Optional parameter type description initialInc float Required when subcycling is enabled. Contains the size of the first substep attempted Abaqus. maxInc float Required when subcycling is enabled. Contains the maximal size allowed for a substep. maxNumInc integer Required when subcycling is enabled. Contains the maximum number of increments that Abaqus is allowed to perform for one time step. minInc float Required when subcycling is enabled. Contains the minimal size allowed for a substep. ramp integer Only important when subcycling is enabled in Abaqus. 0 : Load is considered to be constant throughout the time step 1 : [Default] Load is applied in a ramped fashion throughout the time step subcycling integer 0 : [Default] Abaqus solves the requested time step using one increment 1 : Abaqus is allowed to solve the time step using multiple increments, often required when contact is involved Input file The Abaqus solver wrapper is configured to start from an input file which contains all necessary information for the calculation. This file should be located in the main directory . Its name should be specified in the .json file via the parameter input_file . For the remainder of this section this file will be referred to as \u201cbase-file\u201d Creation of the base-file is not considered a part of the solver wrapper functionality as it is case-specific. However, in order for the solver wrapper to work, the base-file has to comply with certain general conditions. This section aims at informing the user about the requirements for the base-file. General The base-file needs to be of the \u201c.inp\u201d type, this is an \u201cinput file for Abaqus\u201d. \u201c.inp-files\u201d are created via Abaqus by, after configuration, creating a \u201cjob\u201d and requesting a \u201cwrite input\u201d for that job. These files can be opened in Abaqus by using \u201cfile > import > model\u201d. The base-file has to contain all necessary information about the structural model, which includes: Geometry Mesh Material properties Boundary conditions Surfaces where external loads need to be applied Node sets where displacement data will be extracted Additional loads not dependent on the flow solver Abaqus models contain parts and those parts are used to create assemblies. The base-file should contain one assembly, which will then be used by the coupling. The assembly, thus, determines the position and orientation that will be used by the coupling software. Setup for Abaqus input (loads) Per surface in the fluid-structure interface (where loads and displacements need to be exchanged) a \u201csurface\u201d should be created in the assembly. These surfaces can for example be created from geometry or by creating a \u201cnode set\u201d containing all the nodes on the surface and then calling the \u201cSurfaceFromNodeSet\u201d function which can be found in the makeSurface.py file in the Extra directory . The name of the surface has to be MOVINGSURFACE followed by an integer. The integer of the surface has to correspond with the index of that specific surface in the surfaceIDs parameter (index starts from 0). For example MOVINGSURFACE0 is associated with the first item in surfaceIDs and MOVINGSURFACE1 would be associated with the second item in surfaceIDs . An example on the use of SurfaceFromNodeSet (via the Python console in Abaqus or a python script for Abaqus): from makeSurface import * my_model = mdb . models [ 'Model-1' ] my_assembly = my_model . rootAssembly my_instance = my_assembly . instances [ 'PART-1-1' ] movingSurface0 = SurfaceFromNodeSet ( my_model , my_instance , 'NAME_OF_THE_NODESET' , 'MOVINGSURFACE0' ) On these surfaces a pressure load and a traction load need to be specified with a user-defined distribution. Loads are assigned to a \u201cstep\u201d. After creation of the step the loads can be assigned. This can be done via the GUI or using python commands available in Abaqus similar to the following: from step import * step1 = my_model . ImplicitDynamicsStep ( name = 'Step-1' , previous = 'Initial' , timePeriod = 1 , nlgeom = ON , maxNumInc = 1 , haftol = 1 , initialInc = 1 , minInc = 1 , maxInc = 1 , amplitude = RAMP , noStop = OFF , nohaf = ON , initialConditions = OFF , timeIncrementationMethod = FIXED , application = QUASI_STATIC ) my_model . Pressure ( name = 'DistributedPressure' , createStepName = 'Step-1' , distributionType = USER_DEFINED , field = '' , magnitude = 1 , region = movingSurface0 ) my_model . SurfaceTraction ( name = 'DistributedShear' , createStepName = 'Step-1' , region = movingSurface0 , magnitude = 1 , traction = GENERAL , directionVector = (( 0 , 0 , 0 ), ( 1 , 0 , 0 )), distributionType = USER_DEFINED ) Note that the step type \"ImplicitDynamicStep\" is an example, it depends on the analysis procedure chosen to run the Abaqus part of the FSI simulation. For a steady simulation this could for example be \"StaticStep\": step1 = my_model . StaticStep ( name = 'Step-1' , previous = 'Initial' , timePeriod = 1.0 , initialInc = 1 , minInc = 1e-4 , maxNumInc = 10 , nlgeom = ON , amplitude = RAMP ) Currently, the Abaqus wrapper automatically checks if the increments comply with the delta_t and subcycling settings and adjusts them accordingly or raises an error, but only for a dynamic step . This does not mean that it is not possible to run a steady simulation, but it means that the correct values should be provided in the input-file (so no dummy values). Setup for Abaqus output (displacements) After creation of the step Abaqus needs to be instructed about what to output at the end of a calculation. A fieldOutput has to be generated covering all locations involved in the fluid-structure interface. To do so it is best to create node sets in the assembly containing all structural nodes of the surfaces (if this had not been done before) and to create a fieldOutput per surface containing at least the coordinates and the displacements. In the previous section an example was given of how a surface can be created from a node set, but the other way around is also possible, creating a node set from a surface (presuming that this surface was already created): outputSet = my_assembly . Set ( name = 'NAME_OF_THE_NODESET' , nodes = movingSurface0 . nodes ) my_model . FieldOutputRequest ( createStepName = 'Step-1' , frequency = LAST_INCREMENT , name = 'F-Output-1' , region = my_assembly . sets [ 'NAME_OF_THE_NODE_SET' ], variables = ( 'COORD' , 'U' )) Furthermore, it is interesting (for post-processing and debugging) to preserve the default Abaqus output and therefore also configure a fieldOutput and historyOutput with PRESELECTED variables. This can be done via the GUI or using python lines similar to the following: my_model . FieldOutputRequest ( createStepName = 'Step-1' , frequency = LAST_INCREMENT , name = 'F-Output-2' , variables = PRESELECT ) my_model . HistoryOutputRequest ( createStepName = 'Step-1' , frequency = LAST_INCREMENT , name = 'H-Output-1' , variables = PRESELECT )","title":"SolverWrapperAbaqus"},{"location":"abaqus/#solverwrapperabaqus","text":"This is the documentation for all Abaqus SolverWrappers. Currently only FSI simulations are supported, no other multiphysics problems. Subcycling within the structural solver is possible.","title":"SolverWrapperAbaqus"},{"location":"abaqus/#terminology","text":"Main directory : Directory where the Python code will be executed Source directory (for wrapper): .../coconut/coupling_components/solver_wrappers/abaqus/ Extra directory : Subdirectory of the source directory with some files to assist with the setup Working directory : Subdirectory of the main directory where Abaqus will be running Geometrical nodes : Nodes in Abaqus related to the geometry of the elements. At these nodes the displacement data is exported. Loadpoints : Every element has load points. This is where the loads (input to Abaqus) are applied.","title":"Terminology"},{"location":"abaqus/#environment","text":"A working directory for Abaqus needs to be created within the main directory. Its relative path to the main directory should be specified in the .json file. Abaqus needs an AbaqusHosts.txt file in the working directory. This host-file lists the machines on which Abaqus is allowed to run. One line per requested core, but excessive lines cause no harm. The extra directory contains an Example_makeHostFile.sh which was used the generate a host file for the local system. The Abaqus license server needs to be specified in the parametrized file abaqus_v6.env which is present in the source directory The extra directory contains a file abaqus_setup which should be sourced in the terminal that will be used to run the simulation. This script loads the Abaqus module as well as the compilers.","title":"Environment"},{"location":"abaqus/#parameters","text":"This section describes the Parameters in the JSON file, listed in alphabetical order. A distinction is made between mandatory and optional parameters.","title":"Parameters"},{"location":"abaqus/#mandatory","text":"parameter type description arraysize integer Size specification for array in FORTRAN part of the code. Should be large enough and depends on the number of load points in the structural model. cores integer Number of cores to be used by Abaqus. delta_t float Size of the time step in Abaqus (Should be synchronized with the flow solver). This parameter is usually specified in a higher Component . dimensions integer Dimensionality of the problem (2 or 3). interface_input dict Should contain surfaces keys. Keys are names of ModelParts for Abaqus load points. Each name (key) must be the contain an entry from surfaceIDs . The list that follows specifies the historical variables that should be included in this ModelPart (note the comma). Example: \u2003\"NODESETA_load_points\": [\"PRESSURE\", \"TRACTION\"], \u2003\"NODESETB_load_points\": [\"PRESSURE\", \"TRACTION\"] interface_output dict Similar to interface_input but for Abaqus geometrical nodes. input_file string Name of the input file provided by the user. Example: \u201cBase.inp\u201d mp_mode string Determines how Abaqus is executed in parallel. Should be \u201cTHREADS\u201d as \u201cMPI\u201d is currently not implemented. save_iterations integer Determines what files are kept by Abaqus. All files are saved, but files not corresponding to the save_iterations are removed at the end of a time step. Important for restart options (also in correspondence with the save interval of the flow solver). surfaceIDs list of strings Comma-separated list with the names of the node sets associated with the geometrical nodes on the interface surfaces. Example: [\u201cNODESETA\u201d, \u201cNODESETB\u201d] Important notes: \u2003\u2022 The sequence of these surfaces has to correspond with the integer specified in the corresponding load-surface (see the Input file section). \u2003\u2022 The names of these surfaces should be all UPPERCASE as Abaqus recasts these when opening the .inp file. surfaces integer Number of surfaces on the FSI interface. Should correspond with the number of elements in surfaceIDs . timestep_start integer Time step to start from. Data should be available at this time step. For a new simulation this value will typically be 0. This parameter should be synchronized with the flow solver. This parameter is usually specified in a higher Component . working_directory string Relative path to the directory in which Abaqus will be executed and where all structural information will be stored. Should be created before execution and contain an AbaqusHosts.txt file. timestep_start and delta_t are necessary parameters, but are usually defined in a higher Component . However, they can also be given directly as parameter of the solver wrapper (e.g. for standalone testing). If they are defined both in higher object and in the solver wrapper, then the former value is used and a warning is printed. If different parameters are used with different Abaqus versions, this should be specified both in this section and in the version specific documentation section.","title":"Mandatory"},{"location":"abaqus/#optional","text":"parameter type description initialInc float Required when subcycling is enabled. Contains the size of the first substep attempted Abaqus. maxInc float Required when subcycling is enabled. Contains the maximal size allowed for a substep. maxNumInc integer Required when subcycling is enabled. Contains the maximum number of increments that Abaqus is allowed to perform for one time step. minInc float Required when subcycling is enabled. Contains the minimal size allowed for a substep. ramp integer Only important when subcycling is enabled in Abaqus. 0 : Load is considered to be constant throughout the time step 1 : [Default] Load is applied in a ramped fashion throughout the time step subcycling integer 0 : [Default] Abaqus solves the requested time step using one increment 1 : Abaqus is allowed to solve the time step using multiple increments, often required when contact is involved","title":"Optional"},{"location":"abaqus/#input-file","text":"The Abaqus solver wrapper is configured to start from an input file which contains all necessary information for the calculation. This file should be located in the main directory . Its name should be specified in the .json file via the parameter input_file . For the remainder of this section this file will be referred to as \u201cbase-file\u201d Creation of the base-file is not considered a part of the solver wrapper functionality as it is case-specific. However, in order for the solver wrapper to work, the base-file has to comply with certain general conditions. This section aims at informing the user about the requirements for the base-file.","title":"Input file"},{"location":"abaqus/#general","text":"The base-file needs to be of the \u201c.inp\u201d type, this is an \u201cinput file for Abaqus\u201d. \u201c.inp-files\u201d are created via Abaqus by, after configuration, creating a \u201cjob\u201d and requesting a \u201cwrite input\u201d for that job. These files can be opened in Abaqus by using \u201cfile > import > model\u201d. The base-file has to contain all necessary information about the structural model, which includes: Geometry Mesh Material properties Boundary conditions Surfaces where external loads need to be applied Node sets where displacement data will be extracted Additional loads not dependent on the flow solver Abaqus models contain parts and those parts are used to create assemblies. The base-file should contain one assembly, which will then be used by the coupling. The assembly, thus, determines the position and orientation that will be used by the coupling software.","title":"General"},{"location":"abaqus/#setup-for-abaqus-input-loads","text":"Per surface in the fluid-structure interface (where loads and displacements need to be exchanged) a \u201csurface\u201d should be created in the assembly. These surfaces can for example be created from geometry or by creating a \u201cnode set\u201d containing all the nodes on the surface and then calling the \u201cSurfaceFromNodeSet\u201d function which can be found in the makeSurface.py file in the Extra directory . The name of the surface has to be MOVINGSURFACE followed by an integer. The integer of the surface has to correspond with the index of that specific surface in the surfaceIDs parameter (index starts from 0). For example MOVINGSURFACE0 is associated with the first item in surfaceIDs and MOVINGSURFACE1 would be associated with the second item in surfaceIDs . An example on the use of SurfaceFromNodeSet (via the Python console in Abaqus or a python script for Abaqus): from makeSurface import * my_model = mdb . models [ 'Model-1' ] my_assembly = my_model . rootAssembly my_instance = my_assembly . instances [ 'PART-1-1' ] movingSurface0 = SurfaceFromNodeSet ( my_model , my_instance , 'NAME_OF_THE_NODESET' , 'MOVINGSURFACE0' ) On these surfaces a pressure load and a traction load need to be specified with a user-defined distribution. Loads are assigned to a \u201cstep\u201d. After creation of the step the loads can be assigned. This can be done via the GUI or using python commands available in Abaqus similar to the following: from step import * step1 = my_model . ImplicitDynamicsStep ( name = 'Step-1' , previous = 'Initial' , timePeriod = 1 , nlgeom = ON , maxNumInc = 1 , haftol = 1 , initialInc = 1 , minInc = 1 , maxInc = 1 , amplitude = RAMP , noStop = OFF , nohaf = ON , initialConditions = OFF , timeIncrementationMethod = FIXED , application = QUASI_STATIC ) my_model . Pressure ( name = 'DistributedPressure' , createStepName = 'Step-1' , distributionType = USER_DEFINED , field = '' , magnitude = 1 , region = movingSurface0 ) my_model . SurfaceTraction ( name = 'DistributedShear' , createStepName = 'Step-1' , region = movingSurface0 , magnitude = 1 , traction = GENERAL , directionVector = (( 0 , 0 , 0 ), ( 1 , 0 , 0 )), distributionType = USER_DEFINED ) Note that the step type \"ImplicitDynamicStep\" is an example, it depends on the analysis procedure chosen to run the Abaqus part of the FSI simulation. For a steady simulation this could for example be \"StaticStep\": step1 = my_model . StaticStep ( name = 'Step-1' , previous = 'Initial' , timePeriod = 1.0 , initialInc = 1 , minInc = 1e-4 , maxNumInc = 10 , nlgeom = ON , amplitude = RAMP ) Currently, the Abaqus wrapper automatically checks if the increments comply with the delta_t and subcycling settings and adjusts them accordingly or raises an error, but only for a dynamic step . This does not mean that it is not possible to run a steady simulation, but it means that the correct values should be provided in the input-file (so no dummy values).","title":"Setup for Abaqus input (loads)"},{"location":"abaqus/#setup-for-abaqus-output-displacements","text":"After creation of the step Abaqus needs to be instructed about what to output at the end of a calculation. A fieldOutput has to be generated covering all locations involved in the fluid-structure interface. To do so it is best to create node sets in the assembly containing all structural nodes of the surfaces (if this had not been done before) and to create a fieldOutput per surface containing at least the coordinates and the displacements. In the previous section an example was given of how a surface can be created from a node set, but the other way around is also possible, creating a node set from a surface (presuming that this surface was already created): outputSet = my_assembly . Set ( name = 'NAME_OF_THE_NODESET' , nodes = movingSurface0 . nodes ) my_model . FieldOutputRequest ( createStepName = 'Step-1' , frequency = LAST_INCREMENT , name = 'F-Output-1' , region = my_assembly . sets [ 'NAME_OF_THE_NODE_SET' ], variables = ( 'COORD' , 'U' )) Furthermore, it is interesting (for post-processing and debugging) to preserve the default Abaqus output and therefore also configure a fieldOutput and historyOutput with PRESELECTED variables. This can be done via the GUI or using python lines similar to the following: my_model . FieldOutputRequest ( createStepName = 'Step-1' , frequency = LAST_INCREMENT , name = 'F-Output-2' , variables = PRESELECT ) my_model . HistoryOutputRequest ( createStepName = 'Step-1' , frequency = LAST_INCREMENT , name = 'H-Output-1' , variables = PRESELECT )","title":"Setup for Abaqus output (displacements)"},{"location":"convergence_criteria/","text":"ConvergenceCriterion \"documentation on convergence criterion\"","title":"ConvergenceCriteria"},{"location":"convergence_criteria/#convergencecriterion","text":"\"documentation on convergence criterion\"","title":"ConvergenceCriterion"},{"location":"coupled_solvers/","text":"CoupledSolvers This documentation describes the coupled solvers which are available. A coupled solver refers to a coupling algortihm used to couple the two solvers. Some coupled solvers implement one or more models. All coupled solvers inherit from gauss_seidel . In the parameter JSON file, the dictionary coupled_solver holds the dictionaries type and settings , but also predictor , convergence_criterion and solver_wrappers . GaussSeidel Algorithm Gauss-Seidel iterations are the simplest way of coupling two solvers. In this coupling method fixed point iterations are performed as the output of one solver is given to the other one without adjustment. Basic schematic is given in the following figure. Here, \\mathcal{F} \\mathcal{F} is the first solver with input x x and output \\tilde{y} \\tilde{y} and \\mathcal{S} \\mathcal{S} is the second solver with input y y and output \\tilde{x} \\tilde{x} Gauss-Seidel iterations are very simple, but unstable for cases with high added mass. Settings The following parameters need to be included in the settings dictionary. Here they are listed in alphabetical order. parameter type description delta_t double Fixed time step size used in both solvers. For a steady simulation typically a value of 1 is taken. time_step_start int Time step number to (re)start a transient FSI calculation. If 0 is given, the simulation starts from scratch. Otherwise, the code looks for the relevant files to start from the corresponding time step. Not every solver implements restart, see the solver documentation for more information. For a steady simulation this should be 0. timestep_start and delta_t are necessary parameters (also in a steady simulation), but can also defined in the solverwrapper directly (e.g. for standalone testing). If they are defined both here and in the solver wrapper, then the former value is used and a warning is printed. These parameters should also be specified for the coupled solvers inheriting from GaussSeidel . Relaxation This coupled solvers inherits from GaussSeidel . Algorithm Gauss-Seidel iterations are very simple, but are unstable for cases with high added mass. An approach to mitigate this is applying relaxation, also called simple mixing. In this coupling method the output of first solver is still given to the other one without adjustment, but the output of the second solver is relaxed as follows: $$ x^{k+1}=(1-\\omega)x^k+\\omega\\tilde{x}^k=x^k+\\omega r^k $$ with x^k x^k and \\tilde{x}^k \\tilde{x}^k , respectively the input for the first solver and the output of the second solver in iteration k k . The difference between both is called the residual r^k=\\tilde{x}^k-x^k r^k=\\tilde{x}^k-x^k . The mixing or relaxation factor is \\omega \\omega . A symbolic schematic is given in the following figure. Here, \\mathcal{F} \\mathcal{F} is the first solver with input x x and output \\tilde{y} \\tilde{y} and \\mathcal{S} \\mathcal{S} is the second solver with input y y and output \\tilde{x} \\tilde{x} A lower \\omega \\omega increases stability, but decreases convergence speed. This method is again quite simple, but still often unstable for cases with high added mass. Settings Besides the parameters required in GaussSeidel , the following parameters need to be included in the settings dictionary. They are listed in alphabetical order. parameter type description omega double Relaxation factor. Aitken This coupled solvers inherits from GaussSeidel . Algorithm Gauss-Seidel iterations are very simple, but are unstable for cases with high added mass. An approach to mitigate this is applying relaxation. However, the choice of a relaxation factor can be difficult. In this coupling method a dynamic relaxation factor is used. The output of first solver is still given to the other one without adjustment, but the output of the second solver is relaxed as follows: $$ x^{k+1}=(1-\\omega^k)x^k+\\omega^k\\tilde{x}^k=x^k+\\omega^k r^k $$ with x^k x^k and \\tilde{x}^k \\tilde{x}^k , respectively the input for the first solver and the output of the second solver in iteration k k . The difference between both is called the residual r^k=\\tilde{x}^k-x^k r^k=\\tilde{x}^k-x^k . The mixing or relaxation factor is \\omega^k \\omega^k is dynamic in the sense that its value changes between iterations. A symbolic schematic is given in the following figure. Here, \\mathcal{F} \\mathcal{F} is the first solver with input x x and output \\tilde{y} \\tilde{y} and \\mathcal{S} \\mathcal{S} is the second solver with input y y and output \\tilde{x} \\tilde{x} The value of \\omega^k \\omega^k is determined by applying the secant method for scalars directly to vectors and projecting it on r^k-r^{k-1} r^k-r^{k-1} as follows $$ \\omega^k=-\\omega^{k-1}\\frac{(r^{k-1})^T(r^k-r^{k-1})}{(r^k-r^{k-1})^T(r^k-r^{k-1})}. $$ The first relaxation factor in a time step is equal to the last relaxation factor from the previous time step \\omega^n \\omega^n , but limited to \\omega^{max} \\omega^{max} . $$ \\omega^0=\\textrm{sign}(\\omega^n)\\min(|\\omega^n|,\\omega^{max}). $$ The relaxation factor in the first time step is equal to \\omega^{max} \\omega^{max} . This method improves convergence speed drastically compared to Gauss-Seidel iterations, but even faster convergence can be obtained using quasi-Newton methods which take into account sensitivities. Settings Besides the parameters required in GaussSeidel , the following parameters need to be included in the settings dictionary. They are listed in alphabetical order. parameter type description omega_max double Maximal relaxation factor. IQNI This coupled solvers inherits from GaussSeidel . Algorithm The abbreviation IQNI refers to interface quasi-Newton with inverse Jacobian . In this type of coupling iteration, the combination of the two solvers is seen as one system. The input of the first solver in iteration k k is denoted by x^k x^k . The output of this solver is transferred unchanged to the second solver. The output of the second solver is denoted \\tilde{x}^k \\tilde{x}^k . The difference between input and output is called the residual r^k=\\tilde{x}^k-x^k r^k=\\tilde{x}^k-x^k . A residual operator \\mathcal{R}(x) \\mathcal{R}(x) is defined which return the residual r^k r^k as a function of x^k x^k . The goal is to find x x for which \\mathcal{R}(x)=0 \\mathcal{R}(x)=0 . This system of non-linear equations is solved using Newton-Raphson iterations as follows $$ x^{k+1}=x^k-\\mathcal{R}'^{-1}(x^k)r^k, $$ where \\mathcal{R}' \\mathcal{R}' is the Jacobian of \\mathcal{R} \\mathcal{R} . However, this Jacobian is not accessible and is therefore approximated. Note that the iteration update can also be written as $$ \\Delta x^k=\\mathcal{R}'^{-1}(x^k)\\Delta r^k; $$ where \\Delta x^k=x^{k+1}-x^k \\Delta x^k=x^{k+1}-x^k is the difference between the input of two subsequent iterations and \\Delta r^k=0-r^k=-r^k \\Delta r^k=0-r^k=-r^k is the difference between the desired and the current residual. Likewise, \\Delta\\tilde{x}^k=\\tilde{x}^{k+1}-\\tilde{x}^k \\Delta\\tilde{x}^k=\\tilde{x}^{k+1}-\\tilde{x}^k is the difference between the the output of two subsequent iterations. Instead of approximating \\mathcal{R}'^{-1} \\mathcal{R}'^{-1} directly, the inverse Jacobian of \\tilde{\\mathcal{R}} \\tilde{\\mathcal{R}} is approximated. This altered residual operator is defined as follows $$ r^{k+1}=\\tilde{\\mathcal{R}}(\\tilde{x}^{k+1})=\\mathcal{R}(\\tilde{x}^{k+1}-r^{k+1}). $$ The inverse of both Jacobians are linked by $$ \\tilde{\\mathcal{R}}'^{-1}=\\mathcal{R}'^{-1}+I, $$ where \\tilde{\\mathcal{R}}' \\tilde{\\mathcal{R}}' is the Jacobian of \\tilde{\\mathcal{R}} \\tilde{\\mathcal{R}} with respect to \\tilde{x} \\tilde{x} and I I is the identity matrix. For this Jacobian the following is valid $$ \\Delta \\tilde{x}^k=\\tilde{\\mathcal{R}}'^{-1}(x^k)\\Delta r^k. $$ This Jacobian is also not known, but is approximated using a model denoted by \\tilde{N}^k \\tilde{N}^k . The type of model and its settings are specified in the settings dictionary. This model returns an estimation of \\Delta\\tilde{x}^k \\Delta\\tilde{x}^k given \\Delta r^k=-r^k \\Delta r^k=-r^k $$ \\Delta\\tilde{x}^k=\\tilde{N}^k \\Delta r^k. $$ Finally resulting in the update formula $$ x^{k+1}=x^k+(\\tilde{N}^k-I)\\Delta r^k=x^k-\\tilde{N}^k r^k+r^k. $$ A symbolic schematic is given in the following figure. Here, \\mathcal{F} \\mathcal{F} is the first solver with input x x and output \\tilde{y} \\tilde{y} and \\mathcal{S} \\mathcal{S} is the second solver with input y y and output \\tilde{x} \\tilde{x} For more information refer to . Settings Besides the parameters required in GaussSeidel , the following parameters need to be included in the settings dictionary. They are listed in alphabetical order. parameter type description model dict Model component. omega double Relaxation factor. IBQN This coupled solvers inherits from GaussSeidel . Algorithm The abbreviation IBQN refers to interface block quasi-Newton . In type of coupling iteration, the system $$ \\begin{cases} \\mathcal{F}(x)-y=0 \\newline \\mathcal{S}(y)-x=0 \\end{cases} $$ is solved in block form. Here, \\mathcal{F} \\mathcal{F} is the first solver with input x x and output \\tilde{y} \\tilde{y} and \\mathcal{S} \\mathcal{S} is the second solver with input y y and output \\tilde{x} \\tilde{x} In this iteration scheme, the output of each solver is altered before being transferred to the other one. Solving the system in block Newton-Raphson iterations results in $$ \\begin{bmatrix} \\mathcal{F}'(x) & -I \\newline -I & \\mathcal{S}'(y) \\end{bmatrix} \\begin{bmatrix} \\Delta x \\newline \\Delta y \\end{bmatrix} =- \\begin{bmatrix} \\mathcal{F}(x)-y \\newline \\mathcal{S}(y)-x \\end{bmatrix}, $$ where \\mathcal{F}' \\mathcal{F}' and \\mathcal{S}' \\mathcal{S}' denote the Jacobians of the first and second solver, respectively. These Jacobians are however not accessible and are approximated using a model as specified in the settings dictionary. To the fist and second solver correspond model_f , denoted here by M_f M_f , and model_s , denoted bye M_s M_s , respectively. For example, model_f returns an estimation of \\Delta\\tilde{y}^k=\\tilde{y}^{k+1}-\\tilde{y}^k \\Delta\\tilde{y}^k=\\tilde{y}^{k+1}-\\tilde{y}^k given \\Delta x^k=x^{k+1}-x^k \\Delta x^k=x^{k+1}-x^k $$ \\Delta\\tilde{y}^k=M_f^k \\Delta x^k. $$ Solving for x^{k+1}=x^k+\\Delta x^k x^{k+1}=x^k+\\Delta x^k requires solving the system $$ \\left(I-M_s^k M_f^k\\right)\\Delta x^k =\\tilde{x}^k-x^k+M_s^k(\\tilde{y}^k-y^k) $$ for \\Delta x^k \\Delta x^k . This done matrix-free using a GMRES method. Analogously, the input y^{k+1}=y^k+\\Delta y^k y^{k+1}=y^k+\\Delta y^k for the structural solver by solving $$ \\left(I-M_f^{k+1}M_s^k\\right)\\Delta y^k =\\tilde{y}^{k+1}-y^k+M_f^{k+1}(\\tilde{x}^k-x^{k+1}) $$ for \\Delta y^k \\Delta y^k . A symbolic schematic is given in the following figure. For more information refer to . Settings Besides the parameters required in GaussSeidel , the following parameters need to be included in the settings dictionary. They are listed in alphabetical order. parameter type description absolute_tolerance_gmres double Absolute tolerance used in the GMRES method. model_f dict Model component corresponding to the first solver wrapper. model_s dict Model component corresponding to the second solver wrapper. omega double Relaxation factor. relative_tolerance_gmres double Relative tolerance used in the GMRES method.","title":"CoupledSolvers"},{"location":"coupled_solvers/#coupledsolvers","text":"This documentation describes the coupled solvers which are available. A coupled solver refers to a coupling algortihm used to couple the two solvers. Some coupled solvers implement one or more models. All coupled solvers inherit from gauss_seidel . In the parameter JSON file, the dictionary coupled_solver holds the dictionaries type and settings , but also predictor , convergence_criterion and solver_wrappers .","title":"CoupledSolvers"},{"location":"coupled_solvers/#gaussseidel","text":"","title":"GaussSeidel"},{"location":"coupled_solvers/#algorithm","text":"Gauss-Seidel iterations are the simplest way of coupling two solvers. In this coupling method fixed point iterations are performed as the output of one solver is given to the other one without adjustment. Basic schematic is given in the following figure. Here, \\mathcal{F} \\mathcal{F} is the first solver with input x x and output \\tilde{y} \\tilde{y} and \\mathcal{S} \\mathcal{S} is the second solver with input y y and output \\tilde{x} \\tilde{x} Gauss-Seidel iterations are very simple, but unstable for cases with high added mass.","title":"Algorithm"},{"location":"coupled_solvers/#settings","text":"The following parameters need to be included in the settings dictionary. Here they are listed in alphabetical order. parameter type description delta_t double Fixed time step size used in both solvers. For a steady simulation typically a value of 1 is taken. time_step_start int Time step number to (re)start a transient FSI calculation. If 0 is given, the simulation starts from scratch. Otherwise, the code looks for the relevant files to start from the corresponding time step. Not every solver implements restart, see the solver documentation for more information. For a steady simulation this should be 0. timestep_start and delta_t are necessary parameters (also in a steady simulation), but can also defined in the solverwrapper directly (e.g. for standalone testing). If they are defined both here and in the solver wrapper, then the former value is used and a warning is printed. These parameters should also be specified for the coupled solvers inheriting from GaussSeidel .","title":"Settings"},{"location":"coupled_solvers/#relaxation","text":"This coupled solvers inherits from GaussSeidel .","title":"Relaxation"},{"location":"coupled_solvers/#algorithm_1","text":"Gauss-Seidel iterations are very simple, but are unstable for cases with high added mass. An approach to mitigate this is applying relaxation, also called simple mixing. In this coupling method the output of first solver is still given to the other one without adjustment, but the output of the second solver is relaxed as follows: $$ x^{k+1}=(1-\\omega)x^k+\\omega\\tilde{x}^k=x^k+\\omega r^k $$ with x^k x^k and \\tilde{x}^k \\tilde{x}^k , respectively the input for the first solver and the output of the second solver in iteration k k . The difference between both is called the residual r^k=\\tilde{x}^k-x^k r^k=\\tilde{x}^k-x^k . The mixing or relaxation factor is \\omega \\omega . A symbolic schematic is given in the following figure. Here, \\mathcal{F} \\mathcal{F} is the first solver with input x x and output \\tilde{y} \\tilde{y} and \\mathcal{S} \\mathcal{S} is the second solver with input y y and output \\tilde{x} \\tilde{x} A lower \\omega \\omega increases stability, but decreases convergence speed. This method is again quite simple, but still often unstable for cases with high added mass.","title":"Algorithm"},{"location":"coupled_solvers/#settings_1","text":"Besides the parameters required in GaussSeidel , the following parameters need to be included in the settings dictionary. They are listed in alphabetical order. parameter type description omega double Relaxation factor.","title":"Settings"},{"location":"coupled_solvers/#aitken","text":"This coupled solvers inherits from GaussSeidel .","title":"Aitken"},{"location":"coupled_solvers/#algorithm_2","text":"Gauss-Seidel iterations are very simple, but are unstable for cases with high added mass. An approach to mitigate this is applying relaxation. However, the choice of a relaxation factor can be difficult. In this coupling method a dynamic relaxation factor is used. The output of first solver is still given to the other one without adjustment, but the output of the second solver is relaxed as follows: $$ x^{k+1}=(1-\\omega^k)x^k+\\omega^k\\tilde{x}^k=x^k+\\omega^k r^k $$ with x^k x^k and \\tilde{x}^k \\tilde{x}^k , respectively the input for the first solver and the output of the second solver in iteration k k . The difference between both is called the residual r^k=\\tilde{x}^k-x^k r^k=\\tilde{x}^k-x^k . The mixing or relaxation factor is \\omega^k \\omega^k is dynamic in the sense that its value changes between iterations. A symbolic schematic is given in the following figure. Here, \\mathcal{F} \\mathcal{F} is the first solver with input x x and output \\tilde{y} \\tilde{y} and \\mathcal{S} \\mathcal{S} is the second solver with input y y and output \\tilde{x} \\tilde{x} The value of \\omega^k \\omega^k is determined by applying the secant method for scalars directly to vectors and projecting it on r^k-r^{k-1} r^k-r^{k-1} as follows $$ \\omega^k=-\\omega^{k-1}\\frac{(r^{k-1})^T(r^k-r^{k-1})}{(r^k-r^{k-1})^T(r^k-r^{k-1})}. $$ The first relaxation factor in a time step is equal to the last relaxation factor from the previous time step \\omega^n \\omega^n , but limited to \\omega^{max} \\omega^{max} . $$ \\omega^0=\\textrm{sign}(\\omega^n)\\min(|\\omega^n|,\\omega^{max}). $$ The relaxation factor in the first time step is equal to \\omega^{max} \\omega^{max} . This method improves convergence speed drastically compared to Gauss-Seidel iterations, but even faster convergence can be obtained using quasi-Newton methods which take into account sensitivities.","title":"Algorithm"},{"location":"coupled_solvers/#settings_2","text":"Besides the parameters required in GaussSeidel , the following parameters need to be included in the settings dictionary. They are listed in alphabetical order. parameter type description omega_max double Maximal relaxation factor.","title":"Settings"},{"location":"coupled_solvers/#iqni","text":"This coupled solvers inherits from GaussSeidel .","title":"IQNI"},{"location":"coupled_solvers/#algorithm_3","text":"The abbreviation IQNI refers to interface quasi-Newton with inverse Jacobian . In this type of coupling iteration, the combination of the two solvers is seen as one system. The input of the first solver in iteration k k is denoted by x^k x^k . The output of this solver is transferred unchanged to the second solver. The output of the second solver is denoted \\tilde{x}^k \\tilde{x}^k . The difference between input and output is called the residual r^k=\\tilde{x}^k-x^k r^k=\\tilde{x}^k-x^k . A residual operator \\mathcal{R}(x) \\mathcal{R}(x) is defined which return the residual r^k r^k as a function of x^k x^k . The goal is to find x x for which \\mathcal{R}(x)=0 \\mathcal{R}(x)=0 . This system of non-linear equations is solved using Newton-Raphson iterations as follows $$ x^{k+1}=x^k-\\mathcal{R}'^{-1}(x^k)r^k, $$ where \\mathcal{R}' \\mathcal{R}' is the Jacobian of \\mathcal{R} \\mathcal{R} . However, this Jacobian is not accessible and is therefore approximated. Note that the iteration update can also be written as $$ \\Delta x^k=\\mathcal{R}'^{-1}(x^k)\\Delta r^k; $$ where \\Delta x^k=x^{k+1}-x^k \\Delta x^k=x^{k+1}-x^k is the difference between the input of two subsequent iterations and \\Delta r^k=0-r^k=-r^k \\Delta r^k=0-r^k=-r^k is the difference between the desired and the current residual. Likewise, \\Delta\\tilde{x}^k=\\tilde{x}^{k+1}-\\tilde{x}^k \\Delta\\tilde{x}^k=\\tilde{x}^{k+1}-\\tilde{x}^k is the difference between the the output of two subsequent iterations. Instead of approximating \\mathcal{R}'^{-1} \\mathcal{R}'^{-1} directly, the inverse Jacobian of \\tilde{\\mathcal{R}} \\tilde{\\mathcal{R}} is approximated. This altered residual operator is defined as follows $$ r^{k+1}=\\tilde{\\mathcal{R}}(\\tilde{x}^{k+1})=\\mathcal{R}(\\tilde{x}^{k+1}-r^{k+1}). $$ The inverse of both Jacobians are linked by $$ \\tilde{\\mathcal{R}}'^{-1}=\\mathcal{R}'^{-1}+I, $$ where \\tilde{\\mathcal{R}}' \\tilde{\\mathcal{R}}' is the Jacobian of \\tilde{\\mathcal{R}} \\tilde{\\mathcal{R}} with respect to \\tilde{x} \\tilde{x} and I I is the identity matrix. For this Jacobian the following is valid $$ \\Delta \\tilde{x}^k=\\tilde{\\mathcal{R}}'^{-1}(x^k)\\Delta r^k. $$ This Jacobian is also not known, but is approximated using a model denoted by \\tilde{N}^k \\tilde{N}^k . The type of model and its settings are specified in the settings dictionary. This model returns an estimation of \\Delta\\tilde{x}^k \\Delta\\tilde{x}^k given \\Delta r^k=-r^k \\Delta r^k=-r^k $$ \\Delta\\tilde{x}^k=\\tilde{N}^k \\Delta r^k. $$ Finally resulting in the update formula $$ x^{k+1}=x^k+(\\tilde{N}^k-I)\\Delta r^k=x^k-\\tilde{N}^k r^k+r^k. $$ A symbolic schematic is given in the following figure. Here, \\mathcal{F} \\mathcal{F} is the first solver with input x x and output \\tilde{y} \\tilde{y} and \\mathcal{S} \\mathcal{S} is the second solver with input y y and output \\tilde{x} \\tilde{x} For more information refer to .","title":"Algorithm"},{"location":"coupled_solvers/#settings_3","text":"Besides the parameters required in GaussSeidel , the following parameters need to be included in the settings dictionary. They are listed in alphabetical order. parameter type description model dict Model component. omega double Relaxation factor.","title":"Settings"},{"location":"coupled_solvers/#ibqn","text":"This coupled solvers inherits from GaussSeidel .","title":"IBQN"},{"location":"coupled_solvers/#algorithm_4","text":"The abbreviation IBQN refers to interface block quasi-Newton . In type of coupling iteration, the system $$ \\begin{cases} \\mathcal{F}(x)-y=0 \\newline \\mathcal{S}(y)-x=0 \\end{cases} $$ is solved in block form. Here, \\mathcal{F} \\mathcal{F} is the first solver with input x x and output \\tilde{y} \\tilde{y} and \\mathcal{S} \\mathcal{S} is the second solver with input y y and output \\tilde{x} \\tilde{x} In this iteration scheme, the output of each solver is altered before being transferred to the other one. Solving the system in block Newton-Raphson iterations results in $$ \\begin{bmatrix} \\mathcal{F}'(x) & -I \\newline -I & \\mathcal{S}'(y) \\end{bmatrix} \\begin{bmatrix} \\Delta x \\newline \\Delta y \\end{bmatrix} =- \\begin{bmatrix} \\mathcal{F}(x)-y \\newline \\mathcal{S}(y)-x \\end{bmatrix}, $$ where \\mathcal{F}' \\mathcal{F}' and \\mathcal{S}' \\mathcal{S}' denote the Jacobians of the first and second solver, respectively. These Jacobians are however not accessible and are approximated using a model as specified in the settings dictionary. To the fist and second solver correspond model_f , denoted here by M_f M_f , and model_s , denoted bye M_s M_s , respectively. For example, model_f returns an estimation of \\Delta\\tilde{y}^k=\\tilde{y}^{k+1}-\\tilde{y}^k \\Delta\\tilde{y}^k=\\tilde{y}^{k+1}-\\tilde{y}^k given \\Delta x^k=x^{k+1}-x^k \\Delta x^k=x^{k+1}-x^k $$ \\Delta\\tilde{y}^k=M_f^k \\Delta x^k. $$ Solving for x^{k+1}=x^k+\\Delta x^k x^{k+1}=x^k+\\Delta x^k requires solving the system $$ \\left(I-M_s^k M_f^k\\right)\\Delta x^k =\\tilde{x}^k-x^k+M_s^k(\\tilde{y}^k-y^k) $$ for \\Delta x^k \\Delta x^k . This done matrix-free using a GMRES method. Analogously, the input y^{k+1}=y^k+\\Delta y^k y^{k+1}=y^k+\\Delta y^k for the structural solver by solving $$ \\left(I-M_f^{k+1}M_s^k\\right)\\Delta y^k =\\tilde{y}^{k+1}-y^k+M_f^{k+1}(\\tilde{x}^k-x^{k+1}) $$ for \\Delta y^k \\Delta y^k . A symbolic schematic is given in the following figure. For more information refer to .","title":"Algorithm"},{"location":"coupled_solvers/#settings_4","text":"Besides the parameters required in GaussSeidel , the following parameters need to be included in the settings dictionary. They are listed in alphabetical order. parameter type description absolute_tolerance_gmres double Absolute tolerance used in the GMRES method. model_f dict Model component corresponding to the first solver wrapper. model_s dict Model component corresponding to the second solver wrapper. omega double Relaxation factor. relative_tolerance_gmres double Relative tolerance used in the GMRES method.","title":"Settings"},{"location":"data_structure/","text":"CoSimulation Application PYTHON ONLY VERSION This is the description for the python-only version of the CoSimulationApplication. Kratos is only used as a container for data within the CoSimulationApplication, the CoSimApp itself is coded in python. For the python-only version, Kratos is replaced by pyKratos, which is a python version of Kratos which implements the basic features (of KratosMultiphysics) required for CoSimulation. The version of pyKratos within this folder is based on the work of Riccardo Rossi In order to install the python-version, please follow the instructions in configure_py_co_sim.sh . For this no compilation is required. The tests can be executed by running python test_CoSimulationApplication.py in the folder tests TODO: this old file must be adapted to give correct credit to Kratos for the data structure","title":"Data structure"},{"location":"data_structure/#cosimulation-application-python-only-version","text":"This is the description for the python-only version of the CoSimulationApplication. Kratos is only used as a container for data within the CoSimulationApplication, the CoSimApp itself is coded in python. For the python-only version, Kratos is replaced by pyKratos, which is a python version of Kratos which implements the basic features (of KratosMultiphysics) required for CoSimulation. The version of pyKratos within this folder is based on the work of Riccardo Rossi In order to install the python-version, please follow the instructions in configure_py_co_sim.sh . For this no compilation is required. The tests can be executed by running python test_CoSimulationApplication.py in the folder tests TODO: this old file must be adapted to give correct credit to Kratos for the data structure","title":"CoSimulation Application PYTHON ONLY VERSION"},{"location":"docs/","text":"Guide to the documentation This website is a collection of all MarkDown (MD) files found in the coconut package. These files are converted to a static website using MkDocs , based on the outline defined in the mkdocs.yml file. Documentation in MarkDown MD files are easy to write and read in raw form, and can easily be converted to HTML for nicer rendering. It is easy to learn, see e.g. this tutorial . Several flavors of MD exist, which differ only in some details. GitHub has its own GitHub Flavored Markdown (GFM) , which is used to render MD documents found in repositories on the run. PyCharm comes with an automatic rendering tool built in, and I assume many other IDE's too. The MD documents for the CoCoNuT documentation must be written in the Python-Markdown flavor, because they are processed by MkDocs . This flavor stays very close to the reference implementation of MD. Pay attention to lists: they should be indented with 4 spaces (contrary to GFM). Some important rules for writing MD files for this documentation website: The name of the file must be unique: use names like fluent.md or test_examples.md , not readme.md . Links to other MD files: I have yet to test this... probably only works on website, not on GitHub because paths change. Possible fix: automatically replace all names example.md with a proper link. Math For writing mathematics, LaTeX notation can be used. Inline equations must be enclosed in single dollar signs (e.g. E = m c^2 E = m c^2 ), block-style equations in double dolar signs, e.g. e^{i \\pi} + 1 = 0. e^{i \\pi} + 1 = 0. LaTeX expressions will not be rendered on GitHub, but only on the documentation website. For the latter, the MD extension Arithmatex is used to render the expressions with MathJax. Note that MathJax syntax is a little more restrictive than a real LaTeX installation. Images External images can be included with their URL. Adding locally stored images is a bit more complicated: these images must be stored in a directory images next to the MD file. If another location is used, they will not be shown on the website, only on GitHub. Furthermore, images must have a unique name. A warning is shown when this is not the case. An image can be added with the MD command ! [ alt ] ( images / example . png \"description\" ) with alt displayed when the image cannot be shown/viewed for some reason, and description appearing when hovering over the image with your mouse. For example: Only image formats specified in run_mkdocs.py are copied to the website; missing extensions can be added. Images from all coconut subdirectories called images are copied to the website, so care must be taken that images is not used in e.g. the output of the test examples. Creating a static website with MkDocs MkDocs can be installed using pip: pip install mkdocs Furthermore, the Material theme must be installed: pip install mkdocs-material To render LaTeX equations, the PyMdown MD extensions must be installed: pip install pymdown-extensions All three can be installed locally by adding the argument -t /some/absolute/path . In that case, two lines must be added to your .bashrc : export PYTHONPATH = /some/absolute/path: $PYTHONPATH export PATH = /some/absolute/path/bin: $PATH The structure/outline of the website is dictated by the nav variable in mkdocs.yml . This is the only variable that must be adjusted when new MD files are added to the code. The complete process to create the documentation website is automated by run_mkdocs.py . This does the following things: Copy all MD files in coconut and its subfolders to folder docs . Check if there are duplicate filenames: these overwrite each other! If duplicates are found, a warning is given with the original paths. Check if each MD file is mentioned in mkdocs.yml . If a file is not mentioned, a warning is given. Build static HTML website using mkdocs build . The behavior of run_mkdocs.py can be altered by adding an extra command line argument. python run_mkdocs.py --deploy deploys the website on GitHub Pages using mkdocs gh-deploy . It seems this is currently only possible if the remote is configured with SSH, not with HTTPS. python run_mkdocs.py --preview example opens a preview of the website in Firefox, showing the webpage corresponding to the file example.md . This can be used to check MD and LaTeX syntax.","title":"Guide to the documentation"},{"location":"docs/#guide-to-the-documentation","text":"This website is a collection of all MarkDown (MD) files found in the coconut package. These files are converted to a static website using MkDocs , based on the outline defined in the mkdocs.yml file.","title":"Guide to the documentation"},{"location":"docs/#documentation-in-markdown","text":"MD files are easy to write and read in raw form, and can easily be converted to HTML for nicer rendering. It is easy to learn, see e.g. this tutorial . Several flavors of MD exist, which differ only in some details. GitHub has its own GitHub Flavored Markdown (GFM) , which is used to render MD documents found in repositories on the run. PyCharm comes with an automatic rendering tool built in, and I assume many other IDE's too. The MD documents for the CoCoNuT documentation must be written in the Python-Markdown flavor, because they are processed by MkDocs . This flavor stays very close to the reference implementation of MD. Pay attention to lists: they should be indented with 4 spaces (contrary to GFM). Some important rules for writing MD files for this documentation website: The name of the file must be unique: use names like fluent.md or test_examples.md , not readme.md . Links to other MD files: I have yet to test this... probably only works on website, not on GitHub because paths change. Possible fix: automatically replace all names example.md with a proper link.","title":"Documentation in MarkDown"},{"location":"docs/#math","text":"For writing mathematics, LaTeX notation can be used. Inline equations must be enclosed in single dollar signs (e.g. E = m c^2 E = m c^2 ), block-style equations in double dolar signs, e.g. e^{i \\pi} + 1 = 0. e^{i \\pi} + 1 = 0. LaTeX expressions will not be rendered on GitHub, but only on the documentation website. For the latter, the MD extension Arithmatex is used to render the expressions with MathJax. Note that MathJax syntax is a little more restrictive than a real LaTeX installation.","title":"Math"},{"location":"docs/#images","text":"External images can be included with their URL. Adding locally stored images is a bit more complicated: these images must be stored in a directory images next to the MD file. If another location is used, they will not be shown on the website, only on GitHub. Furthermore, images must have a unique name. A warning is shown when this is not the case. An image can be added with the MD command ! [ alt ] ( images / example . png \"description\" ) with alt displayed when the image cannot be shown/viewed for some reason, and description appearing when hovering over the image with your mouse. For example: Only image formats specified in run_mkdocs.py are copied to the website; missing extensions can be added. Images from all coconut subdirectories called images are copied to the website, so care must be taken that images is not used in e.g. the output of the test examples.","title":"Images"},{"location":"docs/#creating-a-static-website-with-mkdocs","text":"MkDocs can be installed using pip: pip install mkdocs Furthermore, the Material theme must be installed: pip install mkdocs-material To render LaTeX equations, the PyMdown MD extensions must be installed: pip install pymdown-extensions All three can be installed locally by adding the argument -t /some/absolute/path . In that case, two lines must be added to your .bashrc : export PYTHONPATH = /some/absolute/path: $PYTHONPATH export PATH = /some/absolute/path/bin: $PATH The structure/outline of the website is dictated by the nav variable in mkdocs.yml . This is the only variable that must be adjusted when new MD files are added to the code. The complete process to create the documentation website is automated by run_mkdocs.py . This does the following things: Copy all MD files in coconut and its subfolders to folder docs . Check if there are duplicate filenames: these overwrite each other! If duplicates are found, a warning is given with the original paths. Check if each MD file is mentioned in mkdocs.yml . If a file is not mentioned, a warning is given. Build static HTML website using mkdocs build . The behavior of run_mkdocs.py can be altered by adding an extra command line argument. python run_mkdocs.py --deploy deploys the website on GitHub Pages using mkdocs gh-deploy . It seems this is currently only possible if the remote is configured with SSH, not with HTTPS. python run_mkdocs.py --preview example opens a preview of the website in Firefox, showing the webpage corresponding to the file example.md . This can be used to check MD and LaTeX syntax.","title":"Creating a static website with MkDocs"},{"location":"fluent/","text":"SolverWrapperFluent This is the documentation for all Fluent solver-wrappers. Currently only FSI simulations are supported, no other multiphysics problems. Also, inviscid flows are not supported yet. Parameters This section describes the parameters in the JSON file, listed in alphabetical order. parameter type description case_file string Name of the case file. It must be present in the folder working_directory . cores int Number of processor cores to use when running Fluent (tested only on single node so far). dimensions int Dimension used in flow solver: 2 for 2D and axisymmetric, 3 for 3D. delta_t double Fixed timestep size in flow solver. This parameter is usually specified in a higher Component . flow_iterations int Number of non-linear iterations in Fluent per coupling iteration. fluent_gui bool Set to true to run Fluent with the graphical interface. hybrid_initialization bool If true , the hybrid initialization is used in Fluent before the first timestep. If false , the standard initialization is used, which requires that adequate reference values have been set in advance by the user in the case_file . interface_input dict Keys are names of ModelParts for Fluent nodes. Each name must be the concatenation of an entry from thread_names and \"_nodes\". The values are (lists of) names of Variables . interface_output dict Analogous to interface_input , but for Fluent faces ('_faces'). max_nodes_per_face int This value is used to construct unique IDs for faces, based on unique IDs of nodes (provided by Fluent). It should be at least as high as the maximum number of nodes on a face on the interface. Use e.g. 4 for rectangular faces, 3 for triangular faces. save_iterations int Number of timesteps between consecutive saves of the Fluent case and data files. thread_names list List with Fluent names of the surface threads on the interface. IS THE ORDER IMPORTANT? TODO timestep_start int Timestep number to (re)start a transient FSI calculation. If 0 is given, the simulation starts from the case_file , else the code looks for the relevant case and data files. This parameter is usually specified in a higher Component . unsteady bool true for transient FSI, false for steady FSI. working_directory string Absolute path to the working directory or relative path w.r.t the current directory. timestep_start and delta_t are necessary parameters, but are usually defined in a higher Component . However, they can also be given directly as parameter of the solver-wrapper (e.g. for standalone testing). If they are defined both in a higher Component and in the solver-wrapper, then the former value is used and a warning is printed. If different parameters are used with different Fluent versions, this should be specified both in this section and in the version specific documentation section. Overview of operation The solver-wrapper consists of 3 files (with X the Fluent version, e.g. 2019R1 ): X.py : defines the SolverWrapperFluentX class X.jou : Fluent journal file to interactively run the FSI simulation, written in Scheme X.c : Fluent UDF file that implements additional functionality used in Fluent, written in C The __init__ method During initialization, the journal and UDF files are adapted (parameter values are filled in) and copied to the working_directory . Fluent is then started in that directory using the parameters cores , dimensions and fluent_gui . Fluent then writes a case summery, so that SolverWrapperFluentX can link the interface thread names (specified in thread_names ) to Fluent thread IDs, for use in the UDFs. Then the Model and ModelParts are created, based on data written by Fluent in timestep 0. After a restart, this same data must be found, i.e. if that file is removed from the folder working_directory , the simulation cannot be restarted. If the simulation was restarted, the coordinates X , Y , Z in the Nodes are updated to the current values. Finally, the Interfaces are made. Files created during simulation In the file conventions, A is the timestep number and B the Fluent thread ID. Fluent case and data files are saved as files of the form case_timestepA.cas and case_timestepA.dat . Current node and face coordinates are passed from Fluent to Python with files of the form nodes_timestepA_threadB.dat and faces_timestepA_threadB.dat . The new node coordinates are passed from Python to Fluent with files of the form nodes_update_timestepA_threadB . Pressure and tractions are passed from Fluent to Python with files of the form pressure_traction_timestepA_threadB.dat . Files with extension .coco are used to pass messages between Python and Fluent (via the journal). Setting up a new case Following items should be set up and saved in the case_file (this list may be non-exhaustive): additional UDFs must be configured steady/unsteady (should match with the unsteady parameter) 2D, 3D or axisymmetric (should match with the dimensions parameter) dynamic mesh for all zones, except the FSI interfaces boundary conditions, material properties, numerical models, discretization schemes, operating conditions, turbulence modeling, convergence criteria if hybrid_initialization is false , then defaults should be set for standard initialization Following items are taken care of by CoCoNuT, and must therefore not be included in the case_file : dynamic mesh for the FSI interfaces (which are defined in thread_names ) the timestep ( delta_t ) initialization of the solution field Version specific documentation 2019R1 (19.3) This is currently the only version, so this section is still empty.","title":"SolverWrapperFluent"},{"location":"fluent/#solverwrapperfluent","text":"This is the documentation for all Fluent solver-wrappers. Currently only FSI simulations are supported, no other multiphysics problems. Also, inviscid flows are not supported yet.","title":"SolverWrapperFluent"},{"location":"fluent/#parameters","text":"This section describes the parameters in the JSON file, listed in alphabetical order. parameter type description case_file string Name of the case file. It must be present in the folder working_directory . cores int Number of processor cores to use when running Fluent (tested only on single node so far). dimensions int Dimension used in flow solver: 2 for 2D and axisymmetric, 3 for 3D. delta_t double Fixed timestep size in flow solver. This parameter is usually specified in a higher Component . flow_iterations int Number of non-linear iterations in Fluent per coupling iteration. fluent_gui bool Set to true to run Fluent with the graphical interface. hybrid_initialization bool If true , the hybrid initialization is used in Fluent before the first timestep. If false , the standard initialization is used, which requires that adequate reference values have been set in advance by the user in the case_file . interface_input dict Keys are names of ModelParts for Fluent nodes. Each name must be the concatenation of an entry from thread_names and \"_nodes\". The values are (lists of) names of Variables . interface_output dict Analogous to interface_input , but for Fluent faces ('_faces'). max_nodes_per_face int This value is used to construct unique IDs for faces, based on unique IDs of nodes (provided by Fluent). It should be at least as high as the maximum number of nodes on a face on the interface. Use e.g. 4 for rectangular faces, 3 for triangular faces. save_iterations int Number of timesteps between consecutive saves of the Fluent case and data files. thread_names list List with Fluent names of the surface threads on the interface. IS THE ORDER IMPORTANT? TODO timestep_start int Timestep number to (re)start a transient FSI calculation. If 0 is given, the simulation starts from the case_file , else the code looks for the relevant case and data files. This parameter is usually specified in a higher Component . unsteady bool true for transient FSI, false for steady FSI. working_directory string Absolute path to the working directory or relative path w.r.t the current directory. timestep_start and delta_t are necessary parameters, but are usually defined in a higher Component . However, they can also be given directly as parameter of the solver-wrapper (e.g. for standalone testing). If they are defined both in a higher Component and in the solver-wrapper, then the former value is used and a warning is printed. If different parameters are used with different Fluent versions, this should be specified both in this section and in the version specific documentation section.","title":"Parameters"},{"location":"fluent/#overview-of-operation","text":"The solver-wrapper consists of 3 files (with X the Fluent version, e.g. 2019R1 ): X.py : defines the SolverWrapperFluentX class X.jou : Fluent journal file to interactively run the FSI simulation, written in Scheme X.c : Fluent UDF file that implements additional functionality used in Fluent, written in C","title":"Overview of operation"},{"location":"fluent/#the-__init__-method","text":"During initialization, the journal and UDF files are adapted (parameter values are filled in) and copied to the working_directory . Fluent is then started in that directory using the parameters cores , dimensions and fluent_gui . Fluent then writes a case summery, so that SolverWrapperFluentX can link the interface thread names (specified in thread_names ) to Fluent thread IDs, for use in the UDFs. Then the Model and ModelParts are created, based on data written by Fluent in timestep 0. After a restart, this same data must be found, i.e. if that file is removed from the folder working_directory , the simulation cannot be restarted. If the simulation was restarted, the coordinates X , Y , Z in the Nodes are updated to the current values. Finally, the Interfaces are made.","title":"The __init__ method"},{"location":"fluent/#files-created-during-simulation","text":"In the file conventions, A is the timestep number and B the Fluent thread ID. Fluent case and data files are saved as files of the form case_timestepA.cas and case_timestepA.dat . Current node and face coordinates are passed from Fluent to Python with files of the form nodes_timestepA_threadB.dat and faces_timestepA_threadB.dat . The new node coordinates are passed from Python to Fluent with files of the form nodes_update_timestepA_threadB . Pressure and tractions are passed from Fluent to Python with files of the form pressure_traction_timestepA_threadB.dat . Files with extension .coco are used to pass messages between Python and Fluent (via the journal).","title":"Files created during simulation"},{"location":"fluent/#setting-up-a-new-case","text":"Following items should be set up and saved in the case_file (this list may be non-exhaustive): additional UDFs must be configured steady/unsteady (should match with the unsteady parameter) 2D, 3D or axisymmetric (should match with the dimensions parameter) dynamic mesh for all zones, except the FSI interfaces boundary conditions, material properties, numerical models, discretization schemes, operating conditions, turbulence modeling, convergence criteria if hybrid_initialization is false , then defaults should be set for standard initialization Following items are taken care of by CoCoNuT, and must therefore not be included in the case_file : dynamic mesh for the FSI interfaces (which are defined in thread_names ) the timestep ( delta_t ) initialization of the solution field","title":"Setting up a new case"},{"location":"fluent/#version-specific-documentation","text":"","title":"Version specific documentation"},{"location":"fluent/#2019r1-193","text":"This is currently the only version, so this section is still empty.","title":"2019R1 (19.3)"},{"location":"mappers/","text":"Mappers General concepts Hierarchy of mapping-related objects CoCoNuT interacts with the mappers through the SolverWrapperMapped object. This solver-wrapper appears and behaves exactly the same as real solver-wrappers. It contains 3 Components : a mapper for the input, a real solver-wrapper and a mapper for the output. The mappers are initialized through the SetInterfaceInput and SetInterfaceOutput methods respectively, by providing them with the Interfaces that will be respectively the input and output of the SolverWrapperMapped object. The two mappers in the SolverWrapperMapped are also of a special type: they work on the level of Interfaces . They are some sort of mapper-wrapper around the actual mappers which work on ModelPart level. Currently only one such mapper is available, aptly called MapperInterface . At the lowest level, mappers interpolate historical variables between two ModelParts , based on the coordinates of the Nodes . Interpolation is always done from the from - ModelPart to the to - ModelPart . These mappers can be chained together in a MapperCombined mapper, creating in fact another layer of mapping. So many layers! Like an onion! Interpolators and transformers The ModelPart -level mappers have two main methods: Initialize and __call__ . The Initialize method performs one-time expensive operations, namely nearest-neighbour search and calculation of the interpolation coefficients. The initialization is done based on the original coordinates X0 , Y0 and Z0 . The __call__ method is used for the actual mapping. It takes two tuples as arguments ( from and to respectively), each tuple containing the ModelPart and the Variable to be used in the interpolation. This method returns nothing: the interpolation is done in-place in the ModelParts . There are two types of ModelPart -level mappers: interpolators and transformers . They can be distinguished by their boolean interpolator attribute (see __init__ ). For interpolators, Initialize gets two ModelPart objects ( from and to ), and returns nothing. These mappers do the real interpolation. Currently MapperNearest , MapperLinear and MapperRadialBasis are available. For transformers, Initialize gets only one ModelPart (from either the from or to side, depending on the transformation), and returns the other ModelPart . Currently MapperPermutation , MapperAxisymmetric2DTo3D and MapperAxisymmetric3DTo2D are available. A transformer can never be used by itself, it must always be combined with an interpolator: the reason is that interpolators use information coming from two sides, which is exactly what the SolverWrapperMapped and MapperInterface objects want. To chain together multiple mappers, the MapperCombined is used: it contains always 1 interpolator and 0 or more transformers, on either side of the interpolator. Overview of special mappers MapperInterface Special mapper-class that maps on the level of Interface objects. It takes two Interfaces , and maps the ModelParts to each other in order of appearance, all using the same ModelPart mapper. To use a different ModelPart mapper for the different ModelParts in the Interface , or even for the different historical variables, a new Interface mapper must be written. JSON setting type description type str ModelPart mapper to be used settings dict all the settings for the ModelPart mapper specified in type MapperCombined The MapperCombined is used to chain together multiple mappers. It contains always 1 interpolator and 0 or more transformers, on either side of the interpolator. If transformers are present, intermediate ModelParts are created during initialization. This is done by working inwards towards the interpolator. This means that transformers upstream of the interpolator, are initialized based on the from ModelPart (input), while downstream transformers are initialized based on the to ModelPart (output). Some transformers can only be initialized in one direction, e.g. for MapperAxisymmetric3DTo2D , the 2D to - ModelPart must be supplied, therefore it must be downstream of the interpolator. JSON setting type description mappers list an ordered list of all the ModelPart mappers to be used Overview of transformers MapperPermutation Permutates the coordinates and the vector variables according to the given permutation . This transformer can be initialized in both directions. JSON setting type description permutation list a permutation of the list [0, 1, 2] MapperAxisymmetric2DTo3D Transforms from a 2D axisymmetric geometry to a 3D geometry. This transformer can only be initialized in the forward direction, i.e. based on the 2D axisymmetric ModelPart . Therefore, it should be upstream of the interpolator in the MapperCombined . The 3D ModelPart is returned by the initialization. n_tangential specifies the number of Node objects in the tangential (circumferential) direction. For each Node in the 2D ModelPart , n_tangential Nodes are created in the 3D ModelPart . The code knows which directions are axial, radial and tangential thanks to the input parameters direction_axial and direction_radial . It is not possible to change the axial direction between 2D and 3D: a separate MapperPermutation should be added for that purpose. Scalar variables are simply mapped from the 2D Node to all corresponding 3D Nodes . For vector variables, the axial component is simply mapped, the radial component is rotated. The tangential component (e.g. swirl) cannot be taken into account. JSON setting type description direction_axial string must be \"X\" , \"Y\" or \"Z\" , specifies the symmetry axis direction_radial string must be \"X\" , \"Y\" or \"Z\" , specifies the second (radial) axis in 2D n_tangential int must be \u2265 6 MapperAxisymmetric3DTo2D Transforms from a 3D geometry to a 2D axisymmetric geometry. This transformer can only be initialized in the backward direction, i.e. based on the 2D axisymmetric ModelPart . Therefore, it should be downstream of the MapperInterpolator in the MapperCombined . For scalar variables, the circumferential average is taken for each 2D Node . For vector variables too, taking into account the correct radial direction in each 3D Node . Again, swirl cannot be taken into account: if a tangential component is present in 3D, it is not mapped to 2D. For more information and JSON settings, see MapperAxisymmetric2DTo3D which is very similar. Overview of interpolators MapperInterpolator Base-class for all interpolators (currently MapperNearest , MapperLinear and MapperRadialBasis ). JSON setting type description directions list list of coordinate directions, maximum three entries, may contain \"X\" , \"Y\" , \"Z\" balanced_tree bool if true , create balanced cKDTree , which is more stable, but takes longer to build; set to true if the tree is giving problems (which I don't expect) The Initialize method should be called in all child-classes. It does the following: read and store the coordinates from the from and to ModelParts check if the bounding boxes of the from and to ModelParts are more or less overlapping do an efficient nearest neighbour search using scipy.spatial.cKDTree check if the from ModelPart does not contain duplicate Nodes (i.e. with same coordinates) The __call__ method should not be overridden in the child-classes. It maps historical variables based on neighbours and coefficients determined in Initialize . Historical variables of type Double and type Array can be mapped (the latter is just the application of the former for each vector component). MapperNearest Child-class of MapperInterpolator , does not require additional settings. Does simple nearest-neighbour mapping. MapperLinear Child-class of MapperInterpolator , additional settings: JSON setting type description parallel bool if true , use multiprocessing to parallellize loop that calculates coefficients The kind of linear mapping depends on the number of coordinate directions, as given in the directions setting. 1D - If the to -point lies between the 2 nearest from -points, linear interpolation is done. Else, nearest neighbour interpolation is done. 2D - The to -point is first projected on the line through the 2 nearest from -points. If the projected point lies between the from -points, linear interpolation is done. Else, nearest neighbour interpolation is done. 3D - The to -point is first projected on the plane through the 3 nearest from -points. If the triangle consinsting of those 3 points is deprecated (colinear points), the 2D-methodology is followed. Else, if the projected point lies inside the triangle, barycentric interpolation is done. If it lies outside the triangle, the 2D-methodology is followed. MapperRadialBasis Child-class of MapperInterpolator , additional settings: JSON setting type description parallel bool if true , use multiprocessing to parallellize loop that calculates coefficients Radial basis function interpolation is relatively straightforward: implementation for 1D, 2D and 3D is exactly the same and can be written in a condensed way using scipy.spatial.distance . Normal radial basis interpolation is done as follows. \\phi(r) \\phi(r) is a radial basis function defined as \\phi(r) = \\begin{cases} (1-r)^4 (1 + 4r) \\quad &\\mathrm{for} \\quad 0 \\leq r < 1 \\\\ 0 &\\mathrm{for} \\quad 1 \\leq r \\end{cases} \\phi(r) = \\begin{cases} (1-r)^4 (1 + 4r) \\quad &\\mathrm{for} \\quad 0 \\leq r < 1 \\\\ 0 &\\mathrm{for} \\quad 1 \\leq r \\end{cases} with r r a positive distance. Assume that n n nearest from -points will be used in the interpolation. An unknown function f(\\boldsymbol{x}) f(\\boldsymbol{x}) can then be approximated as the weighted sum of n n shifted radial basis functions: f(\\boldsymbol{x}) = \\sum_j \\alpha_j \\phi(||\\boldsymbol{x} - \\boldsymbol{x}_j||) f(\\boldsymbol{x}) = \\sum_j \\alpha_j \\phi(||\\boldsymbol{x} - \\boldsymbol{x}_j||) To determine the coefficients \\alpha_j \\alpha_j , we require that the exact function value is returned at the n n from -points. This gives us n n equations f(\\boldsymbol{x}_i) = f_i = \\sum_j \\alpha_j \\phi(||\\boldsymbol{x}_i - \\boldsymbol{x}_j||) f(\\boldsymbol{x}_i) = f_i = \\sum_j \\alpha_j \\phi(||\\boldsymbol{x}_i - \\boldsymbol{x}_j||) which can be written in matrix form as \\boldsymbol{f} = \\boldsymbol{\\Phi} \\boldsymbol{\\alpha} \\boldsymbol{f} = \\boldsymbol{\\Phi} \\boldsymbol{\\alpha} with \\boldsymbol{f}, \\boldsymbol{\\alpha} \\in \\mathbb{R}^{n \\times 1} \\boldsymbol{f}, \\boldsymbol{\\alpha} \\in \\mathbb{R}^{n \\times 1} , and \\boldsymbol{\\Phi} \\in \\mathbb{R}^{n \\times n} \\boldsymbol{\\Phi} \\in \\mathbb{R}^{n \\times n} . This system can be solved for the weights-vector \\boldsymbol{\\alpha} \\boldsymbol{\\alpha} . However, in our case, the from -point values vector \\boldsymbol{f} \\boldsymbol{f} is not known in advance: it contains the values of the Variable that will be interpolated. Therefore, the approximation to calculate the interpolatoin in the to -point is rewritten as follows: f(\\boldsymbol{x}_{to}) = \\sum_j \\alpha_j \\phi(||\\boldsymbol{x}_{to} - \\boldsymbol{x}_j||) = \\boldsymbol{\\Phi}_{to}^T \\boldsymbol{\\alpha} = \\boldsymbol{\\Phi}_{to}^T \\boldsymbol{\\Phi}^{-1} \\boldsymbol{f} = \\boldsymbol{c}^T \\boldsymbol{f} f(\\boldsymbol{x}_{to}) = \\sum_j \\alpha_j \\phi(||\\boldsymbol{x}_{to} - \\boldsymbol{x}_j||) = \\boldsymbol{\\Phi}_{to}^T \\boldsymbol{\\alpha} = \\boldsymbol{\\Phi}_{to}^T \\boldsymbol{\\Phi}^{-1} \\boldsymbol{f} = \\boldsymbol{c}^T \\boldsymbol{f} The coefficients vector \\boldsymbol{c} \\boldsymbol{c} can now be calculated based only on the coordinates by solving the system \\boldsymbol{\\Phi} \\ \\boldsymbol{c} = \\boldsymbol{\\Phi}_{to}. \\boldsymbol{\\Phi} \\ \\boldsymbol{c} = \\boldsymbol{\\Phi}_{to}. As every to-point has different nearest neighbours in the from -points, the coefficient vector \\boldsymbol{c} \\boldsymbol{c} must be calculated for each to -point independently. The matrix \\boldsymbol{\\Phi} \\boldsymbol{\\Phi} and vector \\boldsymbol{\\Phi}_{to} \\boldsymbol{\\Phi}_{to} must also be calculated for every to -point independently.","title":"Mappers"},{"location":"mappers/#mappers","text":"","title":"Mappers"},{"location":"mappers/#general-concepts","text":"","title":"General concepts"},{"location":"mappers/#hierarchy-of-mapping-related-objects","text":"CoCoNuT interacts with the mappers through the SolverWrapperMapped object. This solver-wrapper appears and behaves exactly the same as real solver-wrappers. It contains 3 Components : a mapper for the input, a real solver-wrapper and a mapper for the output. The mappers are initialized through the SetInterfaceInput and SetInterfaceOutput methods respectively, by providing them with the Interfaces that will be respectively the input and output of the SolverWrapperMapped object. The two mappers in the SolverWrapperMapped are also of a special type: they work on the level of Interfaces . They are some sort of mapper-wrapper around the actual mappers which work on ModelPart level. Currently only one such mapper is available, aptly called MapperInterface . At the lowest level, mappers interpolate historical variables between two ModelParts , based on the coordinates of the Nodes . Interpolation is always done from the from - ModelPart to the to - ModelPart . These mappers can be chained together in a MapperCombined mapper, creating in fact another layer of mapping. So many layers! Like an onion!","title":"Hierarchy of mapping-related objects"},{"location":"mappers/#interpolators-and-transformers","text":"The ModelPart -level mappers have two main methods: Initialize and __call__ . The Initialize method performs one-time expensive operations, namely nearest-neighbour search and calculation of the interpolation coefficients. The initialization is done based on the original coordinates X0 , Y0 and Z0 . The __call__ method is used for the actual mapping. It takes two tuples as arguments ( from and to respectively), each tuple containing the ModelPart and the Variable to be used in the interpolation. This method returns nothing: the interpolation is done in-place in the ModelParts . There are two types of ModelPart -level mappers: interpolators and transformers . They can be distinguished by their boolean interpolator attribute (see __init__ ). For interpolators, Initialize gets two ModelPart objects ( from and to ), and returns nothing. These mappers do the real interpolation. Currently MapperNearest , MapperLinear and MapperRadialBasis are available. For transformers, Initialize gets only one ModelPart (from either the from or to side, depending on the transformation), and returns the other ModelPart . Currently MapperPermutation , MapperAxisymmetric2DTo3D and MapperAxisymmetric3DTo2D are available. A transformer can never be used by itself, it must always be combined with an interpolator: the reason is that interpolators use information coming from two sides, which is exactly what the SolverWrapperMapped and MapperInterface objects want. To chain together multiple mappers, the MapperCombined is used: it contains always 1 interpolator and 0 or more transformers, on either side of the interpolator.","title":"Interpolators and transformers"},{"location":"mappers/#overview-of-special-mappers","text":"","title":"Overview of special mappers"},{"location":"mappers/#mapperinterface","text":"Special mapper-class that maps on the level of Interface objects. It takes two Interfaces , and maps the ModelParts to each other in order of appearance, all using the same ModelPart mapper. To use a different ModelPart mapper for the different ModelParts in the Interface , or even for the different historical variables, a new Interface mapper must be written. JSON setting type description type str ModelPart mapper to be used settings dict all the settings for the ModelPart mapper specified in type","title":"MapperInterface"},{"location":"mappers/#mappercombined","text":"The MapperCombined is used to chain together multiple mappers. It contains always 1 interpolator and 0 or more transformers, on either side of the interpolator. If transformers are present, intermediate ModelParts are created during initialization. This is done by working inwards towards the interpolator. This means that transformers upstream of the interpolator, are initialized based on the from ModelPart (input), while downstream transformers are initialized based on the to ModelPart (output). Some transformers can only be initialized in one direction, e.g. for MapperAxisymmetric3DTo2D , the 2D to - ModelPart must be supplied, therefore it must be downstream of the interpolator. JSON setting type description mappers list an ordered list of all the ModelPart mappers to be used","title":"MapperCombined"},{"location":"mappers/#overview-of-transformers","text":"","title":"Overview of transformers"},{"location":"mappers/#mapperpermutation","text":"Permutates the coordinates and the vector variables according to the given permutation . This transformer can be initialized in both directions. JSON setting type description permutation list a permutation of the list [0, 1, 2]","title":"MapperPermutation"},{"location":"mappers/#mapperaxisymmetric2dto3d","text":"Transforms from a 2D axisymmetric geometry to a 3D geometry. This transformer can only be initialized in the forward direction, i.e. based on the 2D axisymmetric ModelPart . Therefore, it should be upstream of the interpolator in the MapperCombined . The 3D ModelPart is returned by the initialization. n_tangential specifies the number of Node objects in the tangential (circumferential) direction. For each Node in the 2D ModelPart , n_tangential Nodes are created in the 3D ModelPart . The code knows which directions are axial, radial and tangential thanks to the input parameters direction_axial and direction_radial . It is not possible to change the axial direction between 2D and 3D: a separate MapperPermutation should be added for that purpose. Scalar variables are simply mapped from the 2D Node to all corresponding 3D Nodes . For vector variables, the axial component is simply mapped, the radial component is rotated. The tangential component (e.g. swirl) cannot be taken into account. JSON setting type description direction_axial string must be \"X\" , \"Y\" or \"Z\" , specifies the symmetry axis direction_radial string must be \"X\" , \"Y\" or \"Z\" , specifies the second (radial) axis in 2D n_tangential int must be \u2265 6","title":"MapperAxisymmetric2DTo3D"},{"location":"mappers/#mapperaxisymmetric3dto2d","text":"Transforms from a 3D geometry to a 2D axisymmetric geometry. This transformer can only be initialized in the backward direction, i.e. based on the 2D axisymmetric ModelPart . Therefore, it should be downstream of the MapperInterpolator in the MapperCombined . For scalar variables, the circumferential average is taken for each 2D Node . For vector variables too, taking into account the correct radial direction in each 3D Node . Again, swirl cannot be taken into account: if a tangential component is present in 3D, it is not mapped to 2D. For more information and JSON settings, see MapperAxisymmetric2DTo3D which is very similar.","title":"MapperAxisymmetric3DTo2D"},{"location":"mappers/#overview-of-interpolators","text":"","title":"Overview of interpolators"},{"location":"mappers/#mapperinterpolator","text":"Base-class for all interpolators (currently MapperNearest , MapperLinear and MapperRadialBasis ). JSON setting type description directions list list of coordinate directions, maximum three entries, may contain \"X\" , \"Y\" , \"Z\" balanced_tree bool if true , create balanced cKDTree , which is more stable, but takes longer to build; set to true if the tree is giving problems (which I don't expect) The Initialize method should be called in all child-classes. It does the following: read and store the coordinates from the from and to ModelParts check if the bounding boxes of the from and to ModelParts are more or less overlapping do an efficient nearest neighbour search using scipy.spatial.cKDTree check if the from ModelPart does not contain duplicate Nodes (i.e. with same coordinates) The __call__ method should not be overridden in the child-classes. It maps historical variables based on neighbours and coefficients determined in Initialize . Historical variables of type Double and type Array can be mapped (the latter is just the application of the former for each vector component).","title":"MapperInterpolator"},{"location":"mappers/#mappernearest","text":"Child-class of MapperInterpolator , does not require additional settings. Does simple nearest-neighbour mapping.","title":"MapperNearest"},{"location":"mappers/#mapperlinear","text":"Child-class of MapperInterpolator , additional settings: JSON setting type description parallel bool if true , use multiprocessing to parallellize loop that calculates coefficients The kind of linear mapping depends on the number of coordinate directions, as given in the directions setting. 1D - If the to -point lies between the 2 nearest from -points, linear interpolation is done. Else, nearest neighbour interpolation is done. 2D - The to -point is first projected on the line through the 2 nearest from -points. If the projected point lies between the from -points, linear interpolation is done. Else, nearest neighbour interpolation is done. 3D - The to -point is first projected on the plane through the 3 nearest from -points. If the triangle consinsting of those 3 points is deprecated (colinear points), the 2D-methodology is followed. Else, if the projected point lies inside the triangle, barycentric interpolation is done. If it lies outside the triangle, the 2D-methodology is followed.","title":"MapperLinear"},{"location":"mappers/#mapperradialbasis","text":"Child-class of MapperInterpolator , additional settings: JSON setting type description parallel bool if true , use multiprocessing to parallellize loop that calculates coefficients Radial basis function interpolation is relatively straightforward: implementation for 1D, 2D and 3D is exactly the same and can be written in a condensed way using scipy.spatial.distance . Normal radial basis interpolation is done as follows. \\phi(r) \\phi(r) is a radial basis function defined as \\phi(r) = \\begin{cases} (1-r)^4 (1 + 4r) \\quad &\\mathrm{for} \\quad 0 \\leq r < 1 \\\\ 0 &\\mathrm{for} \\quad 1 \\leq r \\end{cases} \\phi(r) = \\begin{cases} (1-r)^4 (1 + 4r) \\quad &\\mathrm{for} \\quad 0 \\leq r < 1 \\\\ 0 &\\mathrm{for} \\quad 1 \\leq r \\end{cases} with r r a positive distance. Assume that n n nearest from -points will be used in the interpolation. An unknown function f(\\boldsymbol{x}) f(\\boldsymbol{x}) can then be approximated as the weighted sum of n n shifted radial basis functions: f(\\boldsymbol{x}) = \\sum_j \\alpha_j \\phi(||\\boldsymbol{x} - \\boldsymbol{x}_j||) f(\\boldsymbol{x}) = \\sum_j \\alpha_j \\phi(||\\boldsymbol{x} - \\boldsymbol{x}_j||) To determine the coefficients \\alpha_j \\alpha_j , we require that the exact function value is returned at the n n from -points. This gives us n n equations f(\\boldsymbol{x}_i) = f_i = \\sum_j \\alpha_j \\phi(||\\boldsymbol{x}_i - \\boldsymbol{x}_j||) f(\\boldsymbol{x}_i) = f_i = \\sum_j \\alpha_j \\phi(||\\boldsymbol{x}_i - \\boldsymbol{x}_j||) which can be written in matrix form as \\boldsymbol{f} = \\boldsymbol{\\Phi} \\boldsymbol{\\alpha} \\boldsymbol{f} = \\boldsymbol{\\Phi} \\boldsymbol{\\alpha} with \\boldsymbol{f}, \\boldsymbol{\\alpha} \\in \\mathbb{R}^{n \\times 1} \\boldsymbol{f}, \\boldsymbol{\\alpha} \\in \\mathbb{R}^{n \\times 1} , and \\boldsymbol{\\Phi} \\in \\mathbb{R}^{n \\times n} \\boldsymbol{\\Phi} \\in \\mathbb{R}^{n \\times n} . This system can be solved for the weights-vector \\boldsymbol{\\alpha} \\boldsymbol{\\alpha} . However, in our case, the from -point values vector \\boldsymbol{f} \\boldsymbol{f} is not known in advance: it contains the values of the Variable that will be interpolated. Therefore, the approximation to calculate the interpolatoin in the to -point is rewritten as follows: f(\\boldsymbol{x}_{to}) = \\sum_j \\alpha_j \\phi(||\\boldsymbol{x}_{to} - \\boldsymbol{x}_j||) = \\boldsymbol{\\Phi}_{to}^T \\boldsymbol{\\alpha} = \\boldsymbol{\\Phi}_{to}^T \\boldsymbol{\\Phi}^{-1} \\boldsymbol{f} = \\boldsymbol{c}^T \\boldsymbol{f} f(\\boldsymbol{x}_{to}) = \\sum_j \\alpha_j \\phi(||\\boldsymbol{x}_{to} - \\boldsymbol{x}_j||) = \\boldsymbol{\\Phi}_{to}^T \\boldsymbol{\\alpha} = \\boldsymbol{\\Phi}_{to}^T \\boldsymbol{\\Phi}^{-1} \\boldsymbol{f} = \\boldsymbol{c}^T \\boldsymbol{f} The coefficients vector \\boldsymbol{c} \\boldsymbol{c} can now be calculated based only on the coordinates by solving the system \\boldsymbol{\\Phi} \\ \\boldsymbol{c} = \\boldsymbol{\\Phi}_{to}. \\boldsymbol{\\Phi} \\ \\boldsymbol{c} = \\boldsymbol{\\Phi}_{to}. As every to-point has different nearest neighbours in the from -points, the coefficient vector \\boldsymbol{c} \\boldsymbol{c} must be calculated for each to -point independently. The matrix \\boldsymbol{\\Phi} \\boldsymbol{\\Phi} and vector \\boldsymbol{\\Phi}_{to} \\boldsymbol{\\Phi}_{to} must also be calculated for every to -point independently.","title":"MapperRadialBasis"},{"location":"models/","text":"Models This documentation describes the models which are available. These models always approximate a (inverse) Jacobian, denoted here by J J . Receiving an input, called \\Delta x \\Delta x , they return an estimation of J\\Delta x=\\Delta r J\\Delta x=\\Delta r . In order to improve the estimation, information is added, when it becomes available. This information consists of pairs of calculated differences \\Delta x \\Delta x and \\Delta r \\Delta r . The different models use this information in a different way. LS The abbreviation LS stands for least-squares . This model requires the approximation of J J , to fulfill the secant equations of the current and q previous time steps. Moreover, it is required that the approximation is least-squares. This model is matrix-free, due to an implementation using QR-decomposition. With matrix-free is meant that no large dense matrices are constructed, not that no matrices are used at all. The optimal value of q is problem dependent. Typically however, an optimal value is around 10. The R R matrix from the QR-decompostion has to be invertible. Therefore, (almost) linear columns in the matrix containing the input information from the current and previous time steps should be removed. This is called filtering. The larger q , the more important filtering becomes. If the diagonal element in R R is smaller than an absolute tolerance level, the corresponding column is removed. The most recent information is kept. For more information refer to . Settings The following parameters need to be included in the settings dictionary. They are listed in alphabetical order. parameter type description min_significant double Absolute tolerance for filtering. q int Number of previous time steps that are reused. In a steady simulation there are no previous time steps, so then it should be 0. MV The abbreviation MV stands for multi-vector . not matrix free, not for large number of degrees of freedom on the interface. This model requires the approximation of J J , to fulfill the secant equations of the current time step only. Moreover, it is required that the approximation is as close as possible to the previous time step. In this model large dense matrices are constructed and is hence discouraged for cases with a large number of degrees of freedom on the interface. Here filtering can also be applied. Then, (almost) linear columns in the matrix containing the input information from the current time step are removed. If the diagonal element in R R is smaller than an absolute tolerance level, the corresponding column is removed. The most recent information is kept. However, filtering is much less critical compared to the LS model as it concerns only the information from th current time step. If no filtering is wanted, the tolerance level should be set to zero. For more infromation refer to . Settings The following parameters need to be included in the settings dictionary. They are listed in alphabetical order. parameter type description min_significant double Absolute tolerance for filtering. MV-MF The abbreviation MV-MF stands for multi-vector matrix-free . This method implements the multi-vector method, but in a matrix-free way. Therefore, a parameter q is used to denote how many time steps are re-used. Setting this parameter very large, this model will act the same as MV , which reuses all time steps. Settings The following parameters need to be included in the settings dictionary. They are listed in alphabetical order. parameter type description min_significant double Absolute tolerance for filtering. q int Number of previous time steps that are reused. In a steady simulation there are no previous time steps, so then it should be 0.","title":"Models"},{"location":"models/#models","text":"This documentation describes the models which are available. These models always approximate a (inverse) Jacobian, denoted here by J J . Receiving an input, called \\Delta x \\Delta x , they return an estimation of J\\Delta x=\\Delta r J\\Delta x=\\Delta r . In order to improve the estimation, information is added, when it becomes available. This information consists of pairs of calculated differences \\Delta x \\Delta x and \\Delta r \\Delta r . The different models use this information in a different way.","title":"Models"},{"location":"models/#ls","text":"The abbreviation LS stands for least-squares . This model requires the approximation of J J , to fulfill the secant equations of the current and q previous time steps. Moreover, it is required that the approximation is least-squares. This model is matrix-free, due to an implementation using QR-decomposition. With matrix-free is meant that no large dense matrices are constructed, not that no matrices are used at all. The optimal value of q is problem dependent. Typically however, an optimal value is around 10. The R R matrix from the QR-decompostion has to be invertible. Therefore, (almost) linear columns in the matrix containing the input information from the current and previous time steps should be removed. This is called filtering. The larger q , the more important filtering becomes. If the diagonal element in R R is smaller than an absolute tolerance level, the corresponding column is removed. The most recent information is kept. For more information refer to .","title":"LS"},{"location":"models/#settings","text":"The following parameters need to be included in the settings dictionary. They are listed in alphabetical order. parameter type description min_significant double Absolute tolerance for filtering. q int Number of previous time steps that are reused. In a steady simulation there are no previous time steps, so then it should be 0.","title":"Settings"},{"location":"models/#mv","text":"The abbreviation MV stands for multi-vector . not matrix free, not for large number of degrees of freedom on the interface. This model requires the approximation of J J , to fulfill the secant equations of the current time step only. Moreover, it is required that the approximation is as close as possible to the previous time step. In this model large dense matrices are constructed and is hence discouraged for cases with a large number of degrees of freedom on the interface. Here filtering can also be applied. Then, (almost) linear columns in the matrix containing the input information from the current time step are removed. If the diagonal element in R R is smaller than an absolute tolerance level, the corresponding column is removed. The most recent information is kept. However, filtering is much less critical compared to the LS model as it concerns only the information from th current time step. If no filtering is wanted, the tolerance level should be set to zero. For more infromation refer to .","title":"MV"},{"location":"models/#settings_1","text":"The following parameters need to be included in the settings dictionary. They are listed in alphabetical order. parameter type description min_significant double Absolute tolerance for filtering.","title":"Settings"},{"location":"models/#mv-mf","text":"The abbreviation MV-MF stands for multi-vector matrix-free . This method implements the multi-vector method, but in a matrix-free way. Therefore, a parameter q is used to denote how many time steps are re-used. Setting this parameter very large, this model will act the same as MV , which reuses all time steps.","title":"MV-MF"},{"location":"models/#settings_2","text":"The following parameters need to be included in the settings dictionary. They are listed in alphabetical order. parameter type description min_significant double Absolute tolerance for filtering. q int Number of previous time steps that are reused. In a steady simulation there are no previous time steps, so then it should be 0.","title":"Settings"},{"location":"predictors/","text":"Predictors This documentation describes the available predictors. A predictor is used to determine the initial guess in each time step by extrapolating the solution from previous time steps. The different predictors differ in the number of previous iterations they take into account and the polynomial degree that is used. Only the type has to be provided, no settings dictionary is required. Specification of a predictor is mandatory, also for a steady simulation. In that case however, it does not matter which predictor is chosen as only 1 \"time step\" is performed. Linear This predictor uses the results from the last two time steps to determine the initial guess in the current time step using a linear extrapolation as follows $$ x^{n+1}=2x^{n}-1x^{n-1}. $$ If no two previous solutions are available, the solution from the last time step is used. Legacy This predictor uses the results from the last three time steps to determine the initial guess in the current time step using a linear extrapolation as follows $$ x^{n+1}=\\frac{5}{2}x^{n}-2x^{n-1}+\\frac{1}{2}x^{n-2}. $$ If no three previous solutions are available, the predictor linear is used. This predictor is called legacy as it corresponds to the 2nd order extrapolator in the coupling code Tango. Quadratic This predictor uses the results from the last three time steps to determine the initial guess in the current time step using a quadratic extrapolation as follows $$ x^{n+1}=3x^{n}-3x^{n-1}+1x^{n-2}. $$ If no three previous solutions are available, the predictor linear is used. Cubic This predictor uses the results from the last three time steps to determine the initial guess in the current time step using a cubic extrapolation as follows $$ x^{n+1}=4x^{n}-6x^{n-1}+4x^{n-2}-1x^{n-3}. $$ If no four previous solutions are available, the predictor quadratic is used.","title":"Predictors"},{"location":"predictors/#predictors","text":"This documentation describes the available predictors. A predictor is used to determine the initial guess in each time step by extrapolating the solution from previous time steps. The different predictors differ in the number of previous iterations they take into account and the polynomial degree that is used. Only the type has to be provided, no settings dictionary is required. Specification of a predictor is mandatory, also for a steady simulation. In that case however, it does not matter which predictor is chosen as only 1 \"time step\" is performed.","title":"Predictors"},{"location":"predictors/#linear","text":"This predictor uses the results from the last two time steps to determine the initial guess in the current time step using a linear extrapolation as follows $$ x^{n+1}=2x^{n}-1x^{n-1}. $$ If no two previous solutions are available, the solution from the last time step is used.","title":"Linear"},{"location":"predictors/#legacy","text":"This predictor uses the results from the last three time steps to determine the initial guess in the current time step using a linear extrapolation as follows $$ x^{n+1}=\\frac{5}{2}x^{n}-2x^{n-1}+\\frac{1}{2}x^{n-2}. $$ If no three previous solutions are available, the predictor linear is used. This predictor is called legacy as it corresponds to the 2nd order extrapolator in the coupling code Tango.","title":"Legacy"},{"location":"predictors/#quadratic","text":"This predictor uses the results from the last three time steps to determine the initial guess in the current time step using a quadratic extrapolation as follows $$ x^{n+1}=3x^{n}-3x^{n-1}+1x^{n-2}. $$ If no three previous solutions are available, the predictor linear is used.","title":"Quadratic"},{"location":"predictors/#cubic","text":"This predictor uses the results from the last three time steps to determine the initial guess in the current time step using a cubic extrapolation as follows $$ x^{n+1}=4x^{n}-6x^{n-1}+4x^{n-2}-1x^{n-3}. $$ If no four previous solutions are available, the predictor quadratic is used.","title":"Cubic"},{"location":"python/","text":"SolverWrapperPython This is the documentation for all Python SolverWrappers. Currently only solvers exist for the 1D calculation of a straight flexible tube. Tube There are three tube solvers for a straight tube with circular cross-section. The axial direction is along the z-axis. All of them are 1D solvers. This means the tube is divided in m intervals in the axial z-direction and only variations in that direction are taken into account. In other words, all variables are uniform over a cross-section. They are calculated in the center of each of the m cells. There is one flow solver (TubeFlow) and two structure solvers, one with inertia (TubeStructure) and one without (TubeRingmodel). Settings The following parameters, listed in alphabetical order, need to be provided in the JSON parameter file as setttings of the solver wrapper. parameter type description delta_t double Fixed time step size in flow solver. This parameter is usually specified in a higher Component. input_file string Name of the input file, which must be present in the folder working_directory . The file contains all parameters required for the solver, in JSON-format. interface_input dict Keys are names of ModelParts. The values are (lists of) names of Variables. For a flow solver: \"DISPLACEMENT\" . For a structure solver: [\"PRESSURE\",\"TRACTION\"] . interface_output dict Analogous to interface_input , but for the flow solver output. For a flow solver: [\"PRESSURE\",\"TRACTION\"] . For a structure solver: \"DISPLACEMENT\" . working_directory string Absolute path to the working directory or relative path w.r.t the current directory. delta_t is a necessary parameter, but is usually defined in a higher Component. However, it can also be given directly as parameter of the solver wrapper (e.g. for standalone testing). If it is defined both in higher Component and in the solver wrapper, then the former value is used and a warning is printed. If no intepolation is applied, the names of the ModelParts of both flow and structure solver need to be the same. There is no parameter timestep_start , as currently, restart is not implemented in this solver wrapper. TubeFlow This flow solver calculates the flow inside a 1D straight and flexible tube. The required input is the radial displacement of the tube wall. The resulting output is the pressure on the tube wall. From the radial displacements the area of each cross-section is calculated. The flow is governed by the continuity and momentum equation $$ \\frac{\\partial a}{\\partial t}+\\frac{\\partial av}{\\partial z}=0 $$ $$ \\frac{\\partial av}{\\partial t}+\\frac{\\partial av^2}{\\partial z}+\\frac{1}{\\rho_f}\\left(\\frac{\\partial ap}{\\partial z}-p\\frac{\\partial a}{\\partial z}\\right)=0 $$ with a=\\pi r^2 a=\\pi r^2 the cross-sectional area of the tube and r r the inner radius. Furthermore, t t is the time, v v the velocity along the axis of the tube, p p the pressure and \\rho_f \\rho_f the density of the fluid. Add the start and end of the tube the boundary conditions have to be applied. Discretizing these equations results in a system of linear algebraic equations which can be solved for the pressure and velocity by performing Newton-Raphson iterations. Inside the solver the kinematic pressure is used, which is the pressure divided by the density of the fluid. For more information about the implementation this solver refer to . Solver parameters The following parameters, listed in alphabetical order, need to be specified in a file with name input_file . This file should be located in the working_directory . Care should be taken that the values of d , e , h , l and rhof match the corresponding values of the structural solver. parameter type description axial_offset double (optional) Distance over which tube is displaced axially in the coordinate system. If not provided, the value of this parameter is 0. d double Nominal diameter of the tube. e double Modulus of elasticity of the tube wall. h double Thickness of tube wall. inlet_boundary dict Dictionary containing all information with respect to the inlet boundary condition. l double Length of the tube. m int Number of cells for discretization. The values are calculated in the cell centers. newtonmax double Maximum number of Newton-Raphson iterations for the flow solver calculation. newtontol double Relative tolerance for the Newton-Raphson iterations for the flow solver calculation. outlet_boundary dict Dictionary containing all information with respect to the outlet boundary condition. preference double (optional) Reference pressure. If not provided, the value of this parameter is 0. ureference double Reference velocity. rhof double Density of the fluid. Inlet Boundary This section describes all parameters that need to be specified in the dictionary inlet_boundary , listed in alphabetical order. parameter type description amplitude double Amplitude of the inlet boundary condition. period double Period of the inlet boundary condition. Period of oscillation for a periodic boundary condition, duration for a non-periodic boundary condition. reference double (optional) Reference value of inlet boundary condition. If not provided, the value of this parameter is the corresponding reference value provided above, i.e. ureference or preference . type int Type of inlet boundary condition. If 1, a sine wave is used with amplitude, reference and period as specified. If 2, a pulse is used with amplitude as specified and a duration equal to the parameter period. After the pulse the variable is equal to the reference value. If 3, a quadratic sine wave is used with amplitude, reference and period as specified. If other, a steady increase of the value at the inlet with slope of amplitude divided by period is used. variable string Variable upon which the inlet boundary condition is definded, either 'pressure' or 'velocity'. Outlet Boundary This section describes all parameters that need to be specified in the dictionary outlet_boundary , listed in alphabetical order. parameter type description type int Type of outlet boundary condition. If 1, a non-reflecting boundary condition is applied. If other, a fixed value equal to the reference pressure is applied. TubeRingModel This structure solver calculates the deformation of the wall of a straight and flexible tube. The tube is regarded as made up of independent rings. The required input is the pressure on the tube wall. The resulting output is the radial displacement. The behaviour of the elastic tube wall is described by a Hookean relation, which results in the following equation $$ a=a_0\\left(\\frac{p_0-2c^2_{MK}}{p_0-2c^2_{MK}}\\right)^2 $$ with a=\\pi r^2 a=\\pi r^2 the cross-sectional area of the tube and r r the inner radius. Furthermore, p p the pressure, p_0 p_0 the reference pressure, \\rho_f \\rho_f the density of the fluid and c^2_{MK} c^2_{MK} the Moens-Korteweg wave speed given by $$ c^2_{MK}=\\sqrt{\\frac{Eh}{2\\rho_f r_0}} $$ Here, E E is the modulus of elasticity, h h the thickness of the tube wall and r_0 r_0 the reference radius. No boundary conditions are required. Inside the solver the kinematic pressure is used, which is the pressure divided by the density of the fluid. For more information about the implementation this solver refer to . Solver parameters The following parameters, listed in alphabetical order, need to be specified in a file with name input_file . This file should be located in the working_directory . Care should be taken that the values of d , e , h , l and rhof match the corresponding values of the flow solver. parameter type description axial_offset double (optional) Distance over which tube is displaced axially in the coordinate system. If not provided, the value of this parameter is 0. d double Nominal diameter of the tube. e double Modulus of elasticity of the tube wall. h double Thickness of tube wall. l double Length of the tube. m int Number of cells for discretization. The values are calculated in the cell centers. preference double (optional) Reference pressure. If not provided, the value of this parameter is 0. rhof double Density of the fluid. TubeStructure This structure solver calculates the deformation of the wall of a straight and flexible tube. In this model inertia is taken into account, but still only radial displacements are considered. The required input is the pressure on the tube wall. The resulting output is the radial displacement. The deformation of the tube in the radial direction is determined by $$ \\rho_s h\\frac{\\partial^2 r}{\\partial t^2}+b_1\\frac{\\partial^4 r}{\\partial z^4}-b_2\\frac{\\partial^2 r}{\\partial z^2}+b_3(r-r_o)=p-p_o $$ with \\rho_s \\rho_s the solid density and h h the thickness of the tube's wall. Further, r r is the inner radius, p p pressure and t t time. The variables r_0 r_0 and p_0 p_0 are a reference radius and pressure, respectively. The tube is considered clamped at both ends. The parameters b_1 b_1 and b_2 b_2 ( b_1, b_2 \\ge 0 b_1, b_2 \\ge 0 ) account for the inner action of the bending and the axial tension in the wall, while the parameter b_3 b_3 accounts for the circumferential stress in the tube wall. For a thin-walled tube that is clamped in the axial direction, they are defined as $$ b_1=\\frac{hE}{1-\\nu^2}\\frac{h^2}{12} \\textrm{, } b_2=\\frac{hE}{1-\\nu^2}\\frac{h^2}{12}\\frac{2\\nu}{r_o^2} \\textrm{ and } b_3=\\frac{hE}{1-\\nu^2}\\frac{1}{r_o^2}+\\frac{hE}{1-\\nu^2}\\frac{h^2}{12}\\frac{1}{r_o^4} $$ with E E the Young's modulus and \\nu \\nu Poisson's coefficient. The second term of b_3 b_3 is considered small compared to the first one because h\\ll r_o h\\ll r_o and is thus neglected. Discretizing these equations results in a system of linear algebraic equations whit a Jacobian that does not depend on the pressure. The system can be solved for the radius in one step. For more information about the implementation this solver refer to . Solver parameters The following parameters, listed in alphabetical order, need to be specified in a file with name input_file .This file should be located in the working_directory . Care should be taken that the values of d , e , h , l and rhof match the corresponding values of the flow solver. parameter type description axial_offset double (optional) Distance over which tube is displaced axially in the coordinate system. If not provided, the value of this parameter is 0. beta double Newmark parameter \\beta \\beta d double Nominal diameter of the tube. e double Modulus of elasticity of the tube wall. h double Thickness of tube wall. gamma double Newmark parameter \\gamma \\gamma . l double Length of the tube. m int Number of cells for discretization. The values are calculated in the cell centers. nu double Poisson's ratio. preference double (optional) Reference pressure. If not provided, the value of this parameter is 0. rhof double Density of the fluid. rhos double Density of the tube wall. The equations are discretized in time with the Newmark method. These require two Newmark parameters \\beta \\beta and \\gamma \\gamma which result in an un-conditionally stable integration scheme if $$ \\gamma\\geq\\frac{1}{2} \\textrm{ and } \\beta\\geq\\frac{1}{4}\\left(\\frac{1}{2}+\\gamma\\right)^2. $$","title":"SolverWrapperPython"},{"location":"python/#solverwrapperpython","text":"This is the documentation for all Python SolverWrappers. Currently only solvers exist for the 1D calculation of a straight flexible tube.","title":"SolverWrapperPython"},{"location":"python/#tube","text":"There are three tube solvers for a straight tube with circular cross-section. The axial direction is along the z-axis. All of them are 1D solvers. This means the tube is divided in m intervals in the axial z-direction and only variations in that direction are taken into account. In other words, all variables are uniform over a cross-section. They are calculated in the center of each of the m cells. There is one flow solver (TubeFlow) and two structure solvers, one with inertia (TubeStructure) and one without (TubeRingmodel).","title":"Tube"},{"location":"python/#settings","text":"The following parameters, listed in alphabetical order, need to be provided in the JSON parameter file as setttings of the solver wrapper. parameter type description delta_t double Fixed time step size in flow solver. This parameter is usually specified in a higher Component. input_file string Name of the input file, which must be present in the folder working_directory . The file contains all parameters required for the solver, in JSON-format. interface_input dict Keys are names of ModelParts. The values are (lists of) names of Variables. For a flow solver: \"DISPLACEMENT\" . For a structure solver: [\"PRESSURE\",\"TRACTION\"] . interface_output dict Analogous to interface_input , but for the flow solver output. For a flow solver: [\"PRESSURE\",\"TRACTION\"] . For a structure solver: \"DISPLACEMENT\" . working_directory string Absolute path to the working directory or relative path w.r.t the current directory. delta_t is a necessary parameter, but is usually defined in a higher Component. However, it can also be given directly as parameter of the solver wrapper (e.g. for standalone testing). If it is defined both in higher Component and in the solver wrapper, then the former value is used and a warning is printed. If no intepolation is applied, the names of the ModelParts of both flow and structure solver need to be the same. There is no parameter timestep_start , as currently, restart is not implemented in this solver wrapper.","title":"Settings"},{"location":"python/#tubeflow","text":"This flow solver calculates the flow inside a 1D straight and flexible tube. The required input is the radial displacement of the tube wall. The resulting output is the pressure on the tube wall. From the radial displacements the area of each cross-section is calculated. The flow is governed by the continuity and momentum equation $$ \\frac{\\partial a}{\\partial t}+\\frac{\\partial av}{\\partial z}=0 $$ $$ \\frac{\\partial av}{\\partial t}+\\frac{\\partial av^2}{\\partial z}+\\frac{1}{\\rho_f}\\left(\\frac{\\partial ap}{\\partial z}-p\\frac{\\partial a}{\\partial z}\\right)=0 $$ with a=\\pi r^2 a=\\pi r^2 the cross-sectional area of the tube and r r the inner radius. Furthermore, t t is the time, v v the velocity along the axis of the tube, p p the pressure and \\rho_f \\rho_f the density of the fluid. Add the start and end of the tube the boundary conditions have to be applied. Discretizing these equations results in a system of linear algebraic equations which can be solved for the pressure and velocity by performing Newton-Raphson iterations. Inside the solver the kinematic pressure is used, which is the pressure divided by the density of the fluid. For more information about the implementation this solver refer to .","title":"TubeFlow"},{"location":"python/#solver-parameters","text":"The following parameters, listed in alphabetical order, need to be specified in a file with name input_file . This file should be located in the working_directory . Care should be taken that the values of d , e , h , l and rhof match the corresponding values of the structural solver. parameter type description axial_offset double (optional) Distance over which tube is displaced axially in the coordinate system. If not provided, the value of this parameter is 0. d double Nominal diameter of the tube. e double Modulus of elasticity of the tube wall. h double Thickness of tube wall. inlet_boundary dict Dictionary containing all information with respect to the inlet boundary condition. l double Length of the tube. m int Number of cells for discretization. The values are calculated in the cell centers. newtonmax double Maximum number of Newton-Raphson iterations for the flow solver calculation. newtontol double Relative tolerance for the Newton-Raphson iterations for the flow solver calculation. outlet_boundary dict Dictionary containing all information with respect to the outlet boundary condition. preference double (optional) Reference pressure. If not provided, the value of this parameter is 0. ureference double Reference velocity. rhof double Density of the fluid.","title":"Solver parameters"},{"location":"python/#inlet-boundary","text":"This section describes all parameters that need to be specified in the dictionary inlet_boundary , listed in alphabetical order. parameter type description amplitude double Amplitude of the inlet boundary condition. period double Period of the inlet boundary condition. Period of oscillation for a periodic boundary condition, duration for a non-periodic boundary condition. reference double (optional) Reference value of inlet boundary condition. If not provided, the value of this parameter is the corresponding reference value provided above, i.e. ureference or preference . type int Type of inlet boundary condition. If 1, a sine wave is used with amplitude, reference and period as specified. If 2, a pulse is used with amplitude as specified and a duration equal to the parameter period. After the pulse the variable is equal to the reference value. If 3, a quadratic sine wave is used with amplitude, reference and period as specified. If other, a steady increase of the value at the inlet with slope of amplitude divided by period is used. variable string Variable upon which the inlet boundary condition is definded, either 'pressure' or 'velocity'.","title":"Inlet Boundary"},{"location":"python/#outlet-boundary","text":"This section describes all parameters that need to be specified in the dictionary outlet_boundary , listed in alphabetical order. parameter type description type int Type of outlet boundary condition. If 1, a non-reflecting boundary condition is applied. If other, a fixed value equal to the reference pressure is applied.","title":"Outlet Boundary"},{"location":"python/#tuberingmodel","text":"This structure solver calculates the deformation of the wall of a straight and flexible tube. The tube is regarded as made up of independent rings. The required input is the pressure on the tube wall. The resulting output is the radial displacement. The behaviour of the elastic tube wall is described by a Hookean relation, which results in the following equation $$ a=a_0\\left(\\frac{p_0-2c^2_{MK}}{p_0-2c^2_{MK}}\\right)^2 $$ with a=\\pi r^2 a=\\pi r^2 the cross-sectional area of the tube and r r the inner radius. Furthermore, p p the pressure, p_0 p_0 the reference pressure, \\rho_f \\rho_f the density of the fluid and c^2_{MK} c^2_{MK} the Moens-Korteweg wave speed given by $$ c^2_{MK}=\\sqrt{\\frac{Eh}{2\\rho_f r_0}} $$ Here, E E is the modulus of elasticity, h h the thickness of the tube wall and r_0 r_0 the reference radius. No boundary conditions are required. Inside the solver the kinematic pressure is used, which is the pressure divided by the density of the fluid. For more information about the implementation this solver refer to .","title":"TubeRingModel"},{"location":"python/#solver-parameters_1","text":"The following parameters, listed in alphabetical order, need to be specified in a file with name input_file . This file should be located in the working_directory . Care should be taken that the values of d , e , h , l and rhof match the corresponding values of the flow solver. parameter type description axial_offset double (optional) Distance over which tube is displaced axially in the coordinate system. If not provided, the value of this parameter is 0. d double Nominal diameter of the tube. e double Modulus of elasticity of the tube wall. h double Thickness of tube wall. l double Length of the tube. m int Number of cells for discretization. The values are calculated in the cell centers. preference double (optional) Reference pressure. If not provided, the value of this parameter is 0. rhof double Density of the fluid.","title":"Solver parameters"},{"location":"python/#tubestructure","text":"This structure solver calculates the deformation of the wall of a straight and flexible tube. In this model inertia is taken into account, but still only radial displacements are considered. The required input is the pressure on the tube wall. The resulting output is the radial displacement. The deformation of the tube in the radial direction is determined by $$ \\rho_s h\\frac{\\partial^2 r}{\\partial t^2}+b_1\\frac{\\partial^4 r}{\\partial z^4}-b_2\\frac{\\partial^2 r}{\\partial z^2}+b_3(r-r_o)=p-p_o $$ with \\rho_s \\rho_s the solid density and h h the thickness of the tube's wall. Further, r r is the inner radius, p p pressure and t t time. The variables r_0 r_0 and p_0 p_0 are a reference radius and pressure, respectively. The tube is considered clamped at both ends. The parameters b_1 b_1 and b_2 b_2 ( b_1, b_2 \\ge 0 b_1, b_2 \\ge 0 ) account for the inner action of the bending and the axial tension in the wall, while the parameter b_3 b_3 accounts for the circumferential stress in the tube wall. For a thin-walled tube that is clamped in the axial direction, they are defined as $$ b_1=\\frac{hE}{1-\\nu^2}\\frac{h^2}{12} \\textrm{, } b_2=\\frac{hE}{1-\\nu^2}\\frac{h^2}{12}\\frac{2\\nu}{r_o^2} \\textrm{ and } b_3=\\frac{hE}{1-\\nu^2}\\frac{1}{r_o^2}+\\frac{hE}{1-\\nu^2}\\frac{h^2}{12}\\frac{1}{r_o^4} $$ with E E the Young's modulus and \\nu \\nu Poisson's coefficient. The second term of b_3 b_3 is considered small compared to the first one because h\\ll r_o h\\ll r_o and is thus neglected. Discretizing these equations results in a system of linear algebraic equations whit a Jacobian that does not depend on the pressure. The system can be solved for the radius in one step. For more information about the implementation this solver refer to .","title":"TubeStructure"},{"location":"python/#solver-parameters_2","text":"The following parameters, listed in alphabetical order, need to be specified in a file with name input_file .This file should be located in the working_directory . Care should be taken that the values of d , e , h , l and rhof match the corresponding values of the flow solver. parameter type description axial_offset double (optional) Distance over which tube is displaced axially in the coordinate system. If not provided, the value of this parameter is 0. beta double Newmark parameter \\beta \\beta d double Nominal diameter of the tube. e double Modulus of elasticity of the tube wall. h double Thickness of tube wall. gamma double Newmark parameter \\gamma \\gamma . l double Length of the tube. m int Number of cells for discretization. The values are calculated in the cell centers. nu double Poisson's ratio. preference double (optional) Reference pressure. If not provided, the value of this parameter is 0. rhof double Density of the fluid. rhos double Density of the tube wall. The equations are discretized in time with the Newmark method. These require two Newmark parameters \\beta \\beta and \\gamma \\gamma which result in an un-conditionally stable integration scheme if $$ \\gamma\\geq\\frac{1}{2} \\textrm{ and } \\beta\\geq\\frac{1}{4}\\left(\\frac{1}{2}+\\gamma\\right)^2. $$","title":"Solver parameters"},{"location":"test_examples/","text":"TestExamples This documentation describes the different test examples. Currently all these examples calculate the flow in a flexible tube. Folder and file structure This section describes the different folders and files which are provided. run_simulation.py: Main file which has to be run with a parameterfile as argument project_parameters_X.json: Parameter file in json format setup_X: Setup folder containing all files for setting up solver X setup_X.sh: Bash file which has to be run to set up solver X X.md: A description of the specific example When the setup files are run, working directories are created which have to match the ones specified in the parameter file. These folder are expandable and are deleted when the setup files are (re)run. Project Parameters The parameter file project_parameters_X.json contains two dictionaries. The first is settings in which the number of time steps for which the calculation is run is specified. The second is coupled_solver in which all parameters related to solver algorithm are given: coupling algorithm, predictor, convergence criteria and solvers. Running a case In order to run a test example, first, the setup files have to be run to create the working directories. Then, the calculation is started by running run_simulation.py with the parameter file as argument. Debug files The folder test_examples also contains a folder debug_files containing scripts for debug purposes. These files might need some adjustements to work. In order to use them, the debug boolean self.debug has to be True in the code of the corresponding solver wrappers.","title":"TestExample"},{"location":"test_examples/#testexamples","text":"This documentation describes the different test examples. Currently all these examples calculate the flow in a flexible tube.","title":"TestExamples"},{"location":"test_examples/#folder-and-file-structure","text":"This section describes the different folders and files which are provided. run_simulation.py: Main file which has to be run with a parameterfile as argument project_parameters_X.json: Parameter file in json format setup_X: Setup folder containing all files for setting up solver X setup_X.sh: Bash file which has to be run to set up solver X X.md: A description of the specific example When the setup files are run, working directories are created which have to match the ones specified in the parameter file. These folder are expandable and are deleted when the setup files are (re)run.","title":"Folder and file structure"},{"location":"test_examples/#project-parameters","text":"The parameter file project_parameters_X.json contains two dictionaries. The first is settings in which the number of time steps for which the calculation is run is specified. The second is coupled_solver in which all parameters related to solver algorithm are given: coupling algorithm, predictor, convergence criteria and solvers.","title":"Project Parameters"},{"location":"test_examples/#running-a-case","text":"In order to run a test example, first, the setup files have to be run to create the working directories. Then, the calculation is started by running run_simulation.py with the parameter file as argument.","title":"Running a case"},{"location":"test_examples/#debug-files","text":"The folder test_examples also contains a folder debug_files containing scripts for debug purposes. These files might need some adjustements to work. In order to use them, the debug boolean self.debug has to be True in the code of the corresponding solver wrappers.","title":"Debug files"},{"location":"tube_fluent2d_abaqus2d/","text":"Tube case with Fluent2D and Abaqus2D This example calculates the flow inside and the deformation and stresses of a straight flexible tube, where a pressure pulse is applied at the inlet. This done by using Fluent and Abaqus, both on an axisymmetric case. Coupling algorithm The coupling technique used is the interface quasi-Newton algorithm with an approximation for the inverse of the Jacobian from a least-squares model (IQNI-LS). Predictors The initial guess in every time step is done using the linear predictor. Convergence criterion Two convergence criteria have been specified: - The number of iterations in every time step is larger than 10. - The residual norm on the displacement is a factor 10^{-4} 10^{-4} lower than the initial value. When either criterion is satisfied the simulation stops. Solvers The flow solver is Fluent, used to solve an axisymmetric representation of the tube, with 100 cells on the fluid-structure interface. When setting up the case, the mesh is build based on the file mesh.jou using Gambit. The displacements are applied in the nodes, of which there are 101. In contrast, the loads (pressure and traction) are calculated in the cell centers, of which there are 100. The axial direction is along the x-axis, the radial direction along the y-axis. The structure solver is Abaqus, used to solve an axisymmetric representation of the tube, with 50 elements on the fluid-structure interface. The Abaqus case is not build when setting up the case, but is provided as the file Base.inp . The Abaqus element type used is CAX8RH. These are continuum elements for axisymmetric calculations, for stress and displacement without twist. They are: 8-node biquadratic, reduced integration, hybrid with linear pressure. See Abaqus documentaion for more information. The loads are applied on the faces in three points per element, which means on 150 load points in total. The displacement is calculated in the nodes. There are 101 nodes on the fluid-structure interface. The axial direction is along the y-axis, the radial direction along the x-axis. The difference in reference frames and number of cells on the fluid-structure interface requires the use of mappers. In the structure solver wrapper, a permutation mapper is introduced to match the coordinate frames, flipping the x- and y-axis of the input. Thereafter, a linear interpolation mapper is used to interpolate in the x- and y-direction from the 100 cell centers of Fluent to the 150 load points in Abaqus. For the output the same is done in the opposite order: first interpolating and then flipping the axes.","title":"Fluent 2D - Abaqus 2D"},{"location":"tube_fluent2d_abaqus2d/#tube-case-with-fluent2d-and-abaqus2d","text":"This example calculates the flow inside and the deformation and stresses of a straight flexible tube, where a pressure pulse is applied at the inlet. This done by using Fluent and Abaqus, both on an axisymmetric case.","title":"Tube case with Fluent2D and Abaqus2D"},{"location":"tube_fluent2d_abaqus2d/#coupling-algorithm","text":"The coupling technique used is the interface quasi-Newton algorithm with an approximation for the inverse of the Jacobian from a least-squares model (IQNI-LS).","title":"Coupling algorithm"},{"location":"tube_fluent2d_abaqus2d/#predictors","text":"The initial guess in every time step is done using the linear predictor.","title":"Predictors"},{"location":"tube_fluent2d_abaqus2d/#convergence-criterion","text":"Two convergence criteria have been specified: - The number of iterations in every time step is larger than 10. - The residual norm on the displacement is a factor 10^{-4} 10^{-4} lower than the initial value. When either criterion is satisfied the simulation stops.","title":"Convergence criterion"},{"location":"tube_fluent2d_abaqus2d/#solvers","text":"The flow solver is Fluent, used to solve an axisymmetric representation of the tube, with 100 cells on the fluid-structure interface. When setting up the case, the mesh is build based on the file mesh.jou using Gambit. The displacements are applied in the nodes, of which there are 101. In contrast, the loads (pressure and traction) are calculated in the cell centers, of which there are 100. The axial direction is along the x-axis, the radial direction along the y-axis. The structure solver is Abaqus, used to solve an axisymmetric representation of the tube, with 50 elements on the fluid-structure interface. The Abaqus case is not build when setting up the case, but is provided as the file Base.inp . The Abaqus element type used is CAX8RH. These are continuum elements for axisymmetric calculations, for stress and displacement without twist. They are: 8-node biquadratic, reduced integration, hybrid with linear pressure. See Abaqus documentaion for more information. The loads are applied on the faces in three points per element, which means on 150 load points in total. The displacement is calculated in the nodes. There are 101 nodes on the fluid-structure interface. The axial direction is along the y-axis, the radial direction along the x-axis. The difference in reference frames and number of cells on the fluid-structure interface requires the use of mappers. In the structure solver wrapper, a permutation mapper is introduced to match the coordinate frames, flipping the x- and y-axis of the input. Thereafter, a linear interpolation mapper is used to interpolate in the x- and y-direction from the 100 cell centers of Fluent to the 150 load points in Abaqus. For the output the same is done in the opposite order: first interpolating and then flipping the axes.","title":"Solvers"},{"location":"tube_fluent2d_tube_structure/","text":"Tube case with Fluent2D and TubeStructure This example calculates the flow inside and the deformation and stresses of a straight flexible tube, where a pressure pulse is applied at the inlet. This done by using Fluent (axisymmetric) and the Python solver TubeStructure. Coupling algorithm The coupling technique used is the interface quasi-Newton algorithm with an approximation for the inverse of the Jacobian from a least-squares model (IQNI-LS). Predictors The initial guess in every time step is done using the linear predictor. Convergence criterion Two convergence criteria have been specified: - The number of iterations in every time step is larger than 15. - The residual norm on the displacement is a factor 10^{-6} 10^{-6} lower than the initial value. When either criterion is satisfied the simulation stops. Solvers The flow solver is Fluent, used to solve an axisymmetric representation of the tube, with 100 cells on the fluid-structure interface. When setting up the case, the mesh is build based on the file mesh.jou using Gambit. The displacements are applied in the nodes, of which there are 101. In contrast, the loads (pressure and traction) are calculated in the cell centers, of which there are 100. The axial direction is along the x-axis, the radial direction along the y-axis. The structure solver is the Python solver TubeStructure, which implements a 1D model of the tube wall, with 100 elements on the fluid-structure interface. The parameters for this model are specified in the setup folder by the file solver_parameter.json . The loads, in fact only pressure for this 1D case, are applied on the cell centers. The displacements are calculated in the cell centers as well. Only the radial displacement is different from zero. The axial direction is along the z-axis, the radial direction along the y-axis. Whereas for Fluent the origin is situated axially in the center of the tube, for TubeStructure the origin is located at the start. Therefore, the parameter axial_offset is used in its solver_parameter.json file to correct for this. The difference in reference frames and number of cells on the fluid-structure interface requires the use of mappers. In the structure solver wrapper, a permutation mapper is introduced to match the coordinate frames, flipping the x- and z-axis of the input. Thereafter, a linear interpolation mapper is used to interpolate in the y- and z-direction from the 100 cell centers of Fluent to the 100 cell centers of TubeStructure. For the output the same is done in the opposite order: first interpolating and then flipping the axes.","title":"Fluent 2D - Python"},{"location":"tube_fluent2d_tube_structure/#tube-case-with-fluent2d-and-tubestructure","text":"This example calculates the flow inside and the deformation and stresses of a straight flexible tube, where a pressure pulse is applied at the inlet. This done by using Fluent (axisymmetric) and the Python solver TubeStructure.","title":"Tube case with Fluent2D and TubeStructure"},{"location":"tube_fluent2d_tube_structure/#coupling-algorithm","text":"The coupling technique used is the interface quasi-Newton algorithm with an approximation for the inverse of the Jacobian from a least-squares model (IQNI-LS).","title":"Coupling algorithm"},{"location":"tube_fluent2d_tube_structure/#predictors","text":"The initial guess in every time step is done using the linear predictor.","title":"Predictors"},{"location":"tube_fluent2d_tube_structure/#convergence-criterion","text":"Two convergence criteria have been specified: - The number of iterations in every time step is larger than 15. - The residual norm on the displacement is a factor 10^{-6} 10^{-6} lower than the initial value. When either criterion is satisfied the simulation stops.","title":"Convergence criterion"},{"location":"tube_fluent2d_tube_structure/#solvers","text":"The flow solver is Fluent, used to solve an axisymmetric representation of the tube, with 100 cells on the fluid-structure interface. When setting up the case, the mesh is build based on the file mesh.jou using Gambit. The displacements are applied in the nodes, of which there are 101. In contrast, the loads (pressure and traction) are calculated in the cell centers, of which there are 100. The axial direction is along the x-axis, the radial direction along the y-axis. The structure solver is the Python solver TubeStructure, which implements a 1D model of the tube wall, with 100 elements on the fluid-structure interface. The parameters for this model are specified in the setup folder by the file solver_parameter.json . The loads, in fact only pressure for this 1D case, are applied on the cell centers. The displacements are calculated in the cell centers as well. Only the radial displacement is different from zero. The axial direction is along the z-axis, the radial direction along the y-axis. Whereas for Fluent the origin is situated axially in the center of the tube, for TubeStructure the origin is located at the start. Therefore, the parameter axial_offset is used in its solver_parameter.json file to correct for this. The difference in reference frames and number of cells on the fluid-structure interface requires the use of mappers. In the structure solver wrapper, a permutation mapper is introduced to match the coordinate frames, flipping the x- and z-axis of the input. Thereafter, a linear interpolation mapper is used to interpolate in the y- and z-direction from the 100 cell centers of Fluent to the 100 cell centers of TubeStructure. For the output the same is done in the opposite order: first interpolating and then flipping the axes.","title":"Solvers"},{"location":"tube_fluent3d_abaqus2d/","text":"Tube case with Fluent2D and Abaqus2D This example calculates the flow inside and the deformation and stresses of a straight flexible tube, where a pressure pulse is applied at the inlet. This done by using Fluent (3D case) and Abaqus (axisymmetric case). Coupling algorithm The coupling technique used is the interface quasi-Newton algorithm with an approximation for the inverse of the Jacobian from a least-squares model (IQNI-LS). Predictors The initial guess in every time step is done using the linear predictor. Convergence criterion Two convergence criteria have been specified: - The number of iterations in every time step is larger than 20. - The residual norm on the displacement is a factor 10^{-3} 10^{-3} lower than the initial value. When either criterion is satisfied the simulation stops. Solvers The flow solver is Fluent, used to solve a fully 3D tube, with 48 cells on the fluid-structure interface in the length-wise direction and 8 in the circumferential direction. When setting up the case, the mesh is build based on the file mesh.jou using Gambit. The displacements are applied in the nodes. In contrast, the loads (pressure and traction) are calculated in the cell centers. The axial direction is along the x-axis, the radial direction along the y-axis. The structure solver is Abaqus, used to solve an axisymmetric representation of the tube, with 50 elements on the fluid-structure interface. The Abaqus case is not build when setting up the case, but is provided as the file Base.inp . The Abaqus element type used is CAX8RH. These are continuum elements for axisymmetric calculations, for stress and displacement without twist. They are: 8-node biquadratic, reduced integration, hybrid with linear pressure. See Abaqus documentaion for more information. The loads are applied on the faces in three points per element, which means on 150 load points in total. The displacement is calculated in the nodes. There are 101 nodes on the fluid-structure interface. The axial direction is along the y-axis, the radial direction along the x-axis. The difference in reference frames and number of cells on the fluid-structure interface, but also the difference in dimensions require the use of mappers, In the structure solver wrapper, a permutation mapper is introduced to match the coordinate frames, flipping the x- and y-axis of the input. Thereafter, a radial basis mapper is used to interpolate in the x-, y- and z-direction from the loads coming from Fluent to a temporary 3D interface corresponding to Abaqus. Finally a mapper is added to go from 3D to 2D. For the output the same is done in the opposite order: first going from 2D to 3D, then interpolating and finally flipping the axes.","title":"Fluent 3D - Abaqus 2D"},{"location":"tube_fluent3d_abaqus2d/#tube-case-with-fluent2d-and-abaqus2d","text":"This example calculates the flow inside and the deformation and stresses of a straight flexible tube, where a pressure pulse is applied at the inlet. This done by using Fluent (3D case) and Abaqus (axisymmetric case).","title":"Tube case with Fluent2D and Abaqus2D"},{"location":"tube_fluent3d_abaqus2d/#coupling-algorithm","text":"The coupling technique used is the interface quasi-Newton algorithm with an approximation for the inverse of the Jacobian from a least-squares model (IQNI-LS).","title":"Coupling algorithm"},{"location":"tube_fluent3d_abaqus2d/#predictors","text":"The initial guess in every time step is done using the linear predictor.","title":"Predictors"},{"location":"tube_fluent3d_abaqus2d/#convergence-criterion","text":"Two convergence criteria have been specified: - The number of iterations in every time step is larger than 20. - The residual norm on the displacement is a factor 10^{-3} 10^{-3} lower than the initial value. When either criterion is satisfied the simulation stops.","title":"Convergence criterion"},{"location":"tube_fluent3d_abaqus2d/#solvers","text":"The flow solver is Fluent, used to solve a fully 3D tube, with 48 cells on the fluid-structure interface in the length-wise direction and 8 in the circumferential direction. When setting up the case, the mesh is build based on the file mesh.jou using Gambit. The displacements are applied in the nodes. In contrast, the loads (pressure and traction) are calculated in the cell centers. The axial direction is along the x-axis, the radial direction along the y-axis. The structure solver is Abaqus, used to solve an axisymmetric representation of the tube, with 50 elements on the fluid-structure interface. The Abaqus case is not build when setting up the case, but is provided as the file Base.inp . The Abaqus element type used is CAX8RH. These are continuum elements for axisymmetric calculations, for stress and displacement without twist. They are: 8-node biquadratic, reduced integration, hybrid with linear pressure. See Abaqus documentaion for more information. The loads are applied on the faces in three points per element, which means on 150 load points in total. The displacement is calculated in the nodes. There are 101 nodes on the fluid-structure interface. The axial direction is along the y-axis, the radial direction along the x-axis. The difference in reference frames and number of cells on the fluid-structure interface, but also the difference in dimensions require the use of mappers, In the structure solver wrapper, a permutation mapper is introduced to match the coordinate frames, flipping the x- and y-axis of the input. Thereafter, a radial basis mapper is used to interpolate in the x-, y- and z-direction from the loads coming from Fluent to a temporary 3D interface corresponding to Abaqus. Finally a mapper is added to go from 3D to 2D. For the output the same is done in the opposite order: first going from 2D to 3D, then interpolating and finally flipping the axes.","title":"Solvers"},{"location":"tube_fluent3d_abaqus3d/","text":"Tube case with Fluent2D and Abaqus2D This example calculates the flow inside and the deformation and stresses of a straight flexible tube, where a pressure pulse is applied at the inlet. This done by using Fluent and Abaqus, both with a fully 3D case. Coupling algorithm The coupling technique used is the interface quasi-Newton algorithm with an approximation for the inverse of the Jacobian from a least-squares model (IQNI-LS). Predictors The initial guess in every time step is done using the linear predictor. Convergence criterion Two convergence criteria have been specified: - The number of iterations in every time step is larger than 20. - The residual norm on the displacement is a factor 10^{-3} 10^{-3} lower than the initial value. When either criterion is satisfied the simulation stops. Solvers The flow solver is Fluent, used to solve a fully 3D tube, with 48 cells on the fluid-structure interface in the length-wise direction and 8 in the circumferential direction. When setting up the case, the mesh is build based on the file mesh.jou using Gambit. The displacements are applied in the nodes. In contrast, the loads (pressure and traction) are calculated in the cell centers. The axial direction is along the x-axis, the radial direction along the y-axis. The structure solver is Abaqus, used to solve a fully 3D tube, with 12 elements on the fluid-structure interface in the length-wise direction and 8 in the circumferential direction. The Abaqus case is not build when setting up the case, but is provided as the file Base.inp . The Abaqus element type used is S8R. These are 8-node shell elements. The R refers to reduced integration. See Abaqus documentation for more information. The loads are applied on the faces in 9 points per element, which means on 864 load points in total. The displacement is calculated in the nodes. There are 304 nodes on the fluid-structure interface. The axial direction is along the x-axis, the radial direction along the y-axis. The coordinate frames of both solvers are the same so there is no need for a permutation mapper. In contrast, the difference of the points where loads and displacements are applied or calculated, require the use of interpolation mappers. Therefore, a radial basis mapper is introduced in the structure solver to interpolate in the x-, y- and z-direction.","title":"Fluent 3D - Abaqus 3D"},{"location":"tube_fluent3d_abaqus3d/#tube-case-with-fluent2d-and-abaqus2d","text":"This example calculates the flow inside and the deformation and stresses of a straight flexible tube, where a pressure pulse is applied at the inlet. This done by using Fluent and Abaqus, both with a fully 3D case.","title":"Tube case with Fluent2D and Abaqus2D"},{"location":"tube_fluent3d_abaqus3d/#coupling-algorithm","text":"The coupling technique used is the interface quasi-Newton algorithm with an approximation for the inverse of the Jacobian from a least-squares model (IQNI-LS).","title":"Coupling algorithm"},{"location":"tube_fluent3d_abaqus3d/#predictors","text":"The initial guess in every time step is done using the linear predictor.","title":"Predictors"},{"location":"tube_fluent3d_abaqus3d/#convergence-criterion","text":"Two convergence criteria have been specified: - The number of iterations in every time step is larger than 20. - The residual norm on the displacement is a factor 10^{-3} 10^{-3} lower than the initial value. When either criterion is satisfied the simulation stops.","title":"Convergence criterion"},{"location":"tube_fluent3d_abaqus3d/#solvers","text":"The flow solver is Fluent, used to solve a fully 3D tube, with 48 cells on the fluid-structure interface in the length-wise direction and 8 in the circumferential direction. When setting up the case, the mesh is build based on the file mesh.jou using Gambit. The displacements are applied in the nodes. In contrast, the loads (pressure and traction) are calculated in the cell centers. The axial direction is along the x-axis, the radial direction along the y-axis. The structure solver is Abaqus, used to solve a fully 3D tube, with 12 elements on the fluid-structure interface in the length-wise direction and 8 in the circumferential direction. The Abaqus case is not build when setting up the case, but is provided as the file Base.inp . The Abaqus element type used is S8R. These are 8-node shell elements. The R refers to reduced integration. See Abaqus documentation for more information. The loads are applied on the faces in 9 points per element, which means on 864 load points in total. The displacement is calculated in the nodes. There are 304 nodes on the fluid-structure interface. The axial direction is along the x-axis, the radial direction along the y-axis. The coordinate frames of both solvers are the same so there is no need for a permutation mapper. In contrast, the difference of the points where loads and displacements are applied or calculated, require the use of interpolation mappers. Therefore, a radial basis mapper is introduced in the structure solver to interpolate in the x-, y- and z-direction.","title":"Solvers"},{"location":"tube_tube_flow_abaqus2d/","text":"Tube case with TubeFlow and Abaqus2D This example calculates the flow inside and the deformation and stresses of a straight flexible tube, where a pressure pulse is applied at the inlet. This done by using Python solver TubeFlow and Abaqus (axisymmetric). Coupling algorithm The coupling technique used is the interface quasi-Newton algorithm with an approximation for the inverse of the Jacobian from a least-squares model (IQNI-LS). Predictors The initial guess in every time step is done using the linear predictor. Convergence criterion Two convergence criteria have been specified: - The number of iterations in every time step is larger than 15. - The residual norm on the displacement is a factor 10^{-6} 10^{-6} lower than the initial value. When either criterion is satisfied the simulation stops. Solvers The flow solver is the Python solver TubeFlow, which implements a 1D model of the flow inside the tube, with 100 cells on the fluid-structure interface. The parameters for this model are specified in the setup folder by the file solver_parameter.json . The (radial) displacements are applied on the cell centers. The loads, in fact are only pressure for this 1D case, are calculated in the cell centers as well. The axial direction is along the z-axis, the radial direction along the y-axis. The structure solver is Abaqus, used to solve an axisymmetric representation of the tube, with 50 elements on the fluid-structure interface. The Abaqus case is not build when setting up the case, but is provided as the file Base.inp . The Abaqus element type used is CAX8RH. These are continuum elements for axisymmetric calculations, for stress and displacement without twist. They are: 8-node biquadratic, reduced integration, hybrid with linear pressure. See Abaqus documentaion for more information. The loads are applied on the faces in three points per element, which means on 150 load points in total. The displacement is calculated in the nodes. There are 101 nodes on the fluid-structure interface. The axial direction is along the y-axis, the radial direction along the x-axis. The difference in reference frames and number of cells on the fluid-structure interface requires the use of mappers. In the structure solver wrapper, a permutation mapper is introduced to match the coordinate frames. The new x-axis corresponds to y-axis of the incomming loads the new y-axis corresponds to the z-axis and the new z-axis to the x-axis. Thereafter, a linear interpolation mapper is used to interpolate in the x- and y-direction from the 100 cell centers of TubeFlow to the 150 load points in Abaqus. For the output the same is done in the opposite order: first interpolating and then swapping the axes. So the new x-axis is the z-axis of the displacements calculated by Abaqus, the new y-axis corresponds to the x-axis and the new z-axis to the y-axis.","title":"Python TubeFlow - Abaqus 2D"},{"location":"tube_tube_flow_abaqus2d/#tube-case-with-tubeflow-and-abaqus2d","text":"This example calculates the flow inside and the deformation and stresses of a straight flexible tube, where a pressure pulse is applied at the inlet. This done by using Python solver TubeFlow and Abaqus (axisymmetric).","title":"Tube case with TubeFlow and Abaqus2D"},{"location":"tube_tube_flow_abaqus2d/#coupling-algorithm","text":"The coupling technique used is the interface quasi-Newton algorithm with an approximation for the inverse of the Jacobian from a least-squares model (IQNI-LS).","title":"Coupling algorithm"},{"location":"tube_tube_flow_abaqus2d/#predictors","text":"The initial guess in every time step is done using the linear predictor.","title":"Predictors"},{"location":"tube_tube_flow_abaqus2d/#convergence-criterion","text":"Two convergence criteria have been specified: - The number of iterations in every time step is larger than 15. - The residual norm on the displacement is a factor 10^{-6} 10^{-6} lower than the initial value. When either criterion is satisfied the simulation stops.","title":"Convergence criterion"},{"location":"tube_tube_flow_abaqus2d/#solvers","text":"The flow solver is the Python solver TubeFlow, which implements a 1D model of the flow inside the tube, with 100 cells on the fluid-structure interface. The parameters for this model are specified in the setup folder by the file solver_parameter.json . The (radial) displacements are applied on the cell centers. The loads, in fact are only pressure for this 1D case, are calculated in the cell centers as well. The axial direction is along the z-axis, the radial direction along the y-axis. The structure solver is Abaqus, used to solve an axisymmetric representation of the tube, with 50 elements on the fluid-structure interface. The Abaqus case is not build when setting up the case, but is provided as the file Base.inp . The Abaqus element type used is CAX8RH. These are continuum elements for axisymmetric calculations, for stress and displacement without twist. They are: 8-node biquadratic, reduced integration, hybrid with linear pressure. See Abaqus documentaion for more information. The loads are applied on the faces in three points per element, which means on 150 load points in total. The displacement is calculated in the nodes. There are 101 nodes on the fluid-structure interface. The axial direction is along the y-axis, the radial direction along the x-axis. The difference in reference frames and number of cells on the fluid-structure interface requires the use of mappers. In the structure solver wrapper, a permutation mapper is introduced to match the coordinate frames. The new x-axis corresponds to y-axis of the incomming loads the new y-axis corresponds to the z-axis and the new z-axis to the x-axis. Thereafter, a linear interpolation mapper is used to interpolate in the x- and y-direction from the 100 cell centers of TubeFlow to the 150 load points in Abaqus. For the output the same is done in the opposite order: first interpolating and then swapping the axes. So the new x-axis is the z-axis of the displacements calculated by Abaqus, the new y-axis corresponds to the x-axis and the new z-axis to the y-axis.","title":"Solvers"},{"location":"tube_tube_flow_tube_ringmodel/","text":"Tube case with TubeFlow and TubeStructure This example calculates the flow inside and the deformation and stresses of a straight flexible tube, where a sinusoidal velocity is specified at the inlet. This done by using Python solvers TubeFlow and TubeRingmodel. Coupling algorithm The coupling technique used is the interface quasi-Newton algorithm with an approximation for the inverse of the Jacobian from a least-squares model (IQNI-LS). Predictors The initial guess in every time step is done using the linear predictor. Convergence criterion Two convergence criteria have been specified: - The number of iterations in every time step is larger than 15. - The residual norm on the displacement is a factor 10^{-6} 10^{-6} lower than the initial value. When either criterion is satisfied the simulation stops. Solvers The flow solver is the Python solver TubeFlow, which implements a 1D model of the flow inside the tube, with 100 cells on the fluid-structure interface. The parameters for this model are specified in the setup folder by the file solver_parameter.json . The (radial) displacements are applied on the cell centers. The loads, in fact are only pressure for this 1D case, are calculated in the cell centers as well. The axial direction is along the z-axis, the radial direction along the y-axis. The structure solver is the Python solver TubeRingmodel, which implements a 1D model of the tube wall, with 100 elements on the fluid-structure interface. It differs from the Python solver TubeStructure as the no inertia is considered. The tube is regarded as consisting out of 100 independent rings. The parameters for this model are specified in the setup folder by the file solver_parameter.json . The loads, which in fact only pressure for this 1D case, are applied on the cell centers. The displacements are calculated in the cell centers as well. Only the radial displacement is different from zero. The axial direction is along the z-axis, the radial direction along the y-axis. The coordinate frames of both solvers are the same so there is no need for a permutation mapper. In contrast, the difference of the points where loads and displacements are applied or calculated, require the use of interpolation mappers. Therefore, a linear interpolation mapper is introduced in the structure solver to interpolate in the x-direction. A parameter file project_parameters_conformal.json is also provided. This parameter file performs no interpolation. It should be verified that the number of cells m are the same in both solvers before using it.","title":"Python TubeFlow - Python TubeRingmodel"},{"location":"tube_tube_flow_tube_ringmodel/#tube-case-with-tubeflow-and-tubestructure","text":"This example calculates the flow inside and the deformation and stresses of a straight flexible tube, where a sinusoidal velocity is specified at the inlet. This done by using Python solvers TubeFlow and TubeRingmodel.","title":"Tube case with TubeFlow and TubeStructure"},{"location":"tube_tube_flow_tube_ringmodel/#coupling-algorithm","text":"The coupling technique used is the interface quasi-Newton algorithm with an approximation for the inverse of the Jacobian from a least-squares model (IQNI-LS).","title":"Coupling algorithm"},{"location":"tube_tube_flow_tube_ringmodel/#predictors","text":"The initial guess in every time step is done using the linear predictor.","title":"Predictors"},{"location":"tube_tube_flow_tube_ringmodel/#convergence-criterion","text":"Two convergence criteria have been specified: - The number of iterations in every time step is larger than 15. - The residual norm on the displacement is a factor 10^{-6} 10^{-6} lower than the initial value. When either criterion is satisfied the simulation stops.","title":"Convergence criterion"},{"location":"tube_tube_flow_tube_ringmodel/#solvers","text":"The flow solver is the Python solver TubeFlow, which implements a 1D model of the flow inside the tube, with 100 cells on the fluid-structure interface. The parameters for this model are specified in the setup folder by the file solver_parameter.json . The (radial) displacements are applied on the cell centers. The loads, in fact are only pressure for this 1D case, are calculated in the cell centers as well. The axial direction is along the z-axis, the radial direction along the y-axis. The structure solver is the Python solver TubeRingmodel, which implements a 1D model of the tube wall, with 100 elements on the fluid-structure interface. It differs from the Python solver TubeStructure as the no inertia is considered. The tube is regarded as consisting out of 100 independent rings. The parameters for this model are specified in the setup folder by the file solver_parameter.json . The loads, which in fact only pressure for this 1D case, are applied on the cell centers. The displacements are calculated in the cell centers as well. Only the radial displacement is different from zero. The axial direction is along the z-axis, the radial direction along the y-axis. The coordinate frames of both solvers are the same so there is no need for a permutation mapper. In contrast, the difference of the points where loads and displacements are applied or calculated, require the use of interpolation mappers. Therefore, a linear interpolation mapper is introduced in the structure solver to interpolate in the x-direction. A parameter file project_parameters_conformal.json is also provided. This parameter file performs no interpolation. It should be verified that the number of cells m are the same in both solvers before using it.","title":"Solvers"},{"location":"tube_tube_flow_tube_structure/","text":"Tube case with TubeFlow and TubeStructure This example calculates the flow inside and the deformation and stresses of a straight flexible tube, where a pressure pulse is applied at the inlet. This done by using Python solvers TubeFlow and TubeStructure. Coupling algorithm The coupling technique used is the interface quasi-Newton algorithm with an approximation for the inverse of the Jacobian from a least-squares model (IQNI-LS). Predictors The initial guess in every time step is done using the linear predictor. Convergence criterion Two convergence criteria have been specified: - The number of iterations in every time step is larger than 15. - The residual norm on the displacement is a factor 10^{-6} 10^{-6} lower than the initial value. When either criterion is satisfied the simulation stops. Solvers The flow solver is the Python solver TubeFlow, which implements a 1D model of the flow inside the tube, with 100 cells on the fluid-structure interface. The parameters for this model are specified in the setup folder by the file solver_parameter.json . The (radial) displacements are applied on the cell centers. The loads, in fact are only pressure for this 1D case, are calculated in the cell centers as well. The axial direction is along the z-axis, the radial direction along the y-axis. The structure solver is the Python solver TubeStructure, which implements a 1D model of the tube wall, with 100 elements on the fluid-structure interface. The parameters for this model are specified in the setup folder by the file solver_parameter.json . The loads, which in fact only pressure for this 1D case, are applied on the cell centers. The displacements are calculated in the cell centers as well. Only the radial displacement is different from zero. The axial direction is along the z-axis, the radial direction along the y-axis. The coordinate frames of both solvers are the same so there is no need for a permutation mapper. As both solver has the 100 cells on the fluid-structure interface, no interpolation is required and the parameter file project_parameters_conformal.json can be used. A parameter file project_parameters_mapped.json is also provided, which can be used i the number of cells m is set differently in the two solvers. Then, a linear interpolation mapper is introduced in the structure solver to interpolate in the x-direction.","title":"Python TubeFlow - Python TubeStructre"},{"location":"tube_tube_flow_tube_structure/#tube-case-with-tubeflow-and-tubestructure","text":"This example calculates the flow inside and the deformation and stresses of a straight flexible tube, where a pressure pulse is applied at the inlet. This done by using Python solvers TubeFlow and TubeStructure.","title":"Tube case with TubeFlow and TubeStructure"},{"location":"tube_tube_flow_tube_structure/#coupling-algorithm","text":"The coupling technique used is the interface quasi-Newton algorithm with an approximation for the inverse of the Jacobian from a least-squares model (IQNI-LS).","title":"Coupling algorithm"},{"location":"tube_tube_flow_tube_structure/#predictors","text":"The initial guess in every time step is done using the linear predictor.","title":"Predictors"},{"location":"tube_tube_flow_tube_structure/#convergence-criterion","text":"Two convergence criteria have been specified: - The number of iterations in every time step is larger than 15. - The residual norm on the displacement is a factor 10^{-6} 10^{-6} lower than the initial value. When either criterion is satisfied the simulation stops.","title":"Convergence criterion"},{"location":"tube_tube_flow_tube_structure/#solvers","text":"The flow solver is the Python solver TubeFlow, which implements a 1D model of the flow inside the tube, with 100 cells on the fluid-structure interface. The parameters for this model are specified in the setup folder by the file solver_parameter.json . The (radial) displacements are applied on the cell centers. The loads, in fact are only pressure for this 1D case, are calculated in the cell centers as well. The axial direction is along the z-axis, the radial direction along the y-axis. The structure solver is the Python solver TubeStructure, which implements a 1D model of the tube wall, with 100 elements on the fluid-structure interface. The parameters for this model are specified in the setup folder by the file solver_parameter.json . The loads, which in fact only pressure for this 1D case, are applied on the cell centers. The displacements are calculated in the cell centers as well. Only the radial displacement is different from zero. The axial direction is along the z-axis, the radial direction along the y-axis. The coordinate frames of both solvers are the same so there is no need for a permutation mapper. As both solver has the 100 cells on the fluid-structure interface, no interpolation is required and the parameter file project_parameters_conformal.json can be used. A parameter file project_parameters_mapped.json is also provided, which can be used i the number of cells m is set differently in the two solvers. Then, a linear interpolation mapper is introduced in the structure solver to interpolate in the x-direction.","title":"Solvers"}]}